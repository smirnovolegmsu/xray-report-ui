<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xray Admin Panel</title>
<!-- amCharts 5 - –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ (–±–µ—Å–ø–ª–∞—Ç–Ω–æ –¥–ª—è –Ω–µ–∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è) -->
<script src="https://cdn.amcharts.com/lib/5/index.js"></script>
<script src="https://cdn.amcharts.com/lib/5/xy.js"></script>
<script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>
<script src="https://cdn.amcharts.com/lib/5/themes/Dark.js"></script>
<!-- ApexCharts - –∫—Ä–∞—Å–∏–≤–∞—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤ -->
<script src="https://cdn.jsdelivr.net/npm/apexcharts@3.44.0/dist/apexcharts.min.js"></script>
<!-- D3.js –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–π (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ Recharts –∏ Observable) -->
<!-- –í–ê–ñ–ù–û: D3 –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω –î–û Observable Plot -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
<!-- Observable Plot - —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö -->
<!-- –ò—Å–ø–æ–ª—å–∑—É–µ–º UMD —Å defer, —á—Ç–æ–±—ã D3 —É—Å–ø–µ–ª –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è -->
<script defer src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6.17/dist/plot.umd.min.js"></script>
<script>
// –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥—Ä—É–∑–∫—É Observable Plot –ø–æ—Å–ª–µ load —Å–æ–±—ã—Ç–∏—è (–∫–æ–≥–¥–∞ –≤—Å–µ defer —Å–∫—Ä–∏–ø—Ç—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã)
window.addEventListener('load', function() {
  console.log('üîç Checking Observable Plot availability after load...');
  console.log('typeof Plot:', typeof Plot);
  console.log('window.Plot:', window.Plot);
  console.log('typeof d3:', typeof d3);
  
  if (typeof Plot !== 'undefined' && typeof Plot.plot === 'function') {
    // –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ Plot –¥–æ—Å—Ç—É–ø–µ–Ω –≥–ª–æ–±–∞–ª—å–Ω–æ
    if (typeof window.Plot === 'undefined') {
      window.Plot = Plot;
    }
    console.log('‚úÖ Observable Plot loaded successfully!');
    console.log('Plot keys:', Object.keys(Plot).slice(0, 20));
    console.log('Plot.plot:', typeof Plot.plot);
    console.log('Plot.ruleY:', typeof Plot.ruleY);
    console.log('Plot.ruleX:', typeof Plot.ruleX);
    console.log('Plot.areaY:', typeof Plot.areaY);
    console.log('Plot.lineY:', typeof Plot.lineY);
    console.log('Plot.dot:', typeof Plot.dot);
    console.log('Plot.barX:', typeof Plot.barX);
  } else {
    console.error('‚ùå Observable Plot failed to load!');
    console.error('Plot object:', Plot);
    console.error('Plot keys:', Object.keys(Plot || {}));
    console.error('Available window properties:', Object.keys(window).filter(k => k.toLowerCase().includes('plot') || k.toLowerCase().includes('observable')));
  }
});
</script>
<!-- Highcharts - –ø—Ä–µ–º–∏—É–º –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏ -->
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>
<!-- Vega-Lite - —á–∏—Å—Ç—ã–π BI-–º–∏–Ω–∏–º–∞–ª–∏–∑–º -->
<script src="https://cdn.jsdelivr.net/npm/vega@5.22.1/build/vega.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@5.6.1/build/vega-lite.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@6.21.0/build/vega-embed.min.js"></script>
<style>
:root {
  --bg: #0d1117;
  --panel: #161b22;
  --panel2: #21262d;
  --text: #e6edf3;
  --muted: #8b949e;
  --accent: #58a6ff;
  --accent-light: rgba(88, 166, 255, 0.3);
  --accent-gradient: linear-gradient(135deg, #58a6ff 0%, #3d8bfd 100%);
  --ok: #3fb950;
  --ok-light: rgba(63, 185, 80, 0.2);
  --warn: #d29922;
  --bad: #f85149;
  --bad-light: rgba(248, 81, 73, 0.2);
  --line: #30363d;
  --grid: rgba(48, 54, 61, 0.5);
  --radius: 12px;
  --shadow: 0 8px 24px rgba(0,0,0,.4);
  --bar-normal: rgba(88, 166, 255, 0.6);
  --bar-anomaly: rgba(248, 81, 73, 0.6);
  --bar-border: rgba(88, 166, 255, 0.9);
}
[data-theme="light"] {
  --bg: #f6f8fa;
  --panel: #ffffff;
  --panel2: #f6f8fa;
  --text: #24292f;
  --muted: #57606a;
  --accent: #0969da;
  --accent-light: rgba(9, 105, 218, 0.15);
  --accent-gradient: linear-gradient(135deg, #0969da 0%, #0550ae 100%);
  --ok: #1a7f37;
  --ok-light: rgba(26, 127, 55, 0.15);
  --warn: #9a6700;
  --bad: #cf222e;
  --bad-light: rgba(207, 34, 46, 0.15);
  --line: #d0d7de;
  --grid: rgba(208, 215, 222, 0.5);
  --shadow: 0 8px 24px rgba(0,0,0,.1);
  --bar-normal: rgba(9, 105, 218, 0.4);
  --bar-anomaly: rgba(207, 34, 46, 0.4);
  --bar-border: rgba(9, 105, 218, 0.8);
}
* { box-sizing: border-box; }
body { 
  margin: 0; 
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  background: var(--bg); 
  color: var(--text);
  font-size: 14px; /* –ï–¥–∏–Ω—ã–π –±–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ */
  line-height: 1.5;
  overflow: hidden; /* –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É body */
  height: 100vh;
}

/* Header - compact, single line */
.header {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  padding: 8px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: nowrap;
  min-height: 48px;
  max-height: 48px;
  overflow-x: auto;
  overflow-y: hidden;
}
.header-left {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
}
.logo {
  font-weight: 700;
  font-size: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}
.logo svg { width: 20px; height: 20px; flex-shrink: 0; }
.status-badges {
  display: flex;
  gap: 8px;
}
.badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 20px;
  font-size: 12px;
  color: var(--muted);
}
.badge .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--muted);
}
.badge .dot.ok { background: var(--ok); }
.badge .dot.bad { background: var(--bad); }

/* Compact status badges */
.status-badges-compact {
  display: flex;
  gap: 4px;
  align-items: center;
  flex-shrink: 0;
}
.badge-compact {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 2px 6px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 10px;
  font-size: 11px;
  color: var(--muted);
  line-height: 1.2;
  white-space: nowrap;
}
.badge-compact .dot {
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: var(--muted);
  flex-shrink: 0;
}
.badge-compact .dot.ok { background: var(--ok); }
.badge-compact .dot.bad { background: var(--bad); }
.badge-compact .dot.warn { background: var(--warn); }
.badge-clickable {
  cursor: pointer;
  transition: all 0.2s;
}
.badge-clickable:hover {
  background: var(--panel);
  border-color: var(--accent);
  transform: translateY(-1px);
}
.header-nav {
  display: flex;
  align-items: center;
  padding: 0 12px;
  border-left: 1px solid var(--line);
  border-right: 1px solid var(--line);
  margin: 0 8px;
  flex-shrink: 0;
}
.header-right {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 1;
  min-width: 0;
  overflow-x: auto;
  overflow-y: hidden;
}
.theme-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 20px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text);
}
.theme-toggle:hover { border-color: var(--accent); }
.lang-toggle {
  padding: 6px 12px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 20px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text);
}
.lang-toggle:hover { border-color: var(--accent); }

/* Layout - —É–ª—É—á—à–µ–Ω–Ω—ã–π spacing */
.container {
  max-width: 2500px;
  margin: 0 auto;
  padding: 8px 10px;
  height: calc(100vh - 48px); /* Header 48px */
  overflow-y: auto;
  overflow-x: hidden;
}
/* –ö–∞—Å—Ç–æ–º–Ω—ã–π —Å–∫—Ä–æ–ª–ª–±–∞—Ä –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ */
.container::-webkit-scrollbar {
  width: 8px;
}
.container::-webkit-scrollbar-track {
  background: var(--panel2);
  border-radius: 4px;
}
.container::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 4px;
}
.container::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}
.tabs {
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;
}
.tab {
  padding: 6px 12px;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  color: var(--muted);
  transition: all .15s;
  white-space: nowrap;
  flex-shrink: 0;
}
.tab:hover { 
  background: var(--panel2);
  color: var(--text); 
}
.tab.active { 
  background: var(--accent); 
  border-color: var(--accent); 
  color: #fff; 
  font-weight: 600;
}
.card {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  padding: 0;
  margin-bottom: 20px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  min-width: 0;
  max-width: 100%;
  overflow: hidden;
}
.card-title {
  font-size: 18px; /* –£–≤–µ–ª–∏—á–µ–Ω –¥–ª—è –ª—É—á—à–µ–π –∏–µ—Ä–∞—Ä—Ö–∏–∏ */
  font-weight: 600;
  margin: 0 0 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}
.card-desc {
  font-size: 14px; /* –ï–¥–∏–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ–ø–∏—Å–∞–Ω–∏–π */
  color: var(--muted);
  margin: -16px 0 20px;
  padding: 14px 16px;
  background: var(--panel2);
  border-radius: 8px;
  border-left: 3px solid var(--accent);
  line-height: 1.6;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px; /* –ï–¥–∏–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–Ω–æ–ø–æ–∫ */
  color: var(--text);
  transition: all .15s;
}
.btn:hover { border-color: var(--accent); }
.btn.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
.btn.primary:hover { opacity: .9; }
.btn.danger { background: var(--bad); border-color: var(--bad); color: #fff; }
.btn.danger:hover { opacity: .9; }
.btn.ok { background: var(--ok); border-color: var(--ok); color: #fff; }
.btn-group { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 20px; }

/* Tables */
.table-wrap { overflow-x: auto; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px; /* –ï–¥–∏–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ç–∞–±–ª–∏—Ü */
}
#usersTable {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}
#usersTable th,
#usersTable td {
  padding: 6px 8px;
  text-align: left;
  border-bottom: 1px solid var(--line);
  vertical-align: middle;
  line-height: 1.3;
}
#usersTable th {
  background: var(--panel2);
  font-weight: 600;
  font-size: 11px;
  color: var(--muted);
  position: sticky;
  top: 0;
  z-index: 10;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  white-space: nowrap;
}
#usersTable td {
  font-size: 13px;
}
#usersTable tr {
  height: auto;
}
#usersTable tr:hover td {
  background: var(--panel2);
}
#usersTable .mono {
  font-family: ui-monospace, Menlo, Consolas, monospace;
  font-size: 11px;
  line-height: 1.3;
  color: var(--muted);
}
#usersTable .user-name {
  font-weight: 500;
  font-size: 13px;
}
#usersTable .btn {
  padding: 4px 8px;
  font-size: 12px;
  min-width: 32px;
}
#usersTable th:nth-child(4),
#usersTable th:nth-child(5),
#usersTable th:nth-child(6),
#usersTable th:nth-child(7) {
  text-align: center;
}
#usersTable td:nth-child(4),
#usersTable td:nth-child(5),
#usersTable td:nth-child(6) {
  text-align: center;
  font-size: 13px;
}
#usersTable td:nth-child(5) {
  font-family: ui-monospace, Menlo, Consolas, monospace;
}
th, td {
  padding: 8px 6px;
  text-align: left;
  border-bottom: 1px solid var(--line);
  font-size: 14px; /* –ï–¥–∏–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ç–∞–±–ª–∏—Ü */
}
/* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –∫–∞—Ä—Ç–æ—á–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - —É–ª—å—Ç—Ä–∞-–∫–æ–º–ø–∞–∫—Ç–Ω—ã–µ */
.users-grid .table th,
.users-grid .table td {
  padding: 3px 5px;
  font-size: 10px;
  line-height: 1.3;
  word-break: break-word;
}
th { 
  font-weight: 600; 
  color: var(--muted); 
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  line-height: 1.3;
}
.users-grid .table th {
  font-size: 8px;
  padding: 3px 5px;
}
tr:hover td { background: var(--panel2); }

/* KPI Cards */
.kpi-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 20px;
  margin-bottom: 24px;
}
/* Segmented controls */
.seg {
  display: inline-flex;
  border: 1px solid var(--line);
  background: var(--panel2);
  border-radius: 6px;
  overflow: hidden;
  flex-shrink: 0;
}
.seg button {
  border: 0;
  background: transparent;
  color: var(--muted);
  padding: 5px 10px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: all .15s;
  white-space: nowrap;
}
.seg button.active {
  color: #fff;
  background: var(--accent);
  font-weight: 600;
}
.seg button:hover:not(.active) {
  background: var(--panel);
  color: var(--text);
}

/* Nav pills */
.nav-pills {
  display: flex;
  gap: 6px;
  align-items: center;
  flex-wrap: nowrap;
  flex-shrink: 0;
}
.nav-pill {
  padding: 6px 10px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 6px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 500;
  color: var(--muted);
  transition: all .15s;
  white-space: nowrap;
}
.nav-pill:hover {
  border-color: var(--accent);
  color: var(--text);
  background: var(--panel);
}
.nav-pill.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
  font-weight: 600;
}
.nav-pill-warn {
  border-color: var(--bad);
}
.nav-pill-warn:hover {
  border-color: var(--bad);
  background: color-mix(in srgb, var(--bad) 10%, transparent);
  color: var(--bad);
}
.nav-pill-warn.active {
  background: var(--bad);
  border-color: var(--bad);
  color: #fff;
}

/* KPI Row (6 cards) - —É–ª—É—á—à–µ–Ω–Ω—ã–π spacing */
.kpi-row {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 6px;
  margin-bottom: 8px;
}
@media (max-width: 1600px) {
  .kpi-row { grid-template-columns: repeat(3, 1fr); }
}
@media (max-width: 1000px) {
  .kpi-row { grid-template-columns: repeat(2, 1fr); }
}
@media (max-width: 600px) {
  .kpi-row { grid-template-columns: 1fr; }
}

.kpi-card {
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 6px;
  padding: 6px 8px;
  min-height: 65px;
  position: relative;
  transition: all 0.2s;
}
.kpi-card:hover {
  border-color: var(--accent);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.kpi-card .kpi-title {
  font-size: 9px;
  color: var(--muted);
  margin-bottom: 4px;
  font-weight: 600;
  line-height: 1.2;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.kpi-card .kpi-subtitle {
  font-size: 8px;
  color: var(--muted2);
  margin-bottom: 2px;
}
.kpi-card .kpi-value {
  font-size: 18px;
  font-weight: 700;
  color: var(--text);
  margin-bottom: 2px;
  line-height: 1.1;
  font-variant-numeric: tabular-nums;
}
.kpi-card .kpi-subline {
  font-size: 8px;
  color: var(--muted);
  margin-top: 1px;
  line-height: 1.2;
}
.kpi-card .kpi-list {
  margin-top: 2px;
  font-size: 9px;
  line-height: 1.2;
}
.kpi-card .kpi-list-item {
  padding: 0;
  color: var(--text);
  display: flex;
  justify-content: space-between;
}
.kpi-card .kpi-bubble {
  position: absolute;
  top: 6px;
  right: 6px;
  font-size: 9px;
  padding: 2px 5px;
  border-radius: 999px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--muted);
  font-weight: 600;
  font-variant-numeric: tabular-nums;
}
.kpi-card .kpi-bubble.up {
  color: var(--ok);
  border-color: var(--ok);
  background: color-mix(in srgb, var(--ok) 15%, transparent);
}
.kpi-card .kpi-bubble.down {
  color: var(--bad);
  border-color: var(--bad);
  background: color-mix(in srgb, var(--bad) 15%, transparent);
}
.kpi-card .kpi-bubble.na {
  color: var(--muted2);
}

/* Card header/body */
.card-hd {
  padding: 16px 20px;
  border-bottom: 1px solid var(--line);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 16px;
  background: var(--panel2);
}
/* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –≤ –∫–∞—Ä—Ç–æ—á–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - clean version */
.users-grid .card-hd {
  padding: 14px;
  border-bottom: 1px solid var(--line);
  min-height: 95px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.users-grid .card-hd .user-title-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}
.users-grid .card-hd h3 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.3;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}
.users-grid .card-hd .status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
  cursor: help;
}
.users-grid .card-hd .status-dot.ok {
  background: var(--ok);
}
.users-grid .card-hd .status-dot.bad {
  background: var(--bad);
}
.users-grid .card-hd .status-dot.warn {
  background: var(--warn);
}
.users-grid .card-hd .metrics-row {
  display: flex;
  margin-top: auto;
  position: relative;
}
.users-grid .card-hd .metric-item {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 8px 0;
  min-width: 0;
}
.users-grid .card-hd .metric-separator {
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  width: 1px;
  background: var(--line);
  transform: translateX(-0.5px);
}
.users-grid .card-hd .metric-value {
  font-size: 17px;
  font-weight: 700;
  line-height: 1.2;
  color: var(--text);
  font-variant-numeric: tabular-nums;
}
.users-grid .card-hd .metric-label {
  font-size: 10px;
  font-weight: 500;
  color: var(--muted);
  text-transform: lowercase;
  letter-spacing: 0.3px;
  line-height: 1;
}
.card-hd h2 {
  font-size: 15px;
  font-weight: 600;
  margin: 0 0 6px;
  line-height: 1.4;
  color: var(--text);
}
.card-hd .meta {
  font-size: 11px;
  color: var(--muted);
  line-height: 1.4;
  margin: 0;
}
.card-bd {
  padding: 18px;
}
/* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - clean version */
.users-grid .card-bd {
  padding: 12px 14px 16px 14px;
}
.users-grid .card {
  min-width: 220px;
  max-width: 250px;
  transition: all 0.2s ease;
}
.users-grid .card:hover {
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  transform: translateY(-2px);
}

/* Trends grid - —É–ª—É—á—à–µ–Ω–Ω—ã–π spacing */
.trends-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 20px;
}
@media (max-width: 1000px) {
  .trends-grid { grid-template-columns: 1fr; }
}

/* Main Content Layout: 2 columns (Left: 570px, Right: 1200px) */
.main-content-layout {
  display: grid;
  grid-template-columns: 440px 1fr;
  gap: 10px;
  align-items: start;
  justify-content: start;
}
@media (max-width: 1800px) {
  .main-content-layout {
    grid-template-columns: 1fr;
    gap: 16px;
  }
}

.left-column {
  width: 440px;
  flex-shrink: 0;
}

.right-column {
  width: 100%;
  flex-shrink: 1;
  min-width: 0;
}

/* –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å: —É–ª—å—Ç—Ä–∞-–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã 440px √ó 580px –¥–ª—è 1920x1080 */
.left-panel-card {
  width: 440px;
  height: 580px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.left-panel-card .card-hd {
  padding: 6px 10px;
  border-bottom: 1px solid var(--line);
  flex-shrink: 0;
}

.left-panel-card .card-hd h2 {
  font-size: 12px;
  font-weight: 600;
  margin: 0 0 2px 0;
  line-height: 1.1;
  color: var(--text);
}

.left-panel-card .card-hd .meta {
  font-size: 8px;
  color: var(--muted);
  line-height: 1.1;
  margin: 0;
}

.left-panel-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  overflow-y: auto;
  min-height: 0;
  padding: 8px;
}

/* –≠–ª–µ–º–µ–Ω—Ç—ã –ª–µ–≤–æ–π –ø–∞–Ω–µ–ª–∏ (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ –¥—Ä—É–≥ –ø–æ–¥ –¥—Ä—É–≥–æ–º) - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ */
.trends-vertical-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
  flex-shrink: 0;
}

.trends-vertical-item .chartbox {
  height: 120px;
  min-height: 120px;
  width: 100%;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 4px;
  padding: 5px;
  display: block; /* Will be toggled by JS based on filter */
}

.domains-vertical-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
  flex-shrink: 0;
}

.domains-single-table {
  width: 100%;
  display: block; /* Will be toggled by JS based on filter */
}

.domains-single-table .kpi-title {
  font-size: 8px;
  font-weight: 600;
  color: var(--muted);
  margin-bottom: 3px;
  text-transform: uppercase;
  letter-spacing: 0.4px;
  line-height: 1.0;
}

.domains-single-table .table-container {
  max-height: 100px;
  overflow-y: auto;
}

.domains-single-table .table {
  font-size: 10px;
}

.domains-single-table .table th {
  font-size: 9px;
  padding: 4px 6px;
}

.domains-single-table .table td {
  font-size: 10px;
  padding: 4px 6px;
}

.histogram-vertical-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
  flex-shrink: 0;
}

.histogram-vertical-item .chartbox {
  height: 100px;
  min-height: 100px;
  width: 100%;
  display: flex;
  flex-direction: column;
  padding: 5px;
  background: var(--panel2);
  border-radius: 4px;
  border: 1px solid var(--line);
}

.histogram-vertical-item .chartbox .kpi-title {
  font-size: 8px;
  margin: 0 0 3px 0;
  padding: 0;
  flex-shrink: 0;
  font-weight: 600;
  color: var(--text);
  text-transform: uppercase;
  letter-spacing: 0.4px;
  line-height: 1.0;
}

.histogram-vertical-item .chartbox > div[id^="chUsers"] {
  flex: 1;
  min-height: 0;
  width: 100%;
}

/* –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å: —É–ª—å—Ç—Ä–∞-–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è 1920x1080 */
.right-panel-card {
  width: 100%;
  height: 580px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.right-panel-card .card-hd {
  padding: 6px 10px;
  border-bottom: 1px solid var(--line);
  flex-shrink: 0;
}

.right-panel-card .card-hd h2 {
  font-size: 12px;
  font-weight: 600;
  margin: 0 0 2px 0;
  line-height: 1.1;
  color: var(--text);
}

.right-panel-card .card-hd .meta {
  font-size: 8px;
  color: var(--muted);
  line-height: 1.1;
  margin: 0;
}

.right-panel-content {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  padding: 8px;
}

/* –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ –∫–ª–∞—Å—Å—ã - –æ—Å—Ç–∞–≤–ª–µ–Ω—ã –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ */
.trends-column {
  display: none; /* –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è */
}

.domains-column {
  display: none; /* –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è */
}

.trends-domains-combined {
  display: none; /* –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è */
}

/* –£—Å—Ç–∞—Ä–µ–≤—à–∏–π –∫–ª–∞—Å—Å - –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è */
.users-histogram-container {
  display: none;
}

/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ç–∞–±–ª–∏—Ü —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –≤—ã—Å–æ—Ç—ã */
.table-container {
  max-height: 320px;
  overflow-y: auto;
  overflow-x: hidden;
  margin-top: 8px;
}
.table-container::-webkit-scrollbar {
  width: 6px;
}
.table-container::-webkit-scrollbar-track {
  background: var(--panel2);
  border-radius: 3px;
}
.table-container::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 3px;
}
.table-container::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}

/* Domains grid - —É–ª—É—á—à–µ–Ω–Ω—ã–π spacing */
.domains-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}
/* Override for user cards - single column */
.users-grid .card .domains-grid {
  display: flex;
  flex-direction: column;
}
/* –ö–æ–º–ø–∞–∫—Ç–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã –≤ –∫–∞—Ä—Ç–æ—á–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - —É–ª—å—Ç—Ä–∞-–∫–æ–º–ø–∞–∫—Ç–Ω—ã–µ */
.users-grid .domains-section {
  margin-top: 10px;
}
.users-grid .domains-section-title {
  font-size: 9px;
  font-weight: 700;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.8px;
  margin-bottom: 8px;
  line-height: 1;
  text-align: center;
}
.users-grid .domain-item {
  display: flex;
  align-items: baseline;
  gap: 5px;
  padding: 3px 0;
  line-height: 1.4;
}
.users-grid .domain-pct {
  font-size: 13px;
  font-weight: 700;
  color: var(--accent);
  min-width: 32px;
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
}
.users-grid .domain-bullet {
  color: var(--muted);
  font-size: 10px;
  flex-shrink: 0;
}
.users-grid .domain-gb {
  font-size: 11px;
  color: var(--muted);
  font-variant-numeric: tabular-nums;
  min-width: 42px;
  flex-shrink: 0;
}
.users-grid .domain-name {
  font-size: 11px;
  color: var(--text);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
  min-width: 0;
}
@media (max-width: 1000px) {
  .domains-grid { grid-template-columns: 1fr; }
}

/* Users charts grid - —É–ª—É—á—à–µ–Ω–Ω—ã–π spacing */
.users-charts-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 20px;
  margin-bottom: 20px;
}
@media (max-width: 1000px) {
  .users-charts-grid { grid-template-columns: 1fr; }
}

/* Users grid (cards) - 4 –∫–æ–ª–æ–Ω–∫–∏ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –∫–æ–º–ø–∞–∫—Ç–Ω–æ—Å—Ç–∏ */
.users-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 250px));
  gap: 12px;
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 6px;
  justify-content: start;
}
/* –°–∫—Ä–æ–ª–ª–±–∞—Ä –¥–ª—è users-grid */
.users-grid::-webkit-scrollbar {
  width: 5px;
}
.users-grid::-webkit-scrollbar-track {
  background: var(--panel2);
  border-radius: 3px;
}
.users-grid::-webkit-scrollbar-thumb {
  background: var(--line);
  border-radius: 3px;
}
.users-grid::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}
@media (max-width: 1200px) {
  .users-grid { grid-template-columns: repeat(3, 1fr) !important; }
}
@media (max-width: 900px) {
  .users-grid { grid-template-columns: repeat(2, 1fr) !important; }
}
@media (max-width: 600px) {
  .users-grid { grid-template-columns: 1fr !important; }
}

/* Filters (chips) - –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π */
.filters {
  padding: 6px 8px;
  border-bottom: 1px solid var(--line);
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.filters-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
  margin-left: auto;
  flex: 1;
  min-width: 0;
}
.users-controls-row {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  width: 100%;
}
.filter-chip {
  padding: 6px 12px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 16px;
  cursor: pointer;
  font-size: 12px;
  color: var(--muted);
  transition: all .15s;
}
.filter-chip:hover {
  border-color: var(--accent);
  color: var(--text);
}
.filter-chip.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

/* Chart boxes - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è 2500x1300 */
.chartbox {
  position: relative;
  height: 180px;
  min-height: 180px;
}
.chartbox.small { height: 185px; min-height: 185px; }
.chartbox.tiny { height: 140px; min-height: 140px; }
.chartbox > div {
  width: 100%;
  height: 100%;
}

/* Online now - –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π */
.online-now {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-bottom: 12px;
}
@media (max-width: 800px) {
  .online-now { grid-template-columns: 1fr; }
}

/* Row (flex) */
.row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

/* Notice */
.notice {
  padding: 12px 20px;
  background: var(--panel2);
  border-top: 1px solid var(--line);
  font-size: 12px;
  color: var(--muted);
}

/* Chart containers - amCharts 5 */
.chart-container {
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 20px;
  position: relative;
  height: 300px;
}

/* Forms */
input, select, textarea {
  padding: 10px 12px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
  color: var(--text);
  font-size: 14px;
  outline: none;
}
input:focus, select:focus, textarea:focus {
  border-color: var(--accent);
}
textarea {
  width: 100%;
  min-height: 150px;
  font-family: monospace;
  font-size: 12px;
}
.form-row {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
  margin-bottom: 12px;
}
label {
  font-size: 13px;
  color: var(--muted);
}

/* Help tooltip */
.help {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 50%;
  font-size: 11px;
  color: var(--muted);
  cursor: help;
  position: relative;
}
.help:hover::after {
  content: attr(data-tip);
  position: absolute;
  left: 0;
  top: 100%;
  margin-top: 6px;
  background: var(--panel2);
  color: var(--text);
  padding: 8px 12px;
  border: 1px solid var(--line);
  border-radius: 8px;
  font-size: 11px;
  white-space: normal;
  max-width: 300px;
  width: max-content;
  min-width: 150px;
  z-index: 1000;
  box-shadow: var(--shadow);
  line-height: 1.4;
  word-wrap: break-word;
}

  /* Modal */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 200;
}
.modal-overlay.show { display: flex; }
.modal {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  padding: 24px;
  max-width: 500px;
  width: 90%;
  box-shadow: var(--shadow);
}
.modal h3 { 
  margin: 0 0 16px; 
  font-size: 16px; /* –ï–¥–∏–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –º–æ–¥–∞–ª—å–Ω—ã—Ö –æ–∫–æ–Ω */
  font-weight: 600;
}
.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

/* Toast */
.toast {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  padding: 16px 20px;
  box-shadow: var(--shadow);
  display: none;
  z-index: 300;
  max-width: 400px;
}
.toast.show { display: block; }
.toast-title { font-weight: 600; margin-bottom: 4px; }
.toast-text { font-size: 13px; color: var(--muted); }

/* Panes */
.pane { 
  display: none; 
}
.pane.active { 
  display: block !important; 
}

/* System Navigation (internal tabs within System pane) */
.system-nav {
  margin-bottom: 20px;
  padding: 0 20px;
}

.system-seg {
  display: inline-flex;
  width: auto;
}

.system-tab {
  border: 0;
  background: transparent;
  color: var(--muted);
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all .15s;
  white-space: nowrap;
  border-radius: 8px;
  margin-right: 4px;
}

.system-tab.active {
  color: #fff;
  background: var(--accent);
  font-weight: 600;
}

.system-tab:hover:not(.active) {
  background: var(--panel);
  color: var(--text);
}

/* System Sub-panes */
.system-subpane {
  display: none;
}

.system-subpane.active {
  display: block;
}

/* Progress bar */
.progress-bar {
  width: 100%;
  height: 20px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}
.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--ok));
  transition: width .3s;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: #fff;
  font-weight: 600;
}

/* Utils */
.mono { font-family: monospace; }
.muted { color: var(--muted); }
.text-ok { color: var(--ok); }
.text-bad { color: var(--bad); }
.text-warn { color: var(--warn); }
.mb-0 { margin-bottom: 0; }
.mt-16 { margin-top: 16px; }
.flex { display: flex; }
.gap-8 { gap: 8px; }
.items-center { align-items: center; }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <div class="logo">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
      <span>Xray Usage</span>
    </div>
    <div class="status-badges-compact">
      <div class="badge-compact badge-clickable" id="badgeUI" title="UI —Å–µ—Ä–≤–∏—Å. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç–∞—Ç—É—Å–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è">
        <span class="dot" id="dotUI"></span>
        <span>UI</span>
      </div>
      <div class="badge-compact badge-clickable" id="badgeXray" title="Xray —Å–µ—Ä–≤–∏—Å. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç–∞—Ç—É—Å–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è. –ï—Å–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω - –º–æ–∂–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å">
        <span class="dot" id="dotXray"></span>
        <span>Xray</span>
      </div>
      <div class="badge-compact badge-clickable" id="badgeCollector" title="–°–±–æ—Ä—â–∏–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏. –ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–µ—Ç–∞–ª–µ–π">
        <span class="dot" id="dotCollector"></span>
        <span>–°–±–æ—Ä—â–∏–∫</span>
      </div>
    </div>
  </div>
  
  <!-- Main Navigation Tabs -->
  <div class="header-nav">
    <div class="tabs">
      <div class="tab active" data-tab="dashboard">üìä <span data-i18n="dashboard">–û–±–∑–æ—Ä</span></div>
      <div class="tab" data-tab="users">üë• <span data-i18n="users">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</span></div>
      <div class="tab" data-tab="system">‚öôÔ∏è <span>–°–∏—Å—Ç–µ–º–∞</span></div>
    </div>
  </div>
  
  <div class="header-right">
    <!-- DateSelect -->
    <select id="dateSelect" title="–î–∞—Ç–∞ –æ—Ç—á—ë—Ç–∞" style="width: 130px; padding: 5px 8px; font-size: 12px;"></select>
    
    <!-- Segmented: Daily/Cumulative - Compact -->
    <div class="seg" title="–†–µ–∂–∏–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–æ–≤" style="font-size: 12px;">
      <button id="segDaily" class="active" style="padding: 5px 10px;">üìà Daily</button>
      <button id="segCum" style="padding: 5px 10px;">üìä Cumul</button>
    </div>
    
    <!-- Segmented: Dark/Light -->
    <div class="seg" title="–¢–µ–º–∞ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è">
      <button id="segDark" class="active">üåô</button>
      <button id="segLight">‚òÄÔ∏è</button>
    </div>
    
    <!-- Nav pills: –û–Ω–ª–∞–π–Ω / –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏ -->
    <div class="nav-pills">
      <button class="nav-pill" id="navOnline" data-nav="online">‚ö° –û–Ω–ª–∞–π–Ω</button>
    </div>
    
    <!-- Overview Metric Filter (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã "–û–±–∑–æ—Ä") -->
    <div class="seg" id="overviewMetricFilter" title="–§–∏–ª—å—Ç—Ä –¥–∞–Ω–Ω—ã—Ö" style="display: none;">
      <button id="btnOverviewTraffic" class="active">üìä Traffic</button>
      <button id="btnOverviewConns">üîå Conns</button>
    </div>
    
    <!-- Chart Library Toggle - Compact -->
    <select id="chartLibrarySelect" title="–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –≥—Ä–∞—Ñ–∏–∫–æ–≤" style="padding: 5px 8px; font-size: 11px; min-width: 100px;">
      <option value="amcharts">üìä amCharts</option>
      <option value="apexcharts">üìà ApexCharts</option>
      <option value="observable">ü•á Observable</option>
      <option value="highcharts">ü•à Highcharts</option>
      <option value="vegalite">ü•â Vega-Lite</option>
      <option value="recharts">üìä Recharts</option>
    </select>
  </div>
</div>

<div class="container">

  <!-- –£–ü–†–ê–í–õ–ï–ù–ò–ï (–ò—Å—Ç–æ—Ä–∏—è) -->
  <div class="pane active" data-pane="management" id="paneManagement">
    <!-- KPIRow: 6 –∫–∞—Ä—Ç–æ—á–µ–∫ -->
    <div class="kpi-row" id="kpiRow">
      <!-- KPIStatCard: Today traffic -->
      <div class="kpi-card stat-card" id="kpiTodayTraffic">
        <div class="kpi-title">Today traffic (GB)</div>
        <div class="kpi-value" id="kpiTodayTrafficValue">‚Äî</div>
        <div class="kpi-subline">avg7d: <span id="kpiTodayTrafficAvg">‚Äî</span></div>
        <div class="kpi-bubble" id="kpiTodayTrafficBubble"></div>
      </div>
      
      <!-- KPIStatCard: Today conns -->
      <div class="kpi-card stat-card" id="kpiTodayConns">
        <div class="kpi-title">Today conns</div>
        <div class="kpi-value" id="kpiTodayConnsValue">‚Äî</div>
        <div class="kpi-subline">avg7d: <span id="kpiTodayConnsAvg">‚Äî</span></div>
        <div class="kpi-bubble" id="kpiTodayConnsBubble"></div>
      </div>
      
      <!-- KPITotalCard: 7d total traffic -->
      <div class="kpi-card total-card" id="kpiTotal7dTraffic">
        <div class="kpi-title">7d total traffic (GB)</div>
        <div class="kpi-value" id="kpiTotal7dTrafficValue">‚Äî</div>
        <div class="kpi-bubble" id="kpiTotal7dTrafficBubble"></div>
      </div>
      
      <!-- KPITotalCard: 7d total conns -->
      <div class="kpi-card total-card" id="kpiTotal7dConns">
        <div class="kpi-title">7d total conns</div>
        <div class="kpi-value" id="kpiTotal7dConnsValue">‚Äî</div>
        <div class="kpi-bubble" id="kpiTotal7dConnsBubble"></div>
      </div>
      
      <!-- KPITopMiniList: Top domains (7d) ‚Äî traffic (top-3) -->
      <div class="kpi-card top-card" id="kpiTopDomainsTraffic">
        <div class="kpi-title">Top domains (7d) ‚Äî traffic (top-3)</div>
        <div class="kpi-list" id="kpiTopDomainsTrafficList"></div>
        <div class="kpi-bubble" id="kpiTopDomainsTrafficBubble"></div>
      </div>
      
      <!-- KPITopMiniList: Top domains (7d) ‚Äî conns (top-3) -->
      <div class="kpi-card top-card" id="kpiTopDomainsConns">
        <div class="kpi-title">Top domains (7d) ‚Äî conns (top-3)</div>
        <div class="kpi-list" id="kpiTopDomainsConnsList"></div>
        <div class="kpi-bubble" id="kpiTopDomainsConnsBubble"></div>
      </div>
    </div>
    
    <!-- Main Content Layout: 2 columns (Left: Trends/Domains/Histogram combined, Right: Users Cards) -->
    <div class="main-content-layout">
      <!-- –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –û–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π –±–ª–æ–∫ (570px √ó 800px) -->
      <div class="left-column">
        <div class="card left-panel-card">
          <div class="card-hd">
            <div>
              <h2>–¢—Ä–µ–Ω–¥—ã (7 –¥–Ω–µ–π) & –¢–æ–ø –¥–æ–º–µ–Ω—ã (7 –¥–Ω–µ–π) & –ì–∏—Å—Ç–æ–≥—Ä–∞–º–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</h2>
              <div class="meta">–ü–µ—Ä–µ–∫–ª—é—á–∞–π –≤ —à–∞–ø–∫–µ: Daily / Cumulative (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ) | –¢–æ–ø-7 –ø–æ —Ç—Ä–∞—Ñ–∏–∫—É –∏ –ø–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º</div>
            </div>
          </div>
          <div class="card-bd left-panel-content">
            <!-- –ì—Ä–∞—Ñ–∏–∫ —Ç—Ä–µ–Ω–¥–æ–≤ (—Å–≤–µ—Ä—Ö—É) -->
            <div class="trends-vertical-item">
              <div class="chartbox">
                <div id="chTraffic" style="width:100%;height:100%;"></div>
              </div>
              <div class="chartbox">
                <div id="chConns" style="width:100%;height:100%;"></div>
              </div>
            </div>
            
            <!-- –¢–∞–±–ª–∏—Ü–∞ Top domains (–ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ) -->
            <div class="domains-vertical-item">
              <div class="domains-single-table">
                <div class="kpi-title">–ü–æ —Ç—Ä–∞—Ñ–∏–∫—É</div>
                <div class="table-container">
                  <table class="table" id="tblTopTraffic">
                    <thead>
                      <tr>
                        <th>Domain</th>
                        <th>GB/MB</th>
                        <th>%</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
              <div class="domains-single-table">
                <div class="kpi-title">–ü–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º</div>
                <div class="table-container">
                  <table class="table" id="tblTopConns">
                    <thead>
                      <tr>
                        <th>Domain</th>
                        <th>#</th>
                        <th>%</th>
                      </tr>
                    </thead>
                    <tbody></tbody>
                  </table>
                </div>
              </div>
            </div>
            
            <!-- –ì–∏—Å—Ç–æ–≥—Ä–∞–º–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–≤–Ω–∏–∑—É) -->
            <div class="histogram-vertical-item">
              <div class="chartbox">
                <div class="kpi-title">–ü–æ —Ç—Ä–∞—Ñ–∏–∫—É</div>
                <div id="chUsersTraffic" style="width:100%;height:100%;"></div>
              </div>
              <div class="chartbox">
                <div class="kpi-title">–ü–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º</div>
                <div id="chUsersConns" style="width:100%;height:100%;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: UsersPanel: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ (1200px √ó 800px) -->
      <div class="right-column">
        <div class="card right-panel-card">
          <div class="card-hd">
            <div>
              <h2>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</h2>
              <div class="meta">–§–∏–ª—å—Ç—Ä —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è. –ï—Å–ª–∏ –≤—ã–±—Ä–∞—Ç—å —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ ‚Äî –Ω–µ —É–º–µ—Å—Ç–∏—Ç—Å—è –±–µ–∑ —Å–∫—Ä–æ–ª–ª–∞ (–∏ —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ).</div>
            </div>
            <div class="users-controls-row">
              <!-- –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏ Traffic/Conns —É–¥–∞–ª–µ–Ω—ã - —Ç–µ–ø–µ—Ä—å —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –≥–ª–æ–±–∞–ª—å–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–æ–º –≤ —à–∞–ø–∫–µ -->
              <div class="filters-inline" id="userFilters"></div>
            </div>
          </div>
          <div class="card-bd right-panel-content">
            <div class="users-grid" id="usersGrid"></div>
          </div>
          <div class="notice" id="usersNotice" style="display:none"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- –û–ù–õ–ê–ô–ù (near-realtime) -->
  <div class="pane" data-pane="online" id="paneOnline">
    <div class="card">
      <div class="card-hd">
        <div>
          <h2>–û–Ω–ª–∞–π–Ω</h2>
          <div class="meta" id="onlineMeta">–ò—Å—Ç–æ—á–Ω–∏–∫: <span id="onlineSource">‚Äî</span></div>
        </div>
        <div class="row">
          <div class="seg" title="Scope">
            <button id="segScopeGlobal" class="active">Global</button>
            <button id="segScopeUsers">By users</button>
          </div>
          <div class="seg" title="–ú–µ—Ç—Ä–∏–∫–∞">
            <button id="segMetricTraffic" class="">Traffic</button>
            <button id="segMetricConns" class="active">Conns</button>
            <button id="segMetricOnline">Online users</button>
          </div>
          <div class="seg" title="–ü–µ—Ä–∏–æ–¥">
            <button id="segPeriod60m" class="active">60m</button>
            <button id="segPeriod6h">6h</button>
            <button id="segPeriod24h">24h</button>
          </div>
          <div class="seg" title="–ì—Ä–∞–Ω—É–ª—è—Ä–Ω–æ—Å—Ç—å">
            <button id="segGran1m">1m</button>
            <button id="segGran5m" class="active">5m</button>
            <button id="segGran10m">10m</button>
          </div>
          <button class="btn" id="btnPause">Pause</button>
        </div>
      </div>
      <div class="card-bd">
        <div class="online-now" id="onlineNow">
          <div class="kpi-card">
            <div class="kpi-title">Online users</div>
            <div class="kpi-value" id="onlineUsersValue">‚Äî</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-title">Connections</div>
            <div class="kpi-value" id="onlineConnsValue">‚Äî</div>
          </div>
          <div class="kpi-card">
            <div class="kpi-title">Traffic</div>
            <div class="kpi-value" id="onlineTrafficValue">‚Äî</div>
            <div class="kpi-subline" id="onlineTrafficNote" style="display:none;">Traffic unavailable</div>
          </div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
          <div class="chartbox" style="position: relative;">
            <div class="kpi-title" style="position: absolute; top: 4px; left: 4px; right: 4px; z-index: 10; font-size: 13px; margin: 0; padding: 0;">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è</div>
            <div id="chOnlineConns" style="width:100%;height:100%;"></div>
          </div>
          <div class="chartbox" style="position: relative;">
            <div class="kpi-title" style="position: absolute; top: 4px; left: 4px; right: 4px; z-index: 10; font-size: 13px; margin: 0; padding: 0;">–¢—Ä–∞—Ñ–∏–∫</div>
            <div id="chOnlineTraffic" style="width:100%;height:100%;"></div>
          </div>
        </div>
        <div class="card">
          <h3>Top users (—Å–µ–≥–æ–¥–Ω—è)</h3>
          <table class="table" id="tblOnlineTop">
            <thead>
              <tr>
                <th>User</th>
                <th>–°—Ç–∞—Ç—É—Å</th>
                <th>–¢—Ä–∞—Ñ–∏–∫</th>
                <th>–ü–æ–¥–∫–ª—é—á–µ–Ω–∏—è</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <!-- SERVICES MANAGEMENT -->
  <!-- SYSTEM (Combined: Services, Events, Settings) -->
  <div class="pane" data-pane="system" id="paneSystem">
    <!-- Internal Navigation Tabs -->
    <div class="system-nav">
      <div class="seg system-seg">
        <button class="system-tab active" data-system-tab="services">‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏</button>
        <button class="system-tab" data-system-tab="events">üìã –°–æ–±—ã—Ç–∏—è</button>
        <button class="system-tab" data-system-tab="settings">üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
      </div>
    </div>
    
    <!-- Services Sub-pane -->
    <div class="system-subpane active" data-system-subpane="services">
    <div class="card">
      <h3 class="card-title">
        <span>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏</span>
        <span class="help" data-tip="–°—Ç–∞—Ç—É—Å, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∏ –ª–æ–≥–∏ systemd –¥–ª—è —Å–µ—Ä–≤–∏—Å–æ–≤ UI –∏ Xray.">?</span>
      </h3>
      <div class="card-desc" style="margin-bottom: 16px;">
        –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞–º–∏ —á–µ—Ä–µ–∑ systemd. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ Xray —Ä–∞–∑–æ—Ä–≤—ë—Ç –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ VPN –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.
      </div>
      
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 16px;">
        <!-- UI Service Card -->
        <div style="padding: 16px; background: var(--panel2); border-radius: 8px; border: 1px solid var(--line);">
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 14px;">
            <div>
              <div style="font-weight: 600; font-size: 16px; margin-bottom: 4px;">üìã UI Service</div>
              <div style="font-size: 13px; color: var(--muted);">
                –í–µ–±-–ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
              </div>
            </div>
            <div id="serviceUIStatus" style="font-size: 13px;">
              <span class="dot" id="serviceUIDot" style="width: 10px; height: 10px; border-radius: 50%; background: var(--muted); display: inline-block; margin-right: 8px;"></span>
              <span id="serviceUIStatusText">‚Äî</span>
            </div>
          </div>
          
          <div style="margin-bottom: 14px; padding: 12px; background: var(--bg); border-radius: 6px; font-size: 13px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span style="color: var(--muted);">–°–µ—Ä–≤–∏—Å:</span>
              <code style="font-size: 12px; color: var(--text);">xray-report-ui</code>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span style="color: var(--muted);">–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:</span>
              <strong id="serviceUIUptime" style="color: var(--text); font-size: 13px;">‚Äî</strong>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: var(--muted);">–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤ (14 –¥–Ω–µ–π):</span>
              <strong id="serviceUIRestarts" style="color: var(--text); font-size: 13px;">‚Äî</strong>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 14px;">
            <button class="btn" id="btnRestartUI" style="flex: 1; padding: 10px; font-size: 13px;">üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
          </div>
          
          <!-- UI Logs -->
          <div id="serviceUILogs" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--line);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="font-size: 13px; color: var(--muted);">
                –ü–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤ <span id="serviceUITimezone" style="font-size: 11px; color: var(--muted2);">(–∑–∞–≥—Ä—É–∑–∫–∞...)</span>:
              </div>
              <button class="btn" onclick="loadServiceJournal('ui')" style="padding: 6px 10px; font-size: 12px;">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
            </div>
            <pre id="serviceUIJournalContent" style="max-height:300px;overflow:auto;font-size:12px;font-family:ui-monospace,Menlo,Consolas,monospace;background:var(--bg);padding:12px;border-radius:6px;border:1px solid var(--line);white-space:pre-wrap;word-wrap:break-word;color:var(--text);">–ó–∞–≥—Ä—É–∑–∫–∞...</pre>
          </div>
          
          <!-- UI Restart History -->
          <div style="margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--line);">
            <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text);">–ò—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤:</div>
            <div id="serviceUIRestartHistory" style="font-size: 12px; color: var(--muted);">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
          </div>
        </div>
        
        <!-- Xray Service Card -->
        <div style="padding: 16px; background: var(--panel2); border-radius: 8px; border: 1px solid var(--line);">
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 14px;">
            <div>
              <div style="font-weight: 600; font-size: 16px; margin-bottom: 4px;">‚ö° Xray Service</div>
              <div style="font-size: 13px; color: var(--muted);">
                VPN —Å–µ—Ä–≤–µ—Ä
              </div>
            </div>
            <div id="serviceXrayStatus" style="font-size: 13px;">
              <span class="dot" id="serviceXrayDot" style="width: 10px; height: 10px; border-radius: 50%; background: var(--muted); display: inline-block; margin-right: 8px;"></span>
              <span id="serviceXrayStatusText">‚Äî</span>
            </div>
          </div>
          
          <div style="margin-bottom: 14px; padding: 12px; background: var(--bg); border-radius: 6px; font-size: 13px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span style="color: var(--muted);">–°–µ—Ä–≤–∏—Å:</span>
              <code id="serviceXrayName" style="font-size: 12px; color: var(--text);">xray</code>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span style="color: var(--muted);">–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:</span>
              <strong id="serviceXrayUptime" style="color: var(--text); font-size: 13px;">‚Äî</strong>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: var(--muted);">–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤ (14 –¥–Ω–µ–π):</span>
              <strong id="serviceXrayRestarts" style="color: var(--text); font-size: 13px;">‚Äî</strong>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 14px;">
            <button class="btn danger" id="btnRestartXray" style="flex: 1; padding: 10px; font-size: 13px;">‚ö° –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
          </div>
          
          <!-- Xray Logs -->
          <div id="serviceXrayLogs" style="margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--line);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <div style="font-size: 13px; color: var(--muted);">
                –ü–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤ <span id="serviceXrayTimezone" style="font-size: 11px; color: var(--muted2);">(–∑–∞–≥—Ä—É–∑–∫–∞...)</span>:
              </div>
              <button class="btn" onclick="loadServiceJournal('xray')" style="padding: 6px 10px; font-size: 12px;">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
            </div>
            <pre id="serviceXrayJournalContent" style="max-height:300px;overflow:auto;font-size:12px;font-family:ui-monospace,Menlo,Consolas,monospace;background:var(--bg);padding:12px;border-radius:6px;border:1px solid var(--line);white-space:pre-wrap;word-wrap:break-word;color:var(--text);">–ó–∞–≥—Ä—É–∑–∫–∞...</pre>
          </div>
          
          <!-- Xray Restart History -->
          <div style="margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--line);">
            <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: var(--text);">–ò—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤:</div>
            <div id="serviceXrayRestartHistory" style="font-size: 12px; color: var(--muted);">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
          </div>
        </div>
      </div>
      
    </div>
  </div>
  
  <!-- Events Sub-pane -->
  <div class="system-subpane" data-system-subpane="events">
    <div class="card">
      <h3 class="card-title">
        <span data-i18n="eventLog">–ñ—É—Ä–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π</span>
        <span class="help" data-tip="–í—Å–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –ø–∞–Ω–µ–ª–∏ –ª–æ–≥–∏—Ä—É—é—Ç—Å—è: –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —Ä–µ—Å—Ç–∞—Ä—Ç—ã, –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫.">?</span>
      </h3>
      <div class="card-desc" data-i18n="eventsDesc">
        –ñ—É—Ä–Ω–∞–ª –≤—Å–µ—Ö –¥–µ–π—Å—Ç–≤–∏–π –≤ –ø–∞–Ω–µ–ª–∏. –ü–æ–º–æ–≥–∞–µ—Ç –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∫—Ç–æ –∏ –∫–æ–≥–¥–∞ –≤–Ω–æ—Å–∏–ª –∏–∑–º–µ–Ω–µ–Ω–∏—è.
      </div>
      
      <div class="form-row">
        <input type="text" id="eventsFilter" placeholder="–ü–æ–∏—Å–∫..." style="flex:1;max-width:300px;">
        <button class="btn" id="btnRefreshEvents">üîÑ <span data-i18n="refresh">–û–±–Ω–æ–≤–∏—Ç—å</span></button>
      </div>

      <div class="table-wrap">
        <table id="eventsTable">
          <thead>
            <tr>
              <th data-i18n="time">–í—Ä–µ–º—è</th>
              <th data-i18n="type">–¢–∏–ø</th>
              <th data-i18n="action">–î–µ–π—Å—Ç–≤–∏–µ</th>
              <th data-i18n="details">–î–µ—Ç–∞–ª–∏</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>
  
  <!-- Settings Sub-pane -->
  <div class="system-subpane" data-system-subpane="settings">
      <div class="card">
        <h3 class="card-title">
          <span>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ Xray/Reality</span>
          <span class="help" data-tip="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ VLESS-—Å—Å—ã–ª–æ–∫ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã Reality. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å'. –î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–∫–ª–∞–¥–∫—É '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏'.">?</span>
        </h3>
        
        <!-- Editable Settings -->
        <div style="margin-bottom: 20px;">
          <label style="font-size: 12px; color: var(--muted); margin-bottom: 8px; display: block; font-weight: 600;">–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:</label>
          <div style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 200px;">
              <label style="font-size: 11px; color: var(--muted); margin-bottom: 4px; display: block;">
                Server Host <span class="help" data-tip="IP-–∞–¥—Ä–µ—Å –∏–ª–∏ –¥–æ–º–µ–Ω –≤–∞—à–µ–≥–æ VPN —Å–µ—Ä–≤–µ—Ä–∞. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¢–û–õ–¨–ö–û –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ VLESS-—Å—Å—ã–ª–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–∫–Ω–æ–ø–∫–∞ 'üîó –°—Å—ã–ª–∫–∞' –≤ —Ä–∞–∑–¥–µ–ª–µ '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏'). –≠—Ç–æ –∞–¥—Ä–µ—Å, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤ —Å—Å—ã–ª–∫–µ –≤–∏–¥–∞ vless://UUID@HOST:PORT?... –ë–µ–∑ —ç—Ç–æ–≥–æ –ø–æ–ª—è –Ω–µ–ª—å–∑—è —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫–∏ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.">?</span>
              </label>
              <input type="text" id="setServerHost" placeholder="123.45.67.89 –∏–ª–∏ vpn.example.com" style="width: 100%; padding: 6px; font-size: 13px;">
            </div>
            <div style="flex: 1; min-width: 200px;">
              <label style="font-size: 11px; color: var(--muted); margin-bottom: 4px; display: block;">
                Reality PBK (override) <span class="help" data-tip="–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á Reality. –û—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∏–∑ privateKey –≤ –∫–æ–Ω—Ñ–∏–≥–µ Xray.">?</span>
              </label>
              <input type="text" id="setPbk" placeholder="(–∞–≤—Ç–æ)" style="width: 100%; padding: 6px; font-size: 13px;">
            </div>
            <div style="flex: 1; min-width: 200px;">
              <label style="font-size: 11px; color: var(--muted); margin-bottom: 4px; display: block;">
                CSV –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è <span class="help" data-tip="–ü—É—Ç—å –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å CSV-–æ—Ç—á—ë—Ç–∞–º–∏ –æ—Ç —Å–±–æ—Ä—â–∏–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.">?</span>
              </label>
              <input type="text" id="setUsageDir" placeholder="/var/log/xray/usage" style="width: 100%; padding: 6px; font-size: 13px;">
            </div>
            <div style="display: flex; gap: 6px; flex-shrink: 0;">
              <button class="btn primary" id="btnSaveSettings" style="padding: 6px 12px; font-size: 13px;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
              <button class="btn" id="btnReloadSettings" style="padding: 6px 12px; font-size: 13px;">üîÑ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            </div>
          </div>
        </div>

        <!-- Current Reality Parameters (Read-only from Xray config) -->
        <div style="margin-bottom: 20px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <label style="font-size: 12px; color: var(--muted); font-weight: 600;">–¢–µ–∫—É—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã Reality (–∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ Xray):</label>
            <button class="btn" id="btnReloadXray" style="padding: 4px 8px; font-size: 12px;">üîÑ –û–±–Ω–æ–≤–∏—Ç—å</button>
          </div>
          <pre id="realityParams" class="mono" style="background:var(--panel2);padding:8px;border-radius:6px;overflow-x:auto;font-size:11px;max-height:120px;overflow-y:auto;"></pre>
        </div>

        <!-- Xray Config (Read-only) -->
        <div>
          <label style="font-size: 12px; color: var(--muted); margin-bottom: 4px; display: block; font-weight: 600;">–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Xray (—Ç–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ):</label>
          <div class="card-desc" style="margin-bottom: 8px; font-size: 12px;">
            –ü—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞ Xray. –ò–∑–º–µ–Ω—è—Ç—å –∫–æ–Ω—Ñ–∏–≥ –Ω–∞–ø—Ä—è–º—É—é –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ –≤–æ –≤–∫–ª–∞–¥–∫–µ "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏".
          </div>
          <textarea id="xrayConfig" readonly style="min-height: 200px; font-size: 11px; width: 100%; font-family: monospace;"></textarea>
        </div>
      </div>

      <div class="card" style="margin-top: 16px;">
        <h3 class="card-title">Collector (—Å–±–æ—Ä—â–∏–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏)</h3>
        <div id="collectorStatus"></div>
      </div>
    </div>
  </div>
  
  <!-- USERS -->
  <div class="pane" data-pane="users">
    <div class="card">
      <div class="card-hd" style="padding: 12px 16px; display: flex; justify-content: space-between; align-items: center;">
        <div style="flex: 1;">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <h3 class="card-title" style="margin: 0; font-size: 16px;">üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</h3>
            <label style="display: inline-flex; align-items: center; gap: 4px; font-size: 12px; color: var(--muted); cursor: pointer; user-select: none; padding: 2px 8px; border-radius: 4px; background: var(--panel2);">
              <input type="checkbox" id="chkHideInactive" checked style="cursor: pointer;">
              <span>–¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ</span>
            </label>
          </div>
          <div class="card-desc" style="font-size: 12px; color: var(--muted); line-height: 1.4;">
            –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–æ–º: –¥–æ–±–∞–≤–ª—è–π—Ç–µ, —É–¥–∞–ª—è–π—Ç–µ –∏–ª–∏ –æ—Ç–∫–ª—é—á–∞–π—Ç–µ (—Å–º–µ–Ω–∞ UUID)
          </div>
        </div>
        <div class="btn-group" style="gap: 8px;">
          <button class="btn primary" id="btnAddUser" style="padding: 6px 12px; font-size: 13px;">‚ûï –î–æ–±–∞–≤–∏—Ç—å</button>
          <button class="btn" id="btnRefreshUsers" style="padding: 6px 12px; font-size: 13px;">üîÑ</button>
        </div>
      </div>

      <div class="table-wrap">
        <table id="usersTable">
          <thead>
            <tr>
              <th data-i18n="name">–ò–º—è</th>
              <th>UUID</th>
              <th>–¢–æ–ø-3 –¥–æ–º–µ–Ω–∞</th>
              <th style="text-align: center;">–î–Ω–µ–π</th>
              <th style="text-align: center;">–¢—Ä–∞—Ñ–∏–∫</th>
              <th style="text-align: center;">–°—Ç–∞—Ç—É—Å</th>
              <th style="text-align: center;" data-i18n="actions">–î–µ–π—Å—Ç–≤–∏—è</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

</div> <!-- end .container -->

<!-- Modal -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal">
    <h3 id="modalTitle">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</h3>
    <p id="modalText" class="muted"></p>
    <div id="modalInput"></div>
    <div class="modal-actions">
      <button class="btn" id="modalCancel">–û—Ç–º–µ–Ω–∞</button>
      <button class="btn danger" id="modalConfirm">–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å</button>
    </div>
  </div>
</div>

<!-- Toast -->
<div class="toast" id="toast">
  <div class="toast-title" id="toastTitle"></div>
  <div class="toast-text" id="toastText"></div>
</div>

<script>
// ==================== I18N ====================
const i18n = {
  ru: {
    dashboard: '–û–±–∑–æ—Ä',
    users: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏',
    events: '–°–æ–±—ã—Ç–∏—è',
    xray: 'Xray',
    settings: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏',
    topUsers: '–¢–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —Ç—Ä–∞—Ñ–∏–∫—É',
    user: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
    traffic: '–¢—Ä–∞—Ñ–∏–∫',
    daysActive: '–î–Ω–µ–π –∞–∫—Ç–∏–≤–µ–Ω',
    usersManagement: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏',
    usersDesc: '–ó–¥–µ—Å—å –ø–æ–∫–∞–∑–∞–Ω—ã –≤—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞ Xray. –í—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ, —É–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∏–ª–∏ "–∫–∏–∫–Ω—É—Ç—å" ‚Äî —Å–º–µ–Ω–∏—Ç—å UUID.',
    addUser: '–î–æ–±–∞–≤–∏—Ç—å',
    refresh: '–û–±–Ω–æ–≤–∏—Ç—å',
    name: '–ò–º—è',
    actions: '–î–µ–π—Å—Ç–≤–∏—è',
    eventLog: '–ñ—É—Ä–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π',
    eventsDesc: '–ñ—É—Ä–Ω–∞–ª –≤—Å–µ—Ö –¥–µ–π—Å—Ç–≤–∏–π –≤ –ø–∞–Ω–µ–ª–∏.',
    time: '–í—Ä–µ–º—è',
    type: '–¢–∏–ø',
    action: '–î–µ–π—Å—Ç–≤–∏–µ',
    details: '–î–µ—Ç–∞–ª–∏',
    xrayConfig: '–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Xray',
    xrayDesc: '–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ Xray –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ Reality.',
    reload: '–ó–∞–≥—Ä—É–∑–∏—Ç—å',
    restartXray: '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray',
    settingsTitle: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞–Ω–µ–ª–∏',
    settingsDesc: '–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ –∏ –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.',
    save: '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
    todayTraffic: '–¢—Ä–∞—Ñ–∏–∫ —Å–µ–≥–æ–¥–Ω—è',
    yesterdayTraffic: '–¢—Ä–∞—Ñ–∏–∫ –≤—á–µ—Ä–∞',
    totalTraffic: '–í—Å–µ–≥–æ –∑–∞ –ø–µ—Ä–∏–æ–¥',
    activeUsers: '–ê–∫—Ç–∏–≤–Ω—ã—Ö —é–∑–µ—Ä–æ–≤',
    collectorLag: '–õ–∞–≥ —Å–±–æ—Ä—â–∏–∫–∞',
    getLink: '–°—Å—ã–ª–∫–∞',
    kick: '–ö–∏–∫–Ω—É—Ç—å',
    delete: '–£–¥–∞–ª–∏—Ç—å',
    confirmDelete: '–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è',
    confirmKick: '–°–º–µ–Ω–∏—Ç—å UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è? –í—Å–µ —Ç–µ–∫—É—â–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –æ–±–æ—Ä–≤—É—Ç—Å—è.',
    userAdded: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω',
    userDeleted: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω',
    userKicked: 'UUID —Å–º–µ–Ω—ë–Ω, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–∏–∫–Ω—É—Ç',
    linkCopied: '–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞',
    settingsSaved: '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã',
    error: '–û—à–∏–±–∫–∞',
  },
  en: {
    dashboard: 'Dashboard',
    users: 'Users',
    events: 'Events',
    xray: 'Xray',
    settings: 'Settings',
    topUsers: 'Top users by traffic',
    user: 'User',
    traffic: 'Traffic',
    daysActive: 'Days active',
    usersManagement: 'Users management',
    usersDesc: 'All users from Xray config. You can add, delete or kick (change UUID to disconnect current sessions).',
    addUser: 'Add',
    refresh: 'Refresh',
    name: 'Name',
    actions: 'Actions',
    eventLog: 'Event log',
    eventsDesc: 'Log of all actions in the panel.',
    time: 'Time',
    type: 'Type',
    action: 'Action',
    details: 'Details',
    xrayConfig: 'Xray Configuration',
    xrayDesc: 'View Xray config and Reality params.',
    reload: 'Reload',
    restartXray: 'Restart Xray',
    settingsTitle: 'Panel Settings',
    settingsDesc: 'Configure server address and other params.',
    save: 'Save',
    todayTraffic: 'Today traffic',
    yesterdayTraffic: 'Yesterday traffic',
    totalTraffic: 'Total for period',
    activeUsers: 'Active users',
    collectorLag: 'Collector lag',
    getLink: 'Link',
    kick: 'Kick',
    delete: 'Delete',
    confirmDelete: 'Are you sure you want to delete user',
    confirmKick: 'Change user UUID? All current connections will be dropped.',
    userAdded: 'User added',
    userDeleted: 'User deleted',
    userKicked: 'UUID changed, user kicked',
    linkCopied: 'Link copied',
    settingsSaved: 'Settings saved',
    error: 'Error',
  }
};

function t(key) {
  return i18n[state.lang]?.[key] || i18n.en[key] || key;
}

function applyI18n() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    el.textContent = t(key);
  });
}

// ==================== UTILS ====================
function $(sel) { return document.querySelector(sel); }
function $$(sel) { return document.querySelectorAll(sel); }

function fmtBytes(n) {
  n = Number(n || 0);
  const units = ['B', 'KB', 'MB', 'GB', 'TB'];
  let i = 0;
  while (n >= 1024 && i < units.length - 1) { n /= 1024; i++; }
  return (i === 0 ? n.toFixed(0) : n.toFixed(2)) + ' ' + units[i];
}

function fmtDate(iso) {
  if (!iso) return '‚Äî';
  try {
    const d = new Date(iso);
    return d.toLocaleString(state.lang === 'ru' ? 'ru-RU' : 'en-US', {
      day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'
    });
  } catch { return iso; }
}

function showToast(title, text) {
  $('#toastTitle').textContent = title;
  $('#toastText').textContent = text || '';
  $('#toast').classList.add('show');
  setTimeout(() => $('#toast').classList.remove('show'), 3000);
}

async function api(path, opts = {}) {
  try {
    const res = await fetch(path, {
      headers: { 'Content-Type': 'application/json' },
      ...opts
    });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    const data = await res.json();
    // If response has 'ok' field, check it
    if (data.hasOwnProperty('ok') && !data.ok && data.error) {
      throw new Error(data.error);
    }
    return data;
  } catch (e) {
    console.error('API error:', path, e);
    const msg = e.message || '–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞';
    if ($('#toast')) {
      showToast('‚ùå', msg);
    }
    throw e;
  }
}

function modal(title, text, inputHtml = '', cancelText = '–û—Ç–º–µ–Ω–∞', confirmText = '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', confirmDanger = false) {
  return new Promise(resolve => {
    $('#modalTitle').textContent = title;
    $('#modalText').innerHTML = text; // Use innerHTML to support HTML
    $('#modalInput').innerHTML = inputHtml;
    
    // Update button texts
    const cancelBtn = $('#modalCancel');
    const confirmBtn = $('#modalConfirm');
    if (cancelBtn) cancelBtn.textContent = cancelText;
    if (confirmBtn) {
      confirmBtn.textContent = confirmText;
      if (confirmDanger) {
        confirmBtn.classList.add('danger');
      } else {
        confirmBtn.classList.remove('danger');
      }
    }
    
    $('#modalOverlay').classList.add('show');
    
    const cleanup = () => {
      $('#modalOverlay').classList.remove('show');
      $('#modalConfirm').onclick = null;
      $('#modalCancel').onclick = null;
    };
    
    $('#modalConfirm').onclick = () => {
      cleanup();
      const input = $('#modalInput input') || $('#modalInput textarea') || null;
      if (input) {
        resolve(input.value);
      } else {
        resolve(true);
      }
    };
    $('#modalCancel').onclick = () => {
      cleanup();
      resolve(null);
    };
  });
}

// ==================== THEME ====================
function setTheme(theme) {
  state.theme = theme;
  document.documentElement.setAttribute('data-theme', theme);
  const themeIcon = $('#themeIcon');
  const themeText = $('#themeText');
  if (themeIcon) themeIcon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
  if (themeText) themeText.textContent = theme === 'dark' ? '–¢—ë–º–Ω–∞—è' : '–°–≤–µ—Ç–ª–∞—è';
  localStorage.setItem('theme', theme);
  localStorage.setItem('ui.theme', theme);
}

// ==================== TABS ====================
function setTab(tab) {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë setTab CALLED with tab:', tab);
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  
  if (!tab) {
    console.warn('setTab called without tab parameter');
    return;
  }
  
  // Update tabs
  $$('.tab').forEach(t => {
    if (t && t.dataset) {
      t.classList.toggle('active', t.dataset.tab === tab);
    }
  });
  
  // Show/hide overview metric filter (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã "–û–±–∑–æ—Ä")
  const overviewFilter = $('#overviewMetricFilter');
  if (overviewFilter) {
    overviewFilter.style.display = (tab === 'dashboard') ? 'flex' : 'none';
  }
  
  // Update panes - hide all, show active
  // Map dashboard tab to management pane, system tab to system pane
  let targetPane;
  if (tab === 'dashboard') {
    targetPane = 'management';
  } else if (tab === 'system') {
    targetPane = 'system';
  } else {
    targetPane = tab;
  }
  
  console.log('setTab: targetPane =', targetPane);
  
  $$('.pane').forEach(p => {
    if (p && p.dataset) {
      const paneName = p.dataset.pane;
      
      // Show target pane if it matches
      if (paneName === targetPane) {
        p.classList.add('active');
        p.style.display = 'block';
        // Force visibility - override any inline styles or CSS that might hide it
        p.style.visibility = 'visible';
        p.style.opacity = '1';
        // Force reflow
        void p.offsetWidth;
        console.log(`setTab: Showing pane "${paneName}", computed display: ${window.getComputedStyle(p).display}`);
      } 
      // Hide all other panes
      else {
        p.classList.remove('active');
        p.style.display = 'none';
      }
    }
  });
  
  // Debug: Check if target pane exists and is visible
  const targetPaneEl = document.querySelector(`[data-pane="${targetPane}"]`);
  if (!targetPaneEl) {
    console.error(`setTab: Pane "${targetPane}" not found!`);
  } else {
    const computedStyle = window.getComputedStyle(targetPaneEl);
    console.log(`setTab: Target pane "${targetPane}" found`);
    console.log(`setTab: - display: ${computedStyle.display}, visibility: ${computedStyle.visibility}, opacity: ${computedStyle.opacity}`);
    console.log(`setTab: - has active class: ${targetPaneEl.classList.contains('active')}`);
    const rect = targetPaneEl.getBoundingClientRect();
    console.log(`setTab: - bounds: ${rect.width}x${rect.height} at (${rect.left}, ${rect.top}), visible: ${rect.width > 0 && rect.height > 0}`);
  }
  
  // Deactivate nav pills when switching to tabs
  $$('.nav-pill').forEach(p => {
    if (p) p.classList.remove('active');
  });
  
  // Load content for active tab
  if (tab === 'dashboard') {
    // Dashboard directly shows management pane (no nav pill needed)
    loadManagement();
  } else if (tab === 'users') {
    console.log('setTab: Loading users tab');
    const usersPane = document.querySelector('[data-pane="users"]');
    if (usersPane) {
      console.log('setTab: Users pane found, ensuring it is visible');
      usersPane.classList.add('active');
      usersPane.style.display = 'block';
      // Force reflow
      void usersPane.offsetHeight;
    } else {
      console.error('setTab: Users pane NOT found!');
    }
    
    // Load users data with a small delay to ensure DOM is ready
    setTimeout(() => {
      console.log('setTab: Calling loadUsers() after delay');
      loadUsers();
    }, 100);
  } else if (tab === 'system') {
    // System tab - show first subpane (services) by default
    setSystemSubpane('services');
  }
}

// System sub-pane switcher
function setSystemSubpane(subpane) {
  if (!subpane) return;
  
  // Update system tabs
  $$('.system-tab').forEach(t => {
    if (t && t.dataset) {
      t.classList.toggle('active', t.dataset.systemTab === subpane);
    }
  });
  
  // Show/hide sub-panes
  $$('.system-subpane').forEach(p => {
    if (p && p.dataset) {
      const isActive = p.dataset.systemSubpane === subpane;
      p.classList.toggle('active', isActive);
      p.style.display = isActive ? 'block' : 'none';
    }
  });
  
  // Load content for active sub-pane
  if (subpane === 'services') {
    loadSystemStatus(); // Load service status
  } else if (subpane === 'events') {
    loadEvents();
  } else if (subpane === 'settings') {
    loadSettings(); // This will also load Xray config
  }
}

// ==================== STATE & LOCALSTORAGE ====================
const state = {
  settings: null,
  users: [],
  lang: localStorage.getItem('ui.lang') || 'ru',
  theme: localStorage.getItem('ui.theme') || 'dark',
  unit: localStorage.getItem('ui.unit') || 'gb',
  chartLibrary: localStorage.getItem('ui.chartLibrary') || 'amcharts', // 'amcharts', 'apexcharts', 'observable', 'highcharts', 'vegalite', 'recharts'
  mode: localStorage.getItem('usage.mode') || 'daily',
  date: localStorage.getItem('usage.date') || '',
  selectedUsers: JSON.parse(localStorage.getItem('users.selected') || '[]'),
  mainMetric: localStorage.getItem('users.mainMetric') || 'traffic',
  miniMetric: localStorage.getItem('users.miniMetric') || 'traffic',
  overviewMetric: localStorage.getItem('overview.metric') || 'traffic', // 'traffic' | 'conns' - –µ–¥–∏–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã "–û–±–∑–æ—Ä"
  livePeriod: parseInt(localStorage.getItem('live.period') || '3600'),
  liveGran: parseInt(localStorage.getItem('live.gran') || '300'),
  liveMetric: localStorage.getItem('live.metric') || 'conns',
  liveScope: localStorage.getItem('live.scope') || 'global',
  livePaused: localStorage.getItem('live.paused') === 'true',
  dashboard: null,
};

// ==================== NAVIGATION ====================
function setNav(nav) {
  if (!nav) {
    console.warn('setNav called without nav parameter');
    return;
  }
  
  // Update nav pills
  const navPills = $$('.nav-pill');
  navPills.forEach(p => {
    if (p && p.dataset) {
      const isActive = p.dataset.nav === nav;
      if (isActive) {
        p.classList.add('active');
      } else {
        p.classList.remove('active');
      }
    }
  });
  
  // Update panes - hide all, show active
  const panes = $$('.pane');
  panes.forEach(p => {
    if (p && p.dataset) {
      const paneName = p.dataset.pane;
      
      // Show target nav pane
      if (paneName === nav) {
        p.classList.add('active');
        p.style.display = 'block';
      } 
      // Hide all other panes
      else {
        p.classList.remove('active');
        p.style.display = 'none';
      }
    }
  });
  
  // Deactivate tabs when switching to nav pills
  $$('.tab').forEach(t => {
    if (t) t.classList.remove('active');
  });
  
  // Load content for active pane
  if (nav === 'online') {
    startOnlinePolling(); // –ó–∞–ø—É—Å—Ç–∏—Ç—å online polling —Ç–æ–ª—å–∫–æ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online
  } else if (nav === 'status') {
    // Status section removed - info is in header badges and settings
    setTab('settings');
  } else if (nav === 'services') {
    stopOnlinePolling();
    loadServices(); // Load services management
  }
}

// ==================== MANAGEMENT (–ò—Å—Ç–æ—Ä–∏—è) ====================
async function loadManagement() {
  try {
    let date = state.date;
    if (!date) {
      date = await getLastAvailableDate();
    }
    if (!date) {
      console.warn('No date available for dashboard');
      showToast('‚ö†Ô∏è', '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è');
      return;
    }
    
    console.log('Loading dashboard for date:', date, 'mode:', state.mode);
    const data = await api(`/api/usage/dashboard?date=${date}&mode=${state.mode}&windowDays=7`);
    
    // API returns {ok: true, ...} or just data
    if (data && (data.ok !== false)) {
      console.log('Dashboard data loaded successfully:', {
        summary: data.summary ? 'present' : 'missing',
        trends: data.trends ? 'present' : 'missing',
        users: data.users ? `${data.users.length} users` : 'missing',
        meta: data.meta || {}
      });
      state.dashboard = data;
      renderManagement(data);
    } else {
      console.error('Dashboard data invalid:', data);
      showToast('‚ùå', '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö');
    }
  } catch (e) {
    console.error('Management load error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
  }
}

async function getLastAvailableDate() {
  try {
    const res = await api('/api/usage/dates');
    // Handle both {ok: true, dates: [...]} and {dates: [...]} formats
    const dates = (res && res.ok && res.dates) ? res.dates : (res && res.dates ? res.dates : []);
    if (dates && dates.length > 0) {
      // Prefer today's date, otherwise use the first (most recent) date
      const today = new Date().toISOString().split('T')[0];
      const date = dates.includes(today) ? today : dates[0];
      state.date = date;
      localStorage.setItem('usage.date', state.date);
      return date;
    }
  } catch (e) {
    console.error('Error getting last available date:', e);
  }
  return null;
}

function renderManagement(data) {
  if (!data) {
    console.warn('renderManagement: no data');
    return;
  }
  // Handle both {ok: true, ...} and direct data formats
  if (data.hasOwnProperty('ok') && !data.ok) {
    console.warn('renderManagement: data.ok is false', data);
    return;
  }
  
  console.log('renderManagement: rendering data', {
    summary: data.summary ? 'present' : 'missing',
    trends: data.trends ? 'present' : 'missing',
    topDomains: data.topDomains ? 'present' : 'missing',
    users: data.users ? `${data.users.length} users` : 'missing',
    userDetails: data.userDetails ? `${Object.keys(data.userDetails).length} details` : 'missing',
    meta: data.meta || {}
  });
  
  // Ensure DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => renderManagement(data));
    return;
  }
  
  const s = data.summary || {};
  const t = data.trends || {};
  const td = data.topDomains || { traffic: [], conns: [] };
  const u = data.users || [];
  const ud = data.userDetails || {};
  const meta = data.meta || {};
  
  // Render KPI cards
  try {
    console.log('renderManagement: calling renderKPICards with summary:', s);
    renderKPICards(s, td, state.unit);
    console.log('renderManagement: renderKPICards completed');
  } catch (e) {
    console.error('Error rendering KPI cards:', e);
    console.error('Error stack:', e.stack);
  }
  
  // Render trends charts - force update by disposing old charts first
  // Destroy amCharts
  if (typeof trafficChart !== 'undefined' && trafficChart) {
    try {
      trafficChart.dispose();
    } catch (e) {
      console.warn('Error disposing traffic chart:', e);
    }
    trafficChart = null;
  }
  if (typeof connsChart !== 'undefined' && connsChart) {
    try {
      connsChart.dispose();
    } catch (e) {
      console.warn('Error disposing conns chart:', e);
    }
    connsChart = null;
  }
  // Destroy ApexCharts
  if (typeof trafficChartApex !== 'undefined' && trafficChartApex) {
    try {
      trafficChartApex.destroy();
    } catch (e) {
      console.warn('Error destroying traffic ApexChart:', e);
    }
    trafficChartApex = null;
  }
  if (typeof connsChartApex !== 'undefined' && connsChartApex) {
    try {
      connsChartApex.destroy();
    } catch (e) {
      console.warn('Error destroying conns ApexChart:', e);
    }
    connsChartApex = null;
  }
  // Destroy Highcharts
  if (window.trafficChartHighcharts) {
    try {
      window.trafficChartHighcharts.destroy();
    } catch (e) {
      console.warn('Error destroying traffic Highcharts:', e);
    }
    window.trafficChartHighcharts = null;
  }
  if (window.connsChartHighcharts) {
    try {
      window.connsChartHighcharts.destroy();
    } catch (e) {
      console.warn('Error destroying conns Highcharts:', e);
    }
    window.connsChartHighcharts = null;
  }
  // Destroy users comparison charts
  if (usersCmpChart) {
    try {
      usersCmpChart.dispose();
    } catch (e) {
      console.warn('Error disposing users comparison chart:', e);
    }
    usersCmpChart = null;
  }
  if (window.usersCmpChartApex) {
    try {
      window.usersCmpChartApex.destroy();
    } catch (e) {
      console.warn('Error destroying users comparison ApexChart:', e);
    }
    window.usersCmpChartApex = null;
  }
  if (window.usersCmpChartHighcharts) {
    try {
      window.usersCmpChartHighcharts.destroy();
    } catch (e) {
      console.warn('Error destroying users comparison Highcharts:', e);
    }
    window.usersCmpChartHighcharts = null;
  }
  // Clear Observable Plot and Vega-Lite charts (they are DOM-based)
  const chartElements = ['chTraffic', 'chConns', 'chUsersTraffic', 'chUsersConns', 'chUsersCmp'];
  chartElements.forEach(id => {
    const el = document.getElementById(id);
    if (el && (state.chartLibrary === 'observable' || state.chartLibrary === 'vegalite')) {
      el.innerHTML = '';
    }
  });
  renderTrendsCharts(t, state.mode, state.unit);
  
  // Render top domains tables
  renderTopDomainsTables(td, state.unit);
  
  // Render users histograms (always show ALL users, not filtered)
  // These are separate from the user filter in the Users section
  renderUsersHistograms(u, state.unit);
  
  // Render users section
  renderUsersSection(u, ud, state.selectedUsers, state.mainMetric, state.miniMetric, state.mode, state.unit);
  
  // Update date select
  updateDateSelect();
}

function renderKPICards(summary, topDomains, unit) {
  if (!summary) {
    console.warn('renderKPICards: no summary data');
    return;
  }
  if (!topDomains) {
    console.warn('renderKPICards: no topDomains data');
    topDomains = { traffic: [], conns: [], top3TrafficDomains: [], top3ConnsDomains: [] };
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Today traffic
  const todayTraffic = (summary.todayTrafficBytes || 0) / base;
  const yesterdayTraffic = (summary.yesterdayTrafficBytes || 0) / base;
  const avg7dTraffic = (summary.avg7dTrafficBytes || 0) / base;
  const deltaTodayTraffic = summary.deltaTodayTrafficPct;
  
  const el1 = $('#kpiTodayTrafficValue');
  const el2 = $('#kpiTodayTrafficAvg');
  if (el1) el1.textContent = todayTraffic.toFixed(2) + ' ' + unitLabel;
  if (el2) el2.textContent = avg7dTraffic.toFixed(2) + ' ' + unitLabel;
  renderBubble($('#kpiTodayTrafficBubble'), deltaTodayTraffic);
  
  // Today conns
  const todayConns = summary.todayConns || 0;
  const yesterdayConns = summary.yesterdayConns || 0;
  const avg7dConns = Math.round(summary.avg7dConns || 0);
  const deltaTodayConns = summary.deltaTodayConnsPct;
  
  const el3 = $('#kpiTodayConnsValue');
  const el4 = $('#kpiTodayConnsAvg');
  if (el3) el3.textContent = todayConns.toLocaleString('ru-RU');
  if (el4) el4.textContent = avg7dConns.toLocaleString('ru-RU');
  renderBubble($('#kpiTodayConnsBubble'), deltaTodayConns);
  
  // 7d total traffic
  const total7dTraffic = (summary.total7dTrafficBytes || 0) / base;
  const prevTotal7dTraffic = (summary.prevTotal7dTrafficBytes || 0) / base;
  const deltaTotal7dTraffic = summary.deltaTotal7dTrafficPct;
  
  const el5 = $('#kpiTotal7dTrafficValue');
  if (el5) el5.textContent = total7dTraffic.toFixed(2) + ' ' + unitLabel;
  renderBubble($('#kpiTotal7dTrafficBubble'), deltaTotal7dTraffic);
  
  // 7d total conns
  const total7dConns = summary.total7dConns || 0;
  const prevTotal7dConns = summary.prevTotal7dConns || 0;
  const deltaTotal7dConns = summary.deltaTotal7dConnsPct;
  
  const el6 = $('#kpiTotal7dConnsValue');
  if (el6) el6.textContent = total7dConns.toLocaleString('ru-RU');
  renderBubble($('#kpiTotal7dConnsBubble'), deltaTotal7dConns);
  
  // Top domains traffic (top-3) - display with traffic data
  const top3TrafficData = (topDomains.traffic || []).slice(0, 3);
  const el7 = $('#kpiTopDomainsTrafficList');
  if (el7) {
    if (top3TrafficData.length > 0) {
      const domainsText = top3TrafficData.map(d => {
        const domain = d.domain || '‚Äî';
        const traffic = ((d.trafficBytes || 0) / base).toFixed(2);
        return `${domain} (${traffic} ${unitLabel})`;
      }).join(' | ');
      el7.innerHTML = `<div class="kpi-list-item" style="padding:2px 0;justify-content:flex-start;"><span>${domainsText}</span></div>`;
    } else {
      el7.innerHTML = '<div class="kpi-list-item" style="padding:2px 0;"><span>‚Äî</span></div>';
    }
  }
  renderBubble($('#kpiTopDomainsTrafficBubble'), deltaTotal7dTraffic);
  
  // Top domains conns (top-3) - display with conns data
  const top3ConnsData = (topDomains.conns || []).slice(0, 3);
  const el8 = $('#kpiTopDomainsConnsList');
  if (el8) {
    if (top3ConnsData.length > 0) {
      const domainsText = top3ConnsData.map(d => {
        const domain = d.domain || '‚Äî';
        const conns = (d.conns || 0).toLocaleString('ru-RU');
        return `${domain} (${conns})`;
      }).join(' | ');
      el8.innerHTML = `<div class="kpi-list-item" style="padding:2px 0;justify-content:flex-start;"><span>${domainsText}</span></div>`;
    } else {
      el8.innerHTML = '<div class="kpi-list-item" style="padding:2px 0;"><span>‚Äî</span></div>';
    }
  }
  renderBubble($('#kpiTopDomainsConnsBubble'), deltaTotal7dConns);
  
  // Apply overview metric filter - show/hide cards based on selected metric
  const overviewMetric = state.overviewMetric || 'traffic';
  const trafficCards = [$('#kpiTodayTraffic'), $('#kpiTotal7dTraffic'), $('#kpiTopDomainsTraffic')];
  const connsCards = [$('#kpiTodayConns'), $('#kpiTotal7dConns'), $('#kpiTopDomainsConns')];
  
  if (overviewMetric === 'traffic') {
    // Show traffic cards, hide conns cards
    trafficCards.forEach(card => { if (card) card.style.display = ''; });
    connsCards.forEach(card => { if (card) card.style.display = 'none'; });
  } else {
    // Show conns cards, hide traffic cards
    trafficCards.forEach(card => { if (card) card.style.display = 'none'; });
    connsCards.forEach(card => { if (card) card.style.display = ''; });
  }
}

function renderBubble(el, delta) {
  if (!el) return;
  if (delta === null || delta === undefined) {
    el.textContent = '‚Äî';
    el.className = 'kpi-bubble na';
    return;
  }
  const sign = delta >= 0 ? '+' : '';
  // If delta < -10% or > 10%, round to integer; otherwise 1 decimal place
  let formatted;
  if (delta < -10 || delta > 10) {
    formatted = Math.round(delta).toString();
  } else {
    formatted = delta.toFixed(1);
  }
  el.textContent = `${sign}${formatted}%`;
  el.className = `kpi-bubble ${delta >= 0 ? 'up' : 'down'}`;
}

// ==================== HELPERS ====================
/**
 * –ü–æ–ª—É—á–∞–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ CSS –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
 * @param {string} varName - –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä "--text" –∏–ª–∏ "--muted")
 * @param {string} fallback - –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –µ—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞
 * @returns {string} - –≤—ã—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "#e6edf3")
 */
function getCSSColor(varName, fallback = '#8b949e') {
  try {
    const root = document.documentElement;
    if (!root || typeof root !== 'object') {
      return fallback;
    }
    const style = getComputedStyle(root);
    if (!style) {
      return fallback;
    }
    const value = style.getPropertyValue(varName).trim();
    return value || fallback;
  } catch (e) {
    console.warn(`Failed to get CSS color for ${varName}:`, e);
    return fallback;
  }
}

/**
 * –û–±—ë—Ä—Ç–∫–∞ –¥–ª—è am5.color —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
 * @param {string} varName - –∏–º—è CSS –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä "--text")
 * @param {string} fallback - –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
 * @returns {am5.Color} - –æ–±—ä–µ–∫—Ç —Ü–≤–µ—Ç–∞ amCharts
 */
function amColorVar(varName, fallback = '#8b949e') {
  const colorValue = getCSSColor(varName, fallback);
  return am5.color(colorValue);
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–Ω–æ –ª–∏ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ
 * @param {HTMLElement} el - —ç–ª–µ–º–µ–Ω—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
 * @returns {boolean} - true –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –≥–æ—Ç–æ–≤ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
 */
function isRenderable(el) {
  if (!el || !(el instanceof Element)) {
    return false;
  }
  try {
    const rect = el.getBoundingClientRect();
    // –≠–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ DOM –∏ –∏–º–µ—Ç—å —Ä–∞–∑–º–µ—Ä—ã
    return rect.width > 0 && rect.height > 0;
  } catch (e) {
    return false;
  }
}

let trafficChart = null;
let connsChart = null;
// ApexCharts instances
let trafficChartApex = null;
let connsChartApex = null;

// Chart library wrapper - routes to appropriate renderer
function renderTrendsCharts(trends, mode, unit) {
  // Apply overview metric filter - show/hide chart containers (vertical layout)
  const overviewMetric = state.overviewMetric || 'traffic';
  const elTraffic = $('#chTraffic');
  const elConns = $('#chConns');
  const containerTraffic = elTraffic ? elTraffic.closest('.chartbox') : null;
  const containerConns = elConns ? elConns.closest('.chartbox') : null;
  
  if (overviewMetric === 'traffic') {
    // Show traffic chart, hide conns chart
    if (containerTraffic) containerTraffic.style.display = 'block';
    if (containerConns) containerConns.style.display = 'none';
  } else {
    // Show conns chart, hide traffic chart
    if (containerTraffic) containerTraffic.style.display = 'none';
    if (containerConns) containerConns.style.display = 'block';
  }
  
  // Render charts (both will render, but only one will be visible)
  if (state.chartLibrary === 'apexcharts' && typeof ApexCharts !== 'undefined') {
    renderTrendsChartsApex(trends, mode, unit);
  } else if (state.chartLibrary === 'observable') {
    renderTrendsChartsObservable(trends, mode, unit);
  } else if (state.chartLibrary === 'highcharts' && typeof Highcharts !== 'undefined') {
    renderTrendsChartsHighcharts(trends, mode, unit);
  } else if (state.chartLibrary === 'vegalite' && typeof vegaEmbed !== 'undefined') {
    renderTrendsChartsVegaLite(trends, mode, unit);
  } else if (state.chartLibrary === 'recharts' && typeof d3 !== 'undefined') {
    renderTrendsChartsRecharts(trends, mode, unit);
  } else {
    renderTrendsChartsAmCharts(trends, mode, unit);
  }
}

// amCharts version (original)
function renderTrendsChartsAmCharts(trends, mode, unit) {
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Traffic chart
  const trafficData = trends.trafficDailyBytes || [];
  if (trafficData.length === 0) {
    console.warn('renderTrendsCharts: no traffic data');
  }
  
  const trafficLabels = trafficData.map(t => {
    try {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      if (!dateStr) return '‚Äî';
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return '‚Äî';
      return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
    } catch (e) {
      console.error('Error parsing traffic date:', t, e);
      return '‚Äî';
    }
  });
  const trafficValues = trafficData.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    return Number(val) / base;
  });
  
  const elTraffic = document.getElementById('chTraffic');
  if (!elTraffic) {
    console.warn('chTraffic element not found');
    return;
  }
  
  // Destroy existing chart if exists (amCharts)
  if (trafficChart) {
    try {
      trafficChart.dispose();
    } catch (e) {
      console.warn('Error disposing traffic chart:', e);
    }
    trafficChart = null;
  }
  // Destroy ApexCharts if exists
  if (trafficChartApex) {
    try {
      trafficChartApex.destroy();
    } catch (e) {
      console.warn('Error destroying traffic ApexChart:', e);
    }
    trafficChartApex = null;
  }
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = document.getElementById('chTraffic');
      if (!elCheck || elCheck !== elTraffic) {
        console.warn('renderTrendsCharts: chTraffic element changed');
        return;
      }
      
      const maxValue = Math.max(...trafficValues, 1);
      
      // Create root element
      const root = am5.Root.new(elCheck);
    root.setThemes([
      am5themes_Animated.new(root)
    ]);
    
    // Create chart
    const chart = root.container.children.push(am5xy.XYChart.new(root, {
      panX: false,
      panY: false,
      wheelX: "none",
      wheelY: "none",
      paddingLeft: 0,
      paddingRight: 0
    }));
    
    // Create axes
    const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
      categoryField: "category",
      renderer: am5xy.AxisRendererX.new(root, {
        cellStartLocation: 0.1,
        cellEndLocation: 0.9,
        minGridDistance: 30
      })
    }));
    
    xAxis.data.setAll(trafficLabels.map((label, idx) => ({
      category: label
    })));
    
    const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
      renderer: am5xy.AxisRendererY.new(root, {})
    }));
    
    // Create series
    const series = chart.series.push(am5xy.ColumnSeries.new(root, {
      name: `Traffic (${unitLabel})`,
      xAxis: xAxis,
      yAxis: yAxis,
      valueYField: "value",
      categoryXField: "category"
    }));
    
    // Configure columns with gradient fill
    series.columns.template.setAll({
      tooltipText: "{categoryX}: {valueY.formatNumber('#.00')} {unitLabel}",
      tooltipY: 0,
      strokeOpacity: 0,
      cornerRadiusTL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBL: 8,
      cornerRadiusBR: 8
    });
    
    // Dynamic fill color based on value
    series.columns.template.adapters.add("fill", (fill, target) => {
      const dataItem = target.dataItem;
      if (dataItem) {
        const value = dataItem.get("valueY");
        const ratio = maxValue > 0 ? value / maxValue : 0;
        const opacity = 0.4 + ratio * 0.4;
        return am5.color(`rgba(88, 166, 255, ${opacity})`);
      }
      return fill;
    });
    
    // Labels added via bullets for ColumnSeries
    series.bullets.push(function() {
      const label = am5.Label.new(root, {
        text: "",
        fill: amColorVar("--text"),
        centerY: 0,
        centerX: am5.p50,
        fontSize: 11,
        fontWeight: "bold",
        dy: -5
      });
      // Format text using adapter
      label.adapters.add("text", (text, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const value = dataItem.get("valueY");
          return value ? value.toFixed(2) : "";
        }
        return "";
      });
      return am5.Bullet.new(root, {
        locationY: 1,
        sprite: label
      });
    });
    
    // Set data
    series.data.setAll(trafficValues.map((val, idx) => ({
      category: trafficLabels[idx],
      value: val,
      unitLabel: unitLabel
    })));
    
    // Add cursor
    chart.set("cursor", am5xy.XYCursor.new(root, {}));
    
      trafficChart = root;
    } catch (e) {
      console.error('Error creating traffic chart:', e);
      trafficChart = null;
    }
  });
  
  // Conns chart
  const connsData = trends.connsDaily || [];
  if (connsData.length === 0) {
    console.warn('renderTrendsCharts: no conns data');
  }
  
  const connsLabels = connsData.map(t => {
    try {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      if (!dateStr) {
        console.warn('renderTrendsCharts: empty dateStr in conns data:', t);
        return '‚Äî';
      }
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) {
        console.warn('renderTrendsCharts: invalid date for conns:', dateStr, t);
        return '‚Äî';
      }
      const label = d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
      return label;
    } catch (e) {
      console.error('Error parsing conns date:', t, e);
      return '‚Äî';
    }
  });
  const connsValues = connsData.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    const numVal = Number(val) || 0;
    return numVal;
  });
  
  // Debug: log data for troubleshooting
  console.log('renderTrendsCharts: connsData length:', connsData.length);
  console.log('renderTrendsCharts: connsLabels:', connsLabels);
  console.log('renderTrendsCharts: connsValues:', connsValues);
  
  const elConns = document.getElementById('chConns');
  if (!elConns) {
    console.warn('chConns element not found');
    return;
  }
  
  // Destroy existing chart if exists (amCharts)
  if (connsChart) {
    try {
      connsChart.dispose();
    } catch (e) {
      console.warn('Error disposing conns chart:', e);
    }
    connsChart = null;
  }
  // Destroy ApexCharts if exists
  if (connsChartApex) {
    try {
      connsChartApex.destroy();
    } catch (e) {
      console.warn('Error destroying conns ApexChart:', e);
    }
    connsChartApex = null;
  }
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = document.getElementById('chConns');
      if (!elCheck || elCheck !== elConns) {
        console.warn('renderTrendsCharts: chConns element changed');
        return;
      }
      
      const maxValue = Math.max(...connsValues, 1);
      
      // Create root element
      const root = am5.Root.new(elCheck);
    root.setThemes([
      am5themes_Animated.new(root)
    ]);
    
    // Create chart
    const chart = root.container.children.push(am5xy.XYChart.new(root, {
      panX: false,
      panY: false,
      wheelX: "none",
      wheelY: "none",
      paddingLeft: 0,
      paddingRight: 0
    }));
    
    // Create axes
    const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
      categoryField: "category",
      renderer: am5xy.AxisRendererX.new(root, {
        cellStartLocation: 0.1,
        cellEndLocation: 0.9,
        minGridDistance: 30
      })
    }));
    
    // Set X-axis data - ensure all categories are included, even with 0 values
    const xAxisData = connsLabels.map((label, idx) => ({
      category: label
    }));
    xAxis.data.setAll(xAxisData);
    console.log('renderTrendsCharts: xAxis data set:', xAxisData.length, 'categories');
    
    const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
      renderer: am5xy.AxisRendererY.new(root, {}),
      min: 0  // Ensure Y-axis starts at 0 to show zero values
    }));
    
    // Create series
    const series = chart.series.push(am5xy.ColumnSeries.new(root, {
      name: "Connections",
      xAxis: xAxis,
      yAxis: yAxis,
      valueYField: "value",
      categoryXField: "category"
    }));
    
    // Configure columns with gradient fill
    series.columns.template.setAll({
      tooltipText: "{categoryX}: {valueY.formatNumber('#,###')} connections",
      tooltipY: 0,
      strokeOpacity: 0,
      cornerRadiusTL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBL: 8,
      cornerRadiusBR: 8
    });
    
    // Ensure zero values create visible columns (minimum height)
    series.columns.template.adapters.add("height", (height, target) => {
      const dataItem = target.dataItem;
      if (dataItem) {
        const value = dataItem.get("valueY");
        // For zero values, show a minimal visible bar (2px) so the date is visible on graph
        if (value === 0 || value === null || value === undefined) {
          return 2;  // 2px minimum height for zero values
        }
      }
      return height;
    });
    
    // Dynamic fill color based on value
    series.columns.template.adapters.add("fill", (fill, target) => {
      const dataItem = target.dataItem;
      if (dataItem) {
        const value = dataItem.get("valueY");
        // For zero values, use a very light color but still visible
        if (value === 0 || value === null || value === undefined) {
          return am5.color(`rgba(63, 185, 80, 0.15)`);  // Very light green for zero (slightly more visible)
        }
        const ratio = maxValue > 0 ? value / maxValue : 0;
        const opacity = 0.4 + ratio * 0.4;
        return am5.color(`rgba(63, 185, 80, ${opacity})`);
      }
      return fill;
    });
    
    // Labels added via bullets for ColumnSeries
    series.bullets.push(function() {
      const label = am5.Label.new(root, {
        text: "",
        fill: amColorVar("--text"),
        centerY: 0,
        centerX: am5.p50,
        fontSize: 11,
        fontWeight: "bold",
        dy: -5
      });
      // Format text using adapter
      label.adapters.add("text", (text, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const value = dataItem.get("valueY");
          return value ? value.toLocaleString('ru-RU') : "";
        }
        return "";
      });
      return am5.Bullet.new(root, {
        locationY: 1,
        sprite: label
      });
    });
    
    // Set data - ensure all data points are included, even with 0 values
    const seriesData = connsValues.map((val, idx) => ({
      category: connsLabels[idx],
      value: val
    }));
    console.log('renderTrendsCharts: series data set:', seriesData.length, 'points');
    console.log('renderTrendsCharts: series data sample:', seriesData.slice(0, 3));
    series.data.setAll(seriesData);
    
    // Add cursor
    chart.set("cursor", am5xy.XYCursor.new(root, {}));
    
      connsChart = root;
    } catch (e) {
      console.error('Error creating conns chart:', e);
      connsChart = null;
    }
  });
}

// ApexCharts version (alternative - –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏)
function renderTrendsChartsApex(trends, mode, unit) {
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Prepare data (same logic as amCharts version)
  const trafficData = trends.trafficDailyBytes || [];
  const trafficLabels = trafficData.map(t => {
    try {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      if (!dateStr) return '‚Äî';
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return '‚Äî';
      return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
    } catch (e) {
      return '‚Äî';
    }
  });
  const trafficValues = trafficData.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    return Number(val) / base;
  });
  
  const connsData = trends.connsDaily || [];
  const connsLabels = connsData.map(t => {
    try {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      if (!dateStr) return '‚Äî';
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return '‚Äî';
      return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
    } catch (e) {
      return '‚Äî';
    }
  });
  const connsValues = connsData.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    return Number(val) || 0;
  });
  
  // Get theme colors
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  
  // Destroy existing ApexCharts
  if (trafficChartApex) {
    trafficChartApex.destroy();
    trafficChartApex = null;
  }
  if (connsChartApex) {
    connsChartApex.destroy();
    connsChartApex = null;
  }
  
  // Traffic chart
  const elTraffic = document.getElementById('chTraffic');
  if (elTraffic) {
    elTraffic.innerHTML = ''; // Clear for ApexCharts
    
    const maxValue = Math.max(...trafficValues, 1);
    
    trafficChartApex = new ApexCharts(elTraffic, {
      series: [{
        name: `Traffic (${unitLabel})`,
        data: trafficValues
      }],
      chart: {
        type: 'bar',
        height: '100%',
        toolbar: { show: false },
        animations: { enabled: true, easing: 'easeinout', speed: 800 }
      },
      plotOptions: {
        bar: {
          borderRadius: 8,
          columnWidth: '60%',
          dataLabels: { position: 'top' }
        }
      },
      dataLabels: {
        enabled: true,
        formatter: (val) => val.toFixed(2),
        offsetY: -20,
        style: { fontSize: '11px', colors: [textColor], fontWeight: 'bold' }
      },
      xaxis: {
        categories: trafficLabels,
        labels: { style: { colors: textColor } },
        axisBorder: { color: gridColor },
        axisTicks: { color: gridColor }
      },
      yaxis: {
        labels: { style: { colors: textColor } },
        title: { text: unitLabel, style: { color: textColor } }
      },
      grid: {
        borderColor: gridColor,
        strokeDashArray: 4
      },
      tooltip: {
        theme: isDark ? 'dark' : 'light',
        y: { formatter: (val) => `${val.toFixed(2)} ${unitLabel}` }
      },
      colors: [accentColor],
      fill: {
        type: 'gradient',
        gradient: {
          shade: isDark ? 'dark' : 'light',
          type: 'vertical',
          shadeIntensity: 0.5,
          gradientToColors: [accentColor],
          inverseColors: false,
          opacityFrom: 0.6,
          opacityTo: 0.3,
          stops: [0, 100]
        }
      }
    });
    
    trafficChartApex.render();
  }
  
  // Conns chart
  const elConns = document.getElementById('chConns');
  if (elConns) {
    elConns.innerHTML = ''; // Clear for ApexCharts
    
    const maxValue = Math.max(...connsValues, 1);
    
    connsChartApex = new ApexCharts(elConns, {
      series: [{
        name: 'Connections',
        data: connsValues
      }],
      chart: {
        type: 'bar',
        height: '100%',
        toolbar: { show: false },
        animations: { enabled: true, easing: 'easeinout', speed: 800 }
      },
      plotOptions: {
        bar: {
          borderRadius: 8,
          columnWidth: '60%',
          dataLabels: { position: 'top' }
        }
      },
      dataLabels: {
        enabled: true,
        formatter: (val) => val.toLocaleString('ru-RU'),
        offsetY: -20,
        style: { fontSize: '11px', colors: [textColor], fontWeight: 'bold' }
      },
      xaxis: {
        categories: connsLabels,
        labels: { style: { colors: textColor } },
        axisBorder: { color: gridColor },
        axisTicks: { color: gridColor }
      },
      yaxis: {
        labels: { style: { colors: textColor } },
        min: 0
      },
      grid: {
        borderColor: gridColor,
        strokeDashArray: 4
      },
      tooltip: {
        theme: isDark ? 'dark' : 'light',
        y: { formatter: (val) => `${val.toLocaleString('ru-RU')} connections` }
      },
      colors: [okColor],
      fill: {
        type: 'gradient',
        gradient: {
          shade: isDark ? 'dark' : 'light',
          type: 'vertical',
          shadeIntensity: 0.5,
          gradientToColors: [okColor],
          inverseColors: false,
          opacityFrom: 0.6,
          opacityTo: 0.3,
          stops: [0, 100]
        }
      }
    });
    
    connsChartApex.render();
  }
}

// Observable Plot version - Data Journalism / Bloomberg style (–º–∏–Ω–∏–º–∞–ª–∏–∑–º, —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∞)
function renderTrendsChartsObservable(trends, mode, unit) {
  // Observable Plot —á–µ—Ä–µ–∑ UMD —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç Plot
  if (typeof Plot === 'undefined' || typeof Plot.plot !== 'function') {
    console.error('Observable Plot: Plot.plot is not available');
    console.error('typeof Plot:', typeof Plot);
    console.error('Plot object:', Plot);
    if (typeof Plot !== 'undefined') {
      console.error('Plot keys:', Object.keys(Plot));
    }
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  
  // Traffic chart
  const trafficData = trends.trafficDailyBytes || [];
  const elTraffic = document.getElementById('chTraffic');
  if (elTraffic && trafficData.length > 0) {
    try {
      // Check if Plot is available (try different ways)
      const PlotLib = typeof Plot !== 'undefined' ? Plot : (typeof window !== 'undefined' && window.Plot ? window.Plot : null);
      if (!PlotLib) {
        console.error('Observable Plot: Plot is not defined. Available globals:', Object.keys(window).filter(k => k.toLowerCase().includes('plot')));
        return;
      }
      
      elTraffic.innerHTML = '';
      
      const plotData = trafficData.map(t => {
        const dateStr = typeof t === 'object' ? (t.date || '') : '';
        const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
        if (!dateStr) return null;
        const d = new Date(dateStr + 'T00:00:00');
        if (isNaN(d.getTime())) return null;
        return {
          date: d,
          value: Number(val) / base
        };
      }).filter(d => d !== null && d.value !== undefined && !isNaN(d.value));
      
      if (plotData.length === 0) {
        console.warn('renderTrendsChartsObservable: no valid traffic data');
        return;
      }
      
      const width = Math.max(elTraffic.clientWidth || 600, 300);
      const height = Math.max(elTraffic.clientHeight || 300, 200);
      
      console.log('Observable Plot: rendering traffic chart with', plotData.length, 'data points');
      console.log('Observable Plot: Plot object', typeof PlotLib, PlotLib);
      console.log('Observable Plot: sample data', plotData.slice(0, 3));
      
      // Use simpler syntax
      const trafficChart = Plot.plot({
        style: { 
          background: bgColor, 
          color: textColor
        },
        width: width,
        height: height,
        marginTop: 20,
        marginRight: 20,
        marginBottom: 40,
        marginLeft: 60,
        x: { 
          type: 'time', 
          grid: true
        },
        y: { 
          grid: true, 
          label: `Traffic (${unitLabel})`
        },
        marks: [
          Plot.ruleY([0], { stroke: gridColor }),
          Plot.areaY(plotData, { 
            x: 'date', 
            y: 'value', 
            fill: accentColor, 
            fillOpacity: 0.15
          }),
          Plot.lineY(plotData, { 
            x: 'date', 
            y: 'value', 
            stroke: accentColor, 
            strokeWidth: 2
          }),
          Plot.dot(plotData, { 
            x: 'date', 
            y: 'value', 
            fill: accentColor,
            r: 2.5
          })
        ]
      });
      
      if (trafficChart) {
        elTraffic.appendChild(trafficChart);
        console.log('Observable Plot: traffic chart appended successfully');
      } else {
        console.error('Observable Plot: traffic chart is null');
      }
    } catch (e) {
      console.error('Error rendering Observable traffic chart:', e);
      console.error('Error stack:', e.stack);
    }
  }
  
  // Connections chart
  const connsData = trends.connsDaily || [];
  const elConns = document.getElementById('chConns');
  if (elConns && connsData.length > 0) {
    try {
      const PlotLib = typeof Plot !== 'undefined' ? Plot : (typeof window !== 'undefined' && window.Plot ? window.Plot : null);
      if (!PlotLib) {
        console.error('Observable Plot: Plot is not defined');
        return;
      }
      
      elConns.innerHTML = '';
      
      const plotData = connsData.map(t => {
        const dateStr = typeof t === 'object' ? (t.date || '') : '';
        const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
        if (!dateStr) return null;
        const d = new Date(dateStr + 'T00:00:00');
        if (isNaN(d.getTime())) return null;
        return {
          date: d,
          value: Number(val) || 0
        };
      }).filter(d => d !== null && d.value !== undefined && !isNaN(d.value));
      
      if (plotData.length === 0) {
        console.warn('renderTrendsChartsObservable: no valid conns data');
        return;
      }
      
      const width = Math.max(elConns.clientWidth || 600, 300);
      const height = Math.max(elConns.clientHeight || 300, 200);
      
      console.log('Observable Plot: rendering conns chart with', plotData.length, 'data points');
      
      const connsChart = Plot.plot({
        style: { 
          background: bgColor, 
          color: textColor
        },
        width: width,
        height: height,
        marginTop: 20,
        marginRight: 20,
        marginBottom: 40,
        marginLeft: 60,
        x: { 
          type: 'time', 
          grid: true
        },
        y: { 
          grid: true, 
          label: 'Connections'
        },
        marks: [
          Plot.ruleY([0], { stroke: gridColor }),
          Plot.areaY(plotData, { 
            x: 'date', 
            y: 'value', 
            fill: okColor, 
            fillOpacity: 0.15
          }),
          Plot.lineY(plotData, { 
            x: 'date', 
            y: 'value', 
            stroke: okColor, 
            strokeWidth: 2
          }),
          Plot.dot(plotData, { 
            x: 'date', 
            y: 'value', 
            fill: okColor,
            r: 2.5
          })
        ]
      });
      
      if (connsChart) {
        elConns.appendChild(connsChart);
        console.log('Observable Plot: conns chart appended successfully');
      } else {
        console.error('Observable Plot: conns chart is null');
      }
    } catch (e) {
      console.error('Error rendering Observable conns chart:', e);
      console.error('Error stack:', e.stack);
    }
  }
}

// Highcharts version - –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–µ–º–∏—É–º —Å—Ç–∏–ª—å
function renderTrendsChartsHighcharts(trends, mode, unit) {
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  
  if (typeof Highcharts === 'undefined') {
    console.warn('Highcharts not available');
    return;
  }
  
  // Destroy existing charts
  const trafficEl = document.getElementById('chTraffic');
  const connsEl = document.getElementById('chConns');
  
  if (window.trafficChartHighcharts) {
    window.trafficChartHighcharts.destroy();
    window.trafficChartHighcharts = null;
  }
  if (window.connsChartHighcharts) {
    window.connsChartHighcharts.destroy();
    window.connsChartHighcharts = null;
  }
  
  // Traffic chart
  const trafficData = trends.trafficDailyBytes || [];
  if (trafficEl && trafficData.length > 0) {
    const data = trafficData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return [d.getTime(), Number((val / base).toFixed(2))];
    });
    
    window.trafficChartHighcharts = Highcharts.chart(trafficEl, {
      chart: {
        type: 'column',
        backgroundColor: bgColor,
        height: trafficEl.clientHeight || 300
      },
      title: { text: null },
      credits: { enabled: false },
      xAxis: {
        type: 'datetime',
        labels: { style: { color: textColor } },
        gridLineColor: gridColor,
        lineColor: gridColor,
        tickColor: gridColor
      },
      yAxis: {
        title: { text: `Traffic (${unitLabel})`, style: { color: textColor } },
        labels: { style: { color: textColor } },
        gridLineColor: gridColor
      },
      legend: { enabled: false },
      tooltip: {
        backgroundColor: bgColor,
        borderColor: textColor,
        style: { color: textColor },
        formatter: function() {
          return `<b>${Highcharts.dateFormat('%d.%m.%Y', this.x)}</b><br/>${this.y.toFixed(2)} ${unitLabel}`;
        }
      },
      plotOptions: {
        column: {
          borderRadius: 4,
          color: accentColor,
          borderWidth: 0
        }
      },
      series: [{
        name: `Traffic (${unitLabel})`,
        data: data
      }]
    });
  }
  
  // Connections chart
  const connsData = trends.connsDaily || [];
  if (connsEl && connsData.length > 0) {
    const data = connsData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return [d.getTime(), Number(val) || 0];
    });
    
    window.connsChartHighcharts = Highcharts.chart(connsEl, {
      chart: {
        type: 'column',
        backgroundColor: bgColor,
        height: connsEl.clientHeight || 300
      },
      title: { text: null },
      credits: { enabled: false },
      xAxis: {
        type: 'datetime',
        labels: { style: { color: textColor } },
        gridLineColor: gridColor,
        lineColor: gridColor,
        tickColor: gridColor
      },
      yAxis: {
        title: { text: 'Connections', style: { color: textColor } },
        labels: { style: { color: textColor } },
        gridLineColor: gridColor
      },
      legend: { enabled: false },
      tooltip: {
        backgroundColor: bgColor,
        borderColor: textColor,
        style: { color: textColor },
        formatter: function() {
          return `<b>${Highcharts.dateFormat('%d.%m.%Y', this.x)}</b><br/>${this.y.toLocaleString('ru-RU')} connections`;
        }
      },
      plotOptions: {
        column: {
          borderRadius: 4,
          color: okColor,
          borderWidth: 0
        }
      },
      series: [{
        name: 'Connections',
        data: data
      }]
    });
  }
}

// Vega-Lite version - —á–∏—Å—Ç—ã–π BI-–º–∏–Ω–∏–º–∞–ª–∏–∑–º
function renderTrendsChartsVegaLite(trends, mode, unit) {
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  
  if (typeof vegaEmbed === 'undefined') {
    console.warn('Vega-Lite not available');
    return;
  }
  
  // Traffic chart
  const trafficData = trends.trafficDailyBytes || [];
  const elTraffic = document.getElementById('chTraffic');
  if (elTraffic && trafficData.length > 0) {
    elTraffic.innerHTML = '';
    const data = trafficData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return {
        date: d.toISOString().split('T')[0],
        value: Number((val / base).toFixed(2))
      };
    });
    
    const spec = {
      $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
      data: { values: data },
      width: elTraffic.clientWidth || 600,
      height: elTraffic.clientHeight || 300,
      background: bgColor,
      config: {
        axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.2)' : 'rgba(208, 215, 222, 0.2)', domainColor: isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)', tickColor: isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)' },
        text: { color: textColor, fontSize: 11 },
        view: { stroke: null }
      },
      layer: [
        {
          mark: { type: 'area', color: accentColor, opacity: 0.3, interpolate: 'monotone' }
        },
        {
          mark: { type: 'line', color: accentColor, strokeWidth: 2.5, interpolate: 'monotone' }
        },
        {
          mark: { type: 'point', color: accentColor, size: 40, opacity: 0.7 }
        }
      ],
      encoding: {
        x: { field: 'date', type: 'temporal', title: null, axis: { format: '%d.%m', labelAngle: -45 } },
        y: { field: 'value', type: 'quantitative', title: `Traffic (${unitLabel})` }
      }
    };
    
    vegaEmbed(elTraffic, spec, { actions: false });
  }
  
  // Connections chart
  const connsData = trends.connsDaily || [];
  const elConns = document.getElementById('chConns');
  if (elConns && connsData.length > 0) {
    elConns.innerHTML = '';
    const data = connsData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return {
        date: d.toISOString().split('T')[0],
        value: Number(val) || 0
      };
    });
    
    const spec = {
      $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
      data: { values: data },
      width: elConns.clientWidth || 600,
      height: elConns.clientHeight || 300,
      background: bgColor,
      config: {
        axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)' },
        text: { color: textColor }
      },
      layer: [
        {
          mark: { type: 'area', color: okColor, opacity: 0.3, interpolate: 'monotone' }
        },
        {
          mark: { type: 'line', color: okColor, strokeWidth: 2.5, interpolate: 'monotone' }
        },
        {
          mark: { type: 'point', color: okColor, size: 40, opacity: 0.7 }
        }
      ],
      encoding: {
        x: { field: 'date', type: 'temporal', title: null, axis: { format: '%d.%m', labelAngle: -45 } },
        y: { field: 'value', type: 'quantitative', title: 'Connections' }
      }
    };
    
    vegaEmbed(elConns, spec, { actions: false });
  }
}

// Recharts version (D3.js-based, —Å—Ç–∏–ª—å Recharts)
function renderTrendsChartsRecharts(trends, mode, unit) {
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  const gridColor = isDark ? '#303639' : '#d0d7de';
  
  if (typeof d3 === 'undefined') {
    console.warn('D3.js not available');
    return;
  }
  
  // Traffic chart
  const trafficData = trends.trafficDailyBytes || [];
  const elTraffic = document.getElementById('chTraffic');
  if (elTraffic && trafficData.length > 0) {
    elTraffic.innerHTML = '';
    const data = trafficData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return {
        date: d,
        dateLabel: d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' }),
        value: Number((val / base).toFixed(2))
      };
    });
    
    const margin = { top: 20, right: 20, bottom: 40, left: 60 };
    const width = elTraffic.clientWidth - margin.left - margin.right;
    const height = (elTraffic.clientHeight || 300) - margin.top - margin.bottom;
    
    const svg = d3.select(elTraffic)
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const x = d3.scaleBand()
      .domain(data.map(d => d.dateLabel))
      .range([0, width])
      .padding(0.2);
    
    const y = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.value) * 1.1])
      .nice()
      .range([height, 0]);
    
    // Grid lines
    g.selectAll('.grid-line')
      .data(y.ticks(5))
      .enter().append('line')
      .attr('class', 'grid-line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', d => y(d))
      .attr('y2', d => y(d))
      .attr('stroke', gridColor)
      .attr('stroke-dasharray', '3,3')
      .attr('opacity', 0.5);
    
    // Bars
    g.selectAll('.bar')
      .data(data)
      .enter().append('rect')
      .attr('class', 'bar')
      .attr('x', d => x(d.dateLabel))
      .attr('width', x.bandwidth())
      .attr('y', d => y(d.value))
      .attr('height', d => height - y(d.value))
      .attr('fill', accentColor)
      .attr('rx', 4);
    
    // X axis
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x))
      .attr('color', textColor);
    
    // Y axis
    g.append('g')
      .call(d3.axisLeft(y))
      .attr('color', textColor);
    
    // Tooltip
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', bgColor)
      .style('color', textColor)
      .style('padding', '8px')
      .style('border-radius', '4px')
      .style('border', `1px solid ${textColor}`)
      .style('pointer-events', 'none');
    
    g.selectAll('.bar')
      .on('mouseover', function(event, d) {
        tooltip.transition().style('opacity', 1);
        tooltip.html(`${d.value.toFixed(2)} ${unitLabel}`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', function() {
        tooltip.transition().style('opacity', 0);
      });
  }
  
  // Connections chart
  const connsData = trends.connsDaily || [];
  const elConns = document.getElementById('chConns');
  if (elConns && connsData.length > 0) {
    elConns.innerHTML = '';
    const data = connsData.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
      return {
        date: d,
        dateLabel: d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' }),
        value: Number(val) || 0
      };
    });
    
    const margin = { top: 20, right: 20, bottom: 40, left: 60 };
    const width = elConns.clientWidth - margin.left - margin.right;
    const height = (elConns.clientHeight || 300) - margin.top - margin.bottom;
    
    const svg = d3.select(elConns)
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const x = d3.scaleBand()
      .domain(data.map(d => d.dateLabel))
      .range([0, width])
      .padding(0.2);
    
    const y = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.value) * 1.1])
      .nice()
      .range([height, 0]);
    
    // Grid lines
    g.selectAll('.grid-line')
      .data(y.ticks(5))
      .enter().append('line')
      .attr('class', 'grid-line')
      .attr('x1', 0)
      .attr('x2', width)
      .attr('y1', d => y(d))
      .attr('y2', d => y(d))
      .attr('stroke', gridColor)
      .attr('stroke-dasharray', '3,3')
      .attr('opacity', 0.5);
    
    // Bars
    g.selectAll('.bar')
      .data(data)
      .enter().append('rect')
      .attr('class', 'bar')
      .attr('x', d => x(d.dateLabel))
      .attr('width', x.bandwidth())
      .attr('y', d => y(d.value))
      .attr('height', d => height - y(d.value))
      .attr('fill', okColor)
      .attr('rx', 4);
    
    // X axis
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x))
      .attr('color', textColor);
    
    // Y axis
    g.append('g')
      .call(d3.axisLeft(y))
      .attr('color', textColor);
    
    // Tooltip
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', bgColor)
      .style('color', textColor)
      .style('padding', '8px')
      .style('border-radius', '4px')
      .style('border', `1px solid ${textColor}`)
      .style('pointer-events', 'none');
    
    g.selectAll('.bar')
      .on('mouseover', function(event, d) {
        tooltip.transition().style('opacity', 1);
        tooltip.html(`${d.value.toLocaleString('ru-RU')} connections`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', function() {
        tooltip.transition().style('opacity', 0);
      });
  }
}

function renderTopDomainsTables(topDomains, unit) {
  if (!topDomains) return;
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Traffic table - –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –¥–æ top-7
  const trafficTbody = $('#tblTopTraffic tbody');
  if (trafficTbody) {
    const trafficRows = (topDomains.traffic || []).slice(0, 7).map(d => `
      <tr>
        <td>${d.domain || '‚Äî'}</td>
        <td>${((d.trafficBytes || 0) / base).toFixed(2)} ${unitLabel}</td>
        <td>${(d.sharePct || 0).toFixed(2)}%</td>
      </tr>
    `).join('') || '<tr><td colspan="3">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>';
    trafficTbody.innerHTML = trafficRows;
  }
  
  // Conns table - –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –¥–æ top-7
  const connsTbody = $('#tblTopConns tbody');
  if (connsTbody) {
    const connsRows = (topDomains.conns || []).slice(0, 7).map(d => `
      <tr>
        <td>${d.domain || '‚Äî'}</td>
        <td>${(d.conns || 0).toLocaleString('ru-RU')}</td>
        <td>${(d.sharePct || 0).toFixed(2)}%</td>
      </tr>
    `).join('') || '<tr><td colspan="3">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>';
    connsTbody.innerHTML = connsRows;
  }
  
  // Apply overview metric filter - show/hide tables based on selected metric (vertical layout)
  const overviewMetric = state.overviewMetric || 'traffic';
  const trafficTableEl = $('#tblTopTraffic');
  const connsTableEl = $('#tblTopConns');
  
  // Find parent div that contains both title and table (domains-single-table)
  const trafficContainer = trafficTableEl ? trafficTableEl.closest('.domains-single-table') : null;
  const connsContainer = connsTableEl ? connsTableEl.closest('.domains-single-table') : null;
  
  if (overviewMetric === 'traffic') {
    // Show traffic table block (with title), hide conns table block
    if (trafficContainer) trafficContainer.style.display = 'block';
    if (connsContainer) connsContainer.style.display = 'none';
  } else {
    // Show conns table block (with title), hide traffic table block
    if (trafficContainer) trafficContainer.style.display = 'none';
    if (connsContainer) connsContainer.style.display = 'block';
  }
}

let usersCmpChart = null;
let usersTrafficChart = null;
let usersConnsChart = null;
let usersDomChart = null;
// ApexCharts instances
let usersTrafficChartApex = null;
let usersConnsChartApex = null;
const userColors = {}; // userId -> color

function getColorForUser(userId) {
  if (!userColors[userId]) {
    const colors = [
      '#8ab4ff', '#26c281', '#ff5d5d', '#d29922', '#a371f7',
      '#58a6ff', '#3fb950', '#f85149', '#d29922', '#bc8cff'
    ];
    const idx = Object.keys(userColors).length % colors.length;
    userColors[userId] = colors[idx];
  }
  return userColors[userId];
}

// Helper function to darken a hex color (for line stroke)
function darkenColor(hex, percent) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.max(0, Math.min(255, (num >> 16) - Math.round(255 * percent / 100)));
  const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) - Math.round(255 * percent / 100)));
  const b = Math.max(0, Math.min(255, (num & 0x0000FF) - Math.round(255 * percent / 100)));
  return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
}

function renderUsersSection(users, userDetails, selectedUsers, mainMetric, miniMetric, mode, unit) {
  // Filter users
  const filteredUsers = selectedUsers.length === 0 || selectedUsers.includes('all') 
    ? users 
    : users.filter(u => selectedUsers.includes(u.userId));
  
  // Render filter chips
  renderUserFilters(users, selectedUsers);
  
  // Note: comparison charts are now rendered separately in renderUsersHistograms
  // and are NOT affected by the user filter - they always show ALL users
  
  // Render user cards
  renderUserCards(filteredUsers, userDetails, mode, unit, miniMetric);
}

function renderUserFilters(users, selectedUsers) {
  const container = $('#userFilters');
  if (!container) return;
  
  const allSelected = selectedUsers.length === 0 || selectedUsers.includes('all');
  const html = `
    <div class="filter-chip ${allSelected ? 'active' : ''}" data-user="all">–í—Å–µ</div>
    ${users.map(u => {
      const isSelected = selectedUsers.includes(u.userId);
      return `<div class="filter-chip ${isSelected ? 'active' : ''}" data-user="${u.userId}">${u.displayName || u.userId}</div>`;
    }).join('')}
  `;
  container.innerHTML = html;
  
  // Add click handlers
  container.querySelectorAll('.filter-chip').forEach(chip => {
    chip.onclick = () => {
      const userId = chip.dataset.user;
      if (userId === 'all') {
        state.selectedUsers = ['all'];
      } else {
        if (state.selectedUsers.includes('all')) {
          state.selectedUsers = [userId];
        } else {
          const idx = state.selectedUsers.indexOf(userId);
          if (idx >= 0) {
            state.selectedUsers.splice(idx, 1);
            if (state.selectedUsers.length === 0) {
              state.selectedUsers = ['all'];
            }
          } else {
            state.selectedUsers.push(userId);
          }
        }
      }
      localStorage.setItem('users.selected', JSON.stringify(state.selectedUsers));
      if (state.dashboard) {
        renderUsersSection(state.dashboard.users, state.dashboard.userDetails, 
                          state.selectedUsers, state.mainMetric, state.miniMetric, state.mode, state.unit);
      }
    };
  });
}

// Chart library wrapper for users comparison chart
function renderUsersComparisonChart(users, metric, unit) {
  if (state.chartLibrary === 'apexcharts' && typeof ApexCharts !== 'undefined') {
    renderUsersComparisonChartApex(users, metric, unit);
  } else if (state.chartLibrary === 'observable') {
    renderUsersComparisonChartObservable(users, metric, unit);
  } else if (state.chartLibrary === 'highcharts' && typeof Highcharts !== 'undefined') {
    renderUsersComparisonChartHighcharts(users, metric, unit);
  } else if (state.chartLibrary === 'vegalite' && typeof vegaEmbed !== 'undefined') {
    renderUsersComparisonChartVegaLite(users, metric, unit);
  } else if (state.chartLibrary === 'recharts' && typeof d3 !== 'undefined') {
    renderUsersComparisonChartRecharts(users, metric, unit);
  } else {
    renderUsersComparisonChartAmCharts(users, metric, unit);
  }
}

// amCharts version (original)
function renderUsersComparisonChartAmCharts(users, metric, unit) {
  const el = document.getElementById('chUsersCmp');
  if (!el) return;
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Prepare data with users
  const userData = users.map(u => {
    const value = metric === 'traffic' 
      ? Number(((u.traffic7dBytes || 0) / base).toFixed(2))
      : Number(u.conns7d || 0);
    return {
      user: u,
      label: u.displayName || u.userId,
      value: value,
      color: getColorForUser(u.userId)
    };
  });
  
  // Sort by value descending (top user first)
  userData.sort((a, b) => b.value - a.value);
  
  const labels = userData.map(d => d.label);
  const data = userData.map(d => d.value);
  const colors = userData.map(d => d.color);
  
  // Destroy existing chart if exists
  if (usersCmpChart) {
    try {
      usersCmpChart.dispose();
    } catch (e) {
      console.warn('Error disposing users comparison chart:', e);
    }
  }
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = document.getElementById('chUsersCmp');
      if (!elCheck || elCheck !== el) {
        console.warn('renderUsersComparisonChart: element changed');
        return;
      }
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0
      }));
      
      // Create axes - vertical bar chart (categories on Y, values on X)
      const yAxis = chart.yAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererY.new(root, {
          cellStartLocation: 0.1,
          cellEndLocation: 0.9,
          minGridDistance: 20,
          inversed: false
        })
      }));
      
      yAxis.data.setAll(labels.map((label, idx) => ({
        category: label
      })));
      
      const xAxis = chart.xAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererX.new(root, {})
      }));
      
      // Create series - horizontal bar chart
      const series = chart.series.push(am5xy.ColumnSeries.new(root, {
        name: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections',
        xAxis: xAxis,
        yAxis: yAxis,
        valueXField: "value",
        categoryYField: "category"
      }));
      
      // Configure columns with user-specific colors (horizontal bars)
      series.columns.template.setAll({
        tooltipText: "{categoryY}: {valueX.formatNumber(metric === 'traffic' ? '#.00' : '#,###')} {unitLabel}",
        tooltipX: 0,
        strokeOpacity: 0,
        cornerRadiusTL: 4,
        cornerRadiusTR: 4,
        cornerRadiusBL: 4,
        cornerRadiusBR: 4
      });
      
      // Dynamic fill color based on user
      series.columns.template.adapters.add("fill", (fill, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx] + 'CC');
          }
        }
        return fill;
      });
      
      series.columns.template.adapters.add("stroke", (stroke, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx]);
          }
        }
        return stroke;
      });
      
      // Labels added via bullets for ColumnSeries (horizontal bars)
      series.bullets.push(function() {
        const label = am5.Label.new(root, {
          text: "",
          fill: amColorVar("--text"),
          centerY: am5.p50,
          centerX: 0,
          fontSize: 10,
          fontWeight: "bold",
          dx: 5
        });
        // Format text using adapter
        label.adapters.add("text", (text, target) => {
          const dataItem = target.dataItem;
          if (dataItem) {
            const value = dataItem.get("valueX");
            if (!value) return "";
            if (metric === 'traffic') {
              return value.toFixed(2);
            } else {
              return value.toLocaleString('ru-RU');
            }
          }
          return "";
        });
        return am5.Bullet.new(root, {
          locationX: 1,
          sprite: label
        });
      });
      
      // Set data
      series.data.setAll(data.map((val, idx) => ({
        category: labels[idx],
        value: val,
        unitLabel: metric === 'traffic' ? unitLabel : 'connections',
        metric: metric
      })));
      
      // Add cursor
      chart.set("cursor", am5xy.XYCursor.new(root, {}));
      
      usersCmpChart = root;
    } catch (e) {
      console.error('Error creating users comparison chart:', e);
      usersCmpChart = null;
    }
  });
}

// Observable Plot version - Data Journalism style
function renderUsersComparisonChartObservable(users, metric, unit) {
  if (typeof Plot === 'undefined' || typeof Plot.plot !== 'function') {
    console.error('Observable Plot: Plot is not available');
    return;
  }
  
  const el = document.getElementById('chUsersCmp');
  if (!el) return;
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  
  try {
    el.innerHTML = '';
    
    const userData = users.map(u => {
      const value = metric === 'traffic' 
        ? Number(((u.traffic7dBytes || 0) / base).toFixed(2))
        : Number(u.conns7d || 0);
      return {
        user: u.displayName || u.userId,
        value: value,
        color: getColorForUser(u.userId)
      };
    }).sort((a, b) => b.value - a.value).filter(d => d.value > 0);
    
    if (userData.length === 0) {
      console.warn('renderUsersComparisonChartObservable: no valid data');
      return;
    }
    
    const width = Math.max(el.clientWidth || 600, 300);
    const height = Math.max(el.clientHeight || 300, 200);
    
    console.log('Observable Plot: rendering users comparison chart with', userData.length, 'users');
    
    const chart = Plot.plot({
      style: { 
        background: bgColor, 
        color: textColor, 
        fontSize: '12px', 
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' 
      },
      width: width,
      height: height,
      marginTop: 20,
      marginRight: 20,
      marginBottom: 40,
      marginLeft: 120,
      y: { 
        label: null, 
        domain: userData.map(d => d.user)
      },
      x: { 
        label: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections', 
        grid: true
      },
      marks: [
        Plot.ruleX([0], { stroke: gridColor, strokeWidth: 1 }),
        Plot.barX(userData, { 
          y: 'user', 
          x: 'value', 
          fill: d => d.color, 
          fillOpacity: 0.85, 
          rx: 3 
        })
      ]
    });
    
    if (chart) {
      el.appendChild(chart);
      console.log('Observable Plot: users comparison chart appended successfully');
    } else {
      console.error('Observable Plot: users comparison chart is null');
    }
  } catch (e) {
    console.error('Error rendering Observable users comparison chart:', e);
  }
}

// Highcharts version
function renderUsersComparisonChartHighcharts(users, metric, unit) {
  const el = document.getElementById('chUsersCmp');
  if (!el || typeof Highcharts === 'undefined') return;
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase, unitLabel = unit === 'gb' ? 'GB' : 'MB';
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff', gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  if (window.usersCmpChartHighcharts) { window.usersCmpChartHighcharts.destroy(); window.usersCmpChartHighcharts = null; }
  const userData = users.map(u => {
    const value = metric === 'traffic' ? Number(((u.traffic7dBytes || 0) / base).toFixed(2)) : Number(u.conns7d || 0);
    return { name: u.displayName || u.userId, y: value, color: getColorForUser(u.userId) };
  }).sort((a, b) => b.y - a.y);
  window.usersCmpChartHighcharts = Highcharts.chart(el, {
    chart: { type: 'bar', backgroundColor: bgColor, height: el.clientHeight || 300 },
    title: { text: null }, credits: { enabled: false },
    xAxis: { categories: userData.map(d => d.name), labels: { style: { color: textColor } }, lineColor: gridColor, tickColor: gridColor },
    yAxis: { title: { text: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections', style: { color: textColor } }, labels: { style: { color: textColor } }, gridLineColor: gridColor },
    legend: { enabled: false },
    tooltip: { backgroundColor: bgColor, borderColor: textColor, style: { color: textColor }, formatter: function() {
      const val = metric === 'traffic' ? `${this.point.y.toFixed(2)} ${unitLabel}` : `${this.point.y.toLocaleString('ru-RU')} connections`;
      return `<b>${this.point.name}</b><br/>${val}`;
    }},
    plotOptions: { bar: { borderRadius: 4, borderWidth: 0, colorByPoint: true, colors: userData.map(d => d.color) } },
    series: [{ name: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections', data: userData }]
  });
}

// Vega-Lite version
function renderUsersComparisonChartVegaLite(users, metric, unit) {
  const el = document.getElementById('chUsersCmp');
  if (!el || typeof vegaEmbed === 'undefined') return;
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase, unitLabel = unit === 'gb' ? 'GB' : 'MB';
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff';
  el.innerHTML = '';
  const userData = users.map(u => {
    const value = metric === 'traffic' ? Number(((u.traffic7dBytes || 0) / base).toFixed(2)) : Number(u.conns7d || 0);
    return { user: u.displayName || u.userId, value: value };
  }).sort((a, b) => b.value - a.value);
  const spec = {
    $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
    data: { values: userData },
    width: el.clientWidth || 600, height: el.clientHeight || 300, background: bgColor,
    config: { axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)' }, text: { color: textColor } },
    mark: { type: 'bar', color: '#58a6ff', cornerRadius: 4 },
    encoding: { y: { field: 'user', type: 'ordinal', title: null, sort: '-x' }, x: { field: 'value', type: 'quantitative', title: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections' } }
  };
  vegaEmbed(el, spec, { actions: false });
}

// Recharts version (D3.js-based)
function renderUsersComparisonChartRecharts(users, metric, unit) {
  const el = document.getElementById('chUsersCmp');
  if (!el || typeof d3 === 'undefined') return;
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase, unitLabel = unit === 'gb' ? 'GB' : 'MB';
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff', gridColor = isDark ? '#303639' : '#d0d7de';
  el.innerHTML = '';
  const userData = users.map(u => {
    const value = metric === 'traffic' ? Number(((u.traffic7dBytes || 0) / base).toFixed(2)) : Number(u.conns7d || 0);
    return { user: u.displayName || u.userId, value: value, color: getColorForUser(u.userId) };
  }).sort((a, b) => b.value - a.value);
  const margin = { top: 20, right: 20, bottom: 40, left: 120 }, width = el.clientWidth - margin.left - margin.right, height = (el.clientHeight || 300) - margin.top - margin.bottom;
  const svg = d3.select(el).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
  const x = d3.scaleLinear().domain([0, d3.max(userData, d => d.value) * 1.1]).nice().range([0, width]);
  const y = d3.scaleBand().domain(userData.map(d => d.user)).range([0, height]).padding(0.2);
  g.selectAll('.grid-line').data(x.ticks(5)).enter().append('line').attr('class', 'grid-line').attr('x1', d => x(d)).attr('x2', d => x(d)).attr('y1', 0).attr('y2', height).attr('stroke', gridColor).attr('stroke-dasharray', '3,3').attr('opacity', 0.5);
  g.selectAll('.bar').data(userData).enter().append('rect').attr('class', 'bar').attr('x', 0).attr('y', d => y(d.user)).attr('width', d => x(d.value)).attr('height', y.bandwidth()).attr('fill', d => d.color).attr('rx', 4);
  g.append('g').attr('transform', `translate(0,${height})`).call(d3.axisBottom(x)).attr('color', textColor);
  g.append('g').call(d3.axisLeft(y)).attr('color', textColor);
  const tooltip = d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0).style('position', 'absolute').style('background', bgColor).style('color', textColor).style('padding', '8px').style('border-radius', '4px').style('border', `1px solid ${textColor}`).style('pointer-events', 'none');
  g.selectAll('.bar').on('mouseover', function(event, d) {
    tooltip.transition().style('opacity', 1);
    const val = metric === 'traffic' ? `${d.value.toFixed(2)} ${unitLabel}` : `${d.value.toLocaleString('ru-RU')} connections`;
    tooltip.html(`${d.user}: ${val}`).style('left', (event.pageX + 10) + 'px').style('top', (event.pageY - 10) + 'px');
  }).on('mouseout', function() { tooltip.transition().style('opacity', 0); });
}

// ApexCharts version
function renderUsersComparisonChartApex(users, metric, unit) {
  const el = document.getElementById('chUsersCmp');
  if (!el || typeof ApexCharts === 'undefined') return;
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase, unitLabel = unit === 'gb' ? 'GB' : 'MB';
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff', gridColor = isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)';
  if (window.usersCmpChartApex) { window.usersCmpChartApex.destroy(); window.usersCmpChartApex = null; }
  el.innerHTML = '';
  const userData = users.map(u => {
    const value = metric === 'traffic' ? Number(((u.traffic7dBytes || 0) / base).toFixed(2)) : Number(u.conns7d || 0);
    return { label: u.displayName || u.userId, value: value, color: getColorForUser(u.userId) };
  }).sort((a, b) => b.value - a.value);
  const labels = userData.map(d => d.label), values = userData.map(d => d.value), colors = userData.map(d => d.color);
  window.usersCmpChartApex = new ApexCharts(el, {
    series: [{ name: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections', data: values }],
    chart: { type: 'bar', height: '100%', toolbar: { show: false }, animations: { enabled: true, easing: 'easeinout', speed: 800 }, horizontal: true },
    plotOptions: { bar: { borderRadius: 6, barHeight: '70%', dataLabels: { position: 'right' }, distributed: true } },
    dataLabels: { enabled: true, formatter: (val) => metric === 'traffic' ? val.toFixed(2) : val.toLocaleString('ru-RU'), style: { fontSize: '11px', colors: [textColor], fontWeight: 'bold' } },
    xaxis: { labels: { style: { colors: textColor } }, title: { text: metric === 'traffic' ? unitLabel : 'Connections', style: { color: textColor } } },
    yaxis: { labels: { style: { colors: textColor } }, categories: labels },
    grid: { borderColor: gridColor, strokeDashArray: 4 },
    tooltip: { theme: isDark ? 'dark' : 'light', y: { formatter: (val) => metric === 'traffic' ? `${val.toFixed(2)} ${unitLabel}` : `${val.toLocaleString('ru-RU')} connections` } },
    colors: colors, fill: { type: 'solid', opacity: 0.8 }
  });
  window.usersCmpChartApex.render();
}

// Render two histograms for users: traffic (top) and connections (bottom)
// These always show ALL users, regardless of filter in Users section
// Chart library wrapper for user histograms
function renderUsersHistograms(users, unit) {
  // Apply overview metric filter - show/hide user histogram containers
  const overviewMetric = state.overviewMetric || 'traffic';
  const elUsersTraffic = $('#chUsersTraffic');
  const elUsersConns = $('#chUsersConns');
  const containerUsersTraffic = elUsersTraffic ? elUsersTraffic.closest('.chartbox') : null;
  const containerUsersConns = elUsersConns ? elUsersConns.closest('.chartbox') : null;
  
  if (overviewMetric === 'traffic') {
    // Show traffic histogram, hide conns histogram (vertical layout)
    if (containerUsersTraffic) containerUsersTraffic.style.display = 'flex';
    if (containerUsersConns) containerUsersConns.style.display = 'none';
  } else {
    // Show conns histogram, hide traffic histogram (vertical layout)
    if (containerUsersTraffic) containerUsersTraffic.style.display = 'none';
    if (containerUsersConns) containerUsersConns.style.display = 'flex';
  }
  
  // Render histograms (both will render, but only one will be visible)
  if (state.chartLibrary === 'apexcharts' && typeof ApexCharts !== 'undefined') {
    renderUsersHistogramsApex(users, unit);
  } else if (state.chartLibrary === 'observable') {
    renderUsersHistogramsObservable(users, unit);
  } else if (state.chartLibrary === 'highcharts' && typeof Highcharts !== 'undefined') {
    renderUsersHistogramsHighcharts(users, unit);
  } else if (state.chartLibrary === 'vegalite' && typeof vegaEmbed !== 'undefined') {
    renderUsersHistogramsVegaLite(users, unit);
  } else if (state.chartLibrary === 'recharts' && typeof d3 !== 'undefined') {
    renderUsersHistogramsRecharts(users, unit);
  } else {
    renderUsersHistogramsAmCharts(users, unit);
  }
}

// amCharts version (original)
function renderUsersHistogramsAmCharts(users, unit) {
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistograms: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Prepare data for traffic histogram
  const trafficData = users.map(u => ({
    user: u,
    label: u.displayName || u.userId,
    value: Number(((u.traffic7dBytes || 0) / base).toFixed(2)),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value); // Sort descending
  
  // Prepare data for connections histogram
  const connsData = users.map(u => ({
    user: u,
    label: u.displayName || u.userId,
    value: Number(u.conns7d || 0),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value); // Sort descending
  
  // Render traffic histogram
  renderUserHistogram('chUsersTraffic', trafficData, unitLabel, 'traffic', unit);
  
  // Render connections histogram
  renderUserHistogram('chUsersConns', connsData, 'connections', 'conns', unit);
}

// ApexCharts version (alternative - –∫—Ä–∞—Å–∏–≤—ã–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –±–∞—Ä—ã)
function renderUsersHistogramsApex(users, unit) {
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistograms: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  // Prepare data for traffic histogram
  const trafficData = users.map(u => ({
    user: u,
    label: u.displayName || u.userId,
    value: Number(((u.traffic7dBytes || 0) / base).toFixed(2)),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value); // Sort descending
  
  // Prepare data for connections histogram
  const connsData = users.map(u => ({
    user: u,
    label: u.displayName || u.userId,
    value: Number(u.conns7d || 0),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value); // Sort descending
  
  // Get theme colors
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)';
  const accentColor = isDark ? '#58a6ff' : '#0969da';
  const okColor = isDark ? '#3fb950' : '#1a7f37';
  
  // Destroy existing ApexCharts
  if (usersTrafficChartApex) {
    usersTrafficChartApex.destroy();
    usersTrafficChartApex = null;
  }
  if (usersConnsChartApex) {
    usersConnsChartApex.destroy();
    usersConnsChartApex = null;
  }
  
  // Traffic histogram - horizontal bar chart
  const elTraffic = document.getElementById('chUsersTraffic');
  if (elTraffic) {
    if (!isElementRenderable(elTraffic)) {
      console.log('renderUsersHistogramsApex: chUsersTraffic not visible, skipping');
      return;
    }
    elTraffic.innerHTML = '';
    
    const labels = trafficData.map(d => d.label);
    const values = trafficData.map(d => d.value);
    const colors = trafficData.map(d => d.color);
    
    usersTrafficChartApex = new ApexCharts(elTraffic, {
      series: [{
        name: `Traffic (${unitLabel})`,
        data: values
      }],
      chart: {
        type: 'bar',
        height: '100%',
        toolbar: { show: false },
        animations: { enabled: true, easing: 'easeinout', speed: 800 },
        horizontal: true
      },
      plotOptions: {
        bar: {
          borderRadius: 6,
          barHeight: '70%',
          dataLabels: { position: 'right' },
          distributed: true
        }
      },
      dataLabels: {
        enabled: true,
        formatter: (val) => val.toFixed(2),
        style: { fontSize: '11px', colors: [textColor], fontWeight: 'bold' }
      },
      xaxis: {
        labels: { style: { colors: textColor } },
        title: { text: unitLabel, style: { color: textColor } }
      },
      yaxis: {
        labels: { style: { colors: textColor } },
        categories: labels
      },
      grid: {
        borderColor: gridColor,
        strokeDashArray: 4
      },
      tooltip: {
        theme: isDark ? 'dark' : 'light',
        y: { formatter: (val) => `${val.toFixed(2)} ${unitLabel}` }
      },
      colors: colors,
      fill: {
        type: 'solid',
        opacity: 0.8
      }
    });
    
    usersTrafficChartApex.render();
  }
  
  // Conns histogram - horizontal bar chart
  const elConns = document.getElementById('chUsersConns');
  if (elConns) {
    if (!isElementRenderable(elConns)) {
      console.log('renderUsersHistogramsApex: chUsersConns not visible, skipping');
      return;
    }
    elConns.innerHTML = '';
    
    const labels = connsData.map(d => d.label);
    const values = connsData.map(d => d.value);
    const colors = connsData.map(d => d.color);
    
    usersConnsChartApex = new ApexCharts(elConns, {
      series: [{
        name: 'Connections',
        data: values
      }],
      chart: {
        type: 'bar',
        height: '100%',
        toolbar: { show: false },
        animations: { enabled: true, easing: 'easeinout', speed: 800 },
        horizontal: true
      },
      plotOptions: {
        bar: {
          borderRadius: 6,
          barHeight: '70%',
          dataLabels: { position: 'right' },
          distributed: true
        }
      },
      dataLabels: {
        enabled: true,
        formatter: (val) => val.toLocaleString('ru-RU'),
        style: { fontSize: '11px', colors: [textColor], fontWeight: 'bold' }
      },
      xaxis: {
        labels: { style: { colors: textColor } },
        title: { text: 'Connections', style: { color: textColor } }
      },
      yaxis: {
        labels: { style: { colors: textColor } },
        categories: labels
      },
      grid: {
        borderColor: gridColor,
        strokeDashArray: 4
      },
      tooltip: {
        theme: isDark ? 'dark' : 'light',
        y: { formatter: (val) => `${val.toLocaleString('ru-RU')} connections` }
      },
      colors: colors,
      fill: {
        type: 'solid',
        opacity: 0.8
      }
    });
    
    usersConnsChartApex.render();
  }
}

// Observable Plot version
// Observable Plot version - Data Journalism / Bloomberg style (–º–∏–Ω–∏–º–∞–ª–∏–∑–º, —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∞)
function renderUsersHistogramsObservable(users, unit) {
  let PlotLib = null;
  if (typeof Plot !== 'undefined') {
    PlotLib = Plot;
  } else if (typeof window !== 'undefined' && window.Plot) {
    PlotLib = window.Plot;
  } else if (typeof globalThis !== 'undefined' && globalThis.Plot) {
    PlotLib = globalThis.Plot;
  }
  
  if (!PlotLib) {
    console.error('Observable Plot: Plot library not found');
    return;
  }
  
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistogramsObservable: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  
  // Traffic histogram
  const trafficData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(((u.traffic7dBytes || 0) / base).toFixed(2)),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value).filter(d => d.value > 0);
  
  const trafficEl = document.getElementById('chUsersTraffic');
  if (trafficEl && trafficData.length > 0) {
    if (!isElementRenderable(trafficEl)) {
      console.log('renderUsersHistogramsObservable: chUsersTraffic not visible, skipping');
      return;
    }
    try {
      trafficEl.innerHTML = '';
      const width = Math.max(trafficEl.clientWidth || 600, 300);
      const height = Math.max(trafficEl.clientHeight || 300, 200);
      
      console.log('Observable Plot: rendering traffic histogram with', trafficData.length, 'users');
      
      const trafficChart = Plot.plot({
        style: { 
          background: bgColor, 
          color: textColor,
          fontSize: '12px',
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        },
        width: width,
        height: height,
        marginTop: 20,
        marginRight: 20,
        marginBottom: 40,
        marginLeft: 120,
        y: { 
          label: null,
          domain: trafficData.map(d => d.user)
        },
        x: { 
          label: `Traffic (${unitLabel})`,
          grid: true
        },
        marks: [
          Plot.ruleX([0], { stroke: gridColor, strokeWidth: 1 }),
          Plot.barX(trafficData, { 
            y: 'user', 
            x: 'value', 
            fill: d => d.color,
            fillOpacity: 0.85,
            rx: 3
          })
        ]
      });
      
      if (trafficChart) {
        trafficEl.appendChild(trafficChart);
        console.log('Observable Plot: traffic histogram appended successfully');
      } else {
        console.error('Observable Plot: traffic histogram is null');
      }
    } catch (e) {
      console.error('Error rendering Observable traffic histogram:', e);
    }
  }
  
  // Connections histogram
  const connsData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(u.conns7d || 0),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value).filter(d => d.value > 0);
  
  const connsEl = document.getElementById('chUsersConns');
  if (connsEl && connsData.length > 0) {
    // Check if element is visible before rendering
    if (!isElementRenderable(connsEl)) {
      console.log('renderUsersHistogramsObservable: chUsersConns not visible, skipping');
      return;
    }
    try {
      connsEl.innerHTML = '';
      const width = Math.max(connsEl.clientWidth || 600, 300);
      const height = Math.max(connsEl.clientHeight || 300, 200);
      
      console.log('Observable Plot: rendering conns histogram with', connsData.length, 'users');
      
      const connsChart = Plot.plot({
        style: { 
          background: bgColor, 
          color: textColor,
          fontSize: '12px',
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
        },
        width: width,
        height: height,
        marginTop: 20,
        marginRight: 20,
        marginBottom: 40,
        marginLeft: 120,
        y: { 
          label: null,
          domain: connsData.map(d => d.user)
        },
        x: { 
          label: 'Connections',
          grid: true
        },
        marks: [
          Plot.ruleX([0], { stroke: gridColor, strokeWidth: 1 }),
          Plot.barX(connsData, { 
            y: 'user', 
            x: 'value', 
            fill: d => d.color,
            fillOpacity: 0.85,
            rx: 3
          })
        ]
      });
      
      if (connsChart) {
        connsEl.appendChild(connsChart);
        console.log('Observable Plot: conns histogram appended successfully');
      } else {
        console.error('Observable Plot: conns histogram is null');
      }
    } catch (e) {
      console.error('Error rendering Observable conns histogram:', e);
    }
  }
}

// Highcharts version - –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–µ–º–∏—É–º —Å—Ç–∏–ª—å
function renderUsersHistogramsHighcharts(users, unit) {
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistogramsHighcharts: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  
  if (typeof Highcharts === 'undefined') {
    console.warn('Highcharts not available');
    return;
  }
  
  // Destroy existing charts
  if (window.usersTrafficChartHighcharts) {
    window.usersTrafficChartHighcharts.destroy();
    window.usersTrafficChartHighcharts = null;
  }
  if (window.usersConnsChartHighcharts) {
    window.usersConnsChartHighcharts.destroy();
    window.usersConnsChartHighcharts = null;
  }
  
  // Traffic histogram
  const trafficData = users.map(u => ({
    name: u.displayName || u.userId,
    y: Number(((u.traffic7dBytes || 0) / base).toFixed(2)),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.y - a.y);
  
  const trafficEl = document.getElementById('chUsersTraffic');
  if (trafficEl && trafficData.length > 0) {
    if (!isElementRenderable(trafficEl)) {
      console.log('renderUsersHistogramsHighcharts: chUsersTraffic not visible, skipping');
      return;
    }
    window.usersTrafficChartHighcharts = Highcharts.chart(trafficEl, {
      chart: {
        type: 'bar',
        backgroundColor: bgColor,
        height: trafficEl.clientHeight || 300
      },
      title: { text: null },
      credits: { enabled: false },
      xAxis: {
        categories: trafficData.map(d => d.name),
        labels: { style: { color: textColor } },
        lineColor: gridColor,
        tickColor: gridColor
      },
      yAxis: {
        title: { text: `Traffic (${unitLabel})`, style: { color: textColor } },
        labels: { style: { color: textColor } },
        gridLineColor: gridColor
      },
      legend: { enabled: false },
      tooltip: {
        backgroundColor: bgColor,
        borderColor: textColor,
        style: { color: textColor },
        formatter: function() {
          return `<b>${this.point.name}</b><br/>${this.point.y.toFixed(2)} ${unitLabel}`;
        }
      },
      plotOptions: {
        bar: {
          borderRadius: 4,
          borderWidth: 0,
          colorByPoint: true,
          colors: trafficData.map(d => d.color)
        }
      },
      series: [{
        name: `Traffic (${unitLabel})`,
        data: trafficData
      }]
    });
  }
  
  // Connections histogram
  const connsData = users.map(u => ({
    name: u.displayName || u.userId,
    y: Number(u.conns7d || 0),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.y - a.y);
  
  const connsEl = document.getElementById('chUsersConns');
  if (connsEl && connsData.length > 0) {
    if (!isElementRenderable(connsEl)) {
      console.log('renderUsersHistogramsHighcharts: chUsersConns not visible, skipping');
      return;
    }
    window.usersConnsChartHighcharts = Highcharts.chart(connsEl, {
      chart: {
        type: 'bar',
        backgroundColor: bgColor,
        height: connsEl.clientHeight || 300
      },
      title: { text: null },
      credits: { enabled: false },
      xAxis: {
        categories: connsData.map(d => d.name),
        labels: { style: { color: textColor } },
        lineColor: gridColor,
        tickColor: gridColor
      },
      yAxis: {
        title: { text: 'Connections', style: { color: textColor } },
        labels: { style: { color: textColor } },
        gridLineColor: gridColor
      },
      legend: { enabled: false },
      tooltip: {
        backgroundColor: bgColor,
        borderColor: textColor,
        style: { color: textColor },
        formatter: function() {
          return `<b>${this.point.name}</b><br/>${this.point.y.toLocaleString('ru-RU')} connections`;
        }
      },
      plotOptions: {
        bar: {
          borderRadius: 4,
          borderWidth: 0,
          colorByPoint: true,
          colors: connsData.map(d => d.color)
        }
      },
      series: [{
        name: 'Connections',
        data: connsData
      }]
    });
  }
}

// Vega-Lite version - —á–∏—Å—Ç—ã–π BI-–º–∏–Ω–∏–º–∞–ª–∏–∑–º
function renderUsersHistogramsVegaLite(users, unit) {
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistogramsVegaLite: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  
  if (typeof vegaEmbed === 'undefined') {
    console.warn('Vega-Lite not available');
    return;
  }
  
  // Traffic histogram
  const trafficData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(((u.traffic7dBytes || 0) / base).toFixed(2))
  })).sort((a, b) => b.value - a.value);
  
  const trafficEl = document.getElementById('chUsersTraffic');
  if (trafficEl && trafficData.length > 0) {
    if (!isElementRenderable(trafficEl)) {
      console.log('renderUsersHistogramsVegaLite: chUsersTraffic not visible, skipping');
      return;
    }
    trafficEl.innerHTML = '';
    const spec = {
      $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
      data: { values: trafficData },
      width: trafficEl.clientWidth || 600,
      height: trafficEl.clientHeight || 300,
      background: bgColor,
      config: {
        axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)' },
        text: { color: textColor }
      },
      mark: { type: 'bar', color: '#58a6ff', cornerRadius: 4 },
      encoding: {
        y: { field: 'user', type: 'ordinal', title: null, sort: '-x' },
        x: { field: 'value', type: 'quantitative', title: `Traffic (${unitLabel})` }
      }
    };
    vegaEmbed(trafficEl, spec, { actions: false });
  }
  
  // Connections histogram
  const connsData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(u.conns7d || 0)
  })).sort((a, b) => b.value - a.value);
  
  const connsEl = document.getElementById('chUsersConns');
  if (connsEl && connsData.length > 0) {
    if (!isElementRenderable(connsEl)) {
      console.log('renderUsersHistogramsVegaLite: chUsersConns not visible, skipping');
      return;
    }
    connsEl.innerHTML = '';
    const spec = {
      $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
      data: { values: connsData },
      width: connsEl.clientWidth || 600,
      height: connsEl.clientHeight || 300,
      background: bgColor,
      config: {
        axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)' },
        text: { color: textColor }
      },
      mark: { type: 'bar', color: '#3fb950', cornerRadius: 4 },
      encoding: {
        y: { field: 'user', type: 'ordinal', title: null, sort: '-x' },
        x: { field: 'value', type: 'quantitative', title: 'Connections' }
      }
    };
    vegaEmbed(connsEl, spec, { actions: false });
  }
}

// Recharts version (D3.js-based, —Å—Ç–∏–ª—å Recharts)
function renderUsersHistogramsRecharts(users, unit) {
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersHistogramsRecharts: no users data');
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? '#303639' : '#d0d7de';
  
  if (typeof d3 === 'undefined') {
    console.warn('D3.js not available');
    return;
  }
  
  // Traffic histogram
  const trafficData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(((u.traffic7dBytes || 0) / base).toFixed(2)),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value);
  
  const trafficEl = document.getElementById('chUsersTraffic');
  if (trafficEl && trafficData.length > 0) {
    if (!isElementRenderable(trafficEl)) {
      console.log('renderUsersHistogramsRecharts: chUsersTraffic not visible, skipping');
      return;
    }
    trafficEl.innerHTML = '';
    const margin = { top: 20, right: 20, bottom: 40, left: 120 };
    const width = trafficEl.clientWidth - margin.left - margin.right;
    const height = (trafficEl.clientHeight || 300) - margin.top - margin.bottom;
    
    const svg = d3.select(trafficEl)
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const x = d3.scaleLinear()
      .domain([0, d3.max(trafficData, d => d.value) * 1.1])
      .nice()
      .range([0, width]);
    
    const y = d3.scaleBand()
      .domain(trafficData.map(d => d.user))
      .range([0, height])
      .padding(0.2);
    
    // Grid lines
    g.selectAll('.grid-line')
      .data(x.ticks(5))
      .enter().append('line')
      .attr('class', 'grid-line')
      .attr('x1', d => x(d))
      .attr('x2', d => x(d))
      .attr('y1', 0)
      .attr('y2', height)
      .attr('stroke', gridColor)
      .attr('stroke-dasharray', '3,3')
      .attr('opacity', 0.5);
    
    // Bars
    g.selectAll('.bar')
      .data(trafficData)
      .enter().append('rect')
      .attr('class', 'bar')
      .attr('x', 0)
      .attr('y', d => y(d.user))
      .attr('width', d => x(d.value))
      .attr('height', y.bandwidth())
      .attr('fill', d => d.color)
      .attr('rx', 4);
    
    // X axis
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x))
      .attr('color', textColor);
    
    // Y axis
    g.append('g')
      .call(d3.axisLeft(y))
      .attr('color', textColor);
    
    // Tooltip
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', bgColor)
      .style('color', textColor)
      .style('padding', '8px')
      .style('border-radius', '4px')
      .style('border', `1px solid ${textColor}`)
      .style('pointer-events', 'none');
    
    g.selectAll('.bar')
      .on('mouseover', function(event, d) {
        tooltip.transition().style('opacity', 1);
        tooltip.html(`${d.user}: ${d.value.toFixed(2)} ${unitLabel}`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', function() {
        tooltip.transition().style('opacity', 0);
      });
  }
  
  // Connections histogram
  const connsData = users.map(u => ({
    user: u.displayName || u.userId,
    value: Number(u.conns7d || 0),
    color: getColorForUser(u.userId)
  })).sort((a, b) => b.value - a.value);
  
  const connsEl = document.getElementById('chUsersConns');
  if (connsEl && connsData.length > 0) {
    if (!isElementRenderable(connsEl)) {
      console.log('renderUsersHistogramsRecharts: chUsersConns not visible, skipping');
      return;
    }
    connsEl.innerHTML = '';
    const margin = { top: 20, right: 20, bottom: 40, left: 120 };
    const width = connsEl.clientWidth - margin.left - margin.right;
    const height = (connsEl.clientHeight || 300) - margin.top - margin.bottom;
    
    const svg = d3.select(connsEl)
      .append('svg')
      .attr('width', width + margin.left + margin.right)
      .attr('height', height + margin.top + margin.bottom);
    
    const g = svg.append('g')
      .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const x = d3.scaleLinear()
      .domain([0, d3.max(connsData, d => d.value) * 1.1])
      .nice()
      .range([0, width]);
    
    const y = d3.scaleBand()
      .domain(connsData.map(d => d.user))
      .range([0, height])
      .padding(0.2);
    
    // Grid lines
    g.selectAll('.grid-line')
      .data(x.ticks(5))
      .enter().append('line')
      .attr('class', 'grid-line')
      .attr('x1', d => x(d))
      .attr('x2', d => x(d))
      .attr('y1', 0)
      .attr('y2', height)
      .attr('stroke', gridColor)
      .attr('stroke-dasharray', '3,3')
      .attr('opacity', 0.5);
    
    // Bars
    g.selectAll('.bar')
      .data(connsData)
      .enter().append('rect')
      .attr('class', 'bar')
      .attr('x', 0)
      .attr('y', d => y(d.user))
      .attr('width', d => x(d.value))
      .attr('height', y.bandwidth())
      .attr('fill', d => d.color)
      .attr('rx', 4);
    
    // X axis
    g.append('g')
      .attr('transform', `translate(0,${height})`)
      .call(d3.axisBottom(x))
      .attr('color', textColor);
    
    // Y axis
    g.append('g')
      .call(d3.axisLeft(y))
      .attr('color', textColor);
    
    // Tooltip
    const tooltip = d3.select('body').append('div')
      .attr('class', 'tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', bgColor)
      .style('color', textColor)
      .style('padding', '8px')
      .style('border-radius', '4px')
      .style('border', `1px solid ${textColor}`)
      .style('pointer-events', 'none');
    
    g.selectAll('.bar')
      .on('mouseover', function(event, d) {
        tooltip.transition().style('opacity', 1);
        tooltip.html(`${d.user}: ${d.value.toLocaleString('ru-RU')} connections`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px');
      })
      .on('mouseout', function() {
        tooltip.transition().style('opacity', 0);
      });
  }
}

// Helper: Check if element is visible and has size
function isElementRenderable(el) {
  if (!el) return false;
  
  // Check computed style - if display is none, element is not renderable
  const style = window.getComputedStyle(el);
  if (style.display === 'none' || style.visibility === 'hidden') {
    return false;
  }
  
  // Check if element is inside a hidden parent
  let parent = el.parentElement;
  while (parent && parent !== document.body) {
    const parentStyle = window.getComputedStyle(parent);
    if (parentStyle.display === 'none' || parentStyle.visibility === 'hidden') {
      return false;
    }
    parent = parent.parentElement;
  }
  
  // Check size
  const rect = el.getBoundingClientRect();
  return rect.width > 0 && rect.height > 0;
}

// Helper: Render when element becomes visible (using ResizeObserver)
function renderWhenVisible(elementId, renderCallback, maxRetries = 0) {
  const el = document.getElementById(elementId);
  if (!el) {
    console.warn(`renderWhenVisible: element ${elementId} not found`);
    return;
  }
  
  // If already visible, render immediately
  if (isElementRenderable(el)) {
    renderCallback();
    return;
  }
  
  // If max retries reached, give up
  if (maxRetries >= 10) {
    console.warn(`renderWhenVisible: element ${elementId} still not visible after ${maxRetries} checks, giving up`);
    return;
  }
  
  // Use ResizeObserver to detect when element becomes visible
  const ro = new ResizeObserver(() => {
    if (isElementRenderable(el)) {
      ro.disconnect();
      renderCallback();
    }
  });
  
  // Also check parent elements
  let current = el;
  while (current && current !== document.body) {
    ro.observe(current);
    current = current.parentElement;
  }
  
  // Fallback: check after a delay (in case ResizeObserver doesn't fire)
  setTimeout(() => {
    if (isElementRenderable(el)) {
      ro.disconnect();
      renderCallback();
    } else {
      ro.disconnect();
      // Retry with incremented counter
      renderWhenVisible(elementId, renderCallback, maxRetries + 1);
    }
  }, 200);
}

function renderUserHistogram(elementId, userData, unitLabel, metric, unit) {
  const el = document.getElementById(elementId);
  if (!el) {
    console.warn(`renderUserHistogram: element ${elementId} not found`);
    return;
  }
  
  // Check if element is renderable - if not, use ResizeObserver
  if (!isElementRenderable(el)) {
    console.log(`renderUserHistogram: element ${elementId} is not visible, waiting for visibility...`);
    renderWhenVisible(elementId, () => {
      renderUserHistogram(elementId, userData, unitLabel, metric, unit);
    });
    return;
  }
  
  const labels = userData.map(d => d.label);
  const values = userData.map(d => d.value);
  const colors = userData.map(d => d.color);
  
  // Destroy existing chart if exists (amCharts)
  if (metric === 'traffic' && usersTrafficChart) {
    try {
      usersTrafficChart.dispose();
      usersTrafficChart = null;
    } catch (e) {
      console.warn('Error disposing users traffic chart:', e);
    }
  }
  if (metric === 'conns' && usersConnsChart) {
    try {
      usersConnsChart.dispose();
      usersConnsChart = null;
    } catch (e) {
      console.warn('Error disposing users conns chart:', e);
    }
  }
  // Destroy ApexCharts if exists
  if (metric === 'traffic' && usersTrafficChartApex) {
    try {
      usersTrafficChartApex.destroy();
      usersTrafficChartApex = null;
    } catch (e) {
      console.warn('Error destroying users traffic ApexChart:', e);
    }
  }
  if (metric === 'conns' && usersConnsChartApex) {
    try {
      usersConnsChartApex.destroy();
      usersConnsChartApex = null;
    } catch (e) {
      console.warn('Error destroying users conns ApexChart:', e);
    }
  }
  
  am5.ready(() => {
    try {
      const elCheck = document.getElementById(elementId);
      if (!elCheck) {
        console.warn(`renderUserHistogram: element ${elementId} not found in am5.ready`);
        return;
      }
      
      // Final check before rendering - if still not visible, skip
      if (!isElementRenderable(elCheck)) {
        console.log(`renderUserHistogram: element ${elementId} still not visible, skipping render`);
        return;
      }
      
      console.log(`renderUserHistogram: creating chart for ${elementId}, size: ${rect.width}x${rect.height}`);
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 20,
        paddingBottom: 0
      }));
      
      // Create axes - horizontal bar chart (categories on Y, values on X)
      const yAxis = chart.yAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererY.new(root, {
          cellStartLocation: 0.1,
          cellEndLocation: 0.9,
          minGridDistance: 20,
          inversed: false
        })
      }));
      
      yAxis.data.setAll(labels.map((label) => ({
        category: label
      })));
      
      const xAxis = chart.xAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererX.new(root, {}),
        min: 0
      }));
      
      // Create series - horizontal bar chart
      const series = chart.series.push(am5xy.ColumnSeries.new(root, {
        name: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections',
        xAxis: xAxis,
        yAxis: yAxis,
        valueXField: "value",
        categoryYField: "category"
      }));
      
      // Configure columns
      const formatPattern = metric === 'traffic' ? '#.00' : '#,###';
      series.columns.template.setAll({
        tooltipText: `{categoryY}: {valueX.formatNumber('${formatPattern}')} ${unitLabel}`,
        tooltipX: 0,
        strokeOpacity: 0,
        cornerRadiusTL: 4,
        cornerRadiusTR: 4,
        cornerRadiusBL: 4,
        cornerRadiusBR: 4
      });
      
      // Dynamic fill color based on user
      series.columns.template.adapters.add("fill", (fill, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx] + 'CC');
          }
        }
        return fill;
      });
      
      series.columns.template.adapters.add("stroke", (stroke, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx]);
          }
        }
        return stroke;
      });
      
      // Labels on bars
      series.bullets.push(function() {
        const label = am5.Label.new(root, {
          text: "",
          fill: amColorVar("--text"),
          centerY: am5.p50,
          centerX: 0,
          fontSize: 10,
          fontWeight: "bold",
          dx: 5
        });
        label.adapters.add("text", (text, target) => {
          const dataItem = target.dataItem;
          if (dataItem) {
            const value = dataItem.get("valueX");
            if (!value) return "";
            if (metric === 'traffic') {
              return value.toFixed(2);
            } else {
              return value.toLocaleString('ru-RU');
            }
          }
          return "";
        });
        return am5.Bullet.new(root, {
          locationX: 1,
          sprite: label
        });
      });
      
      // Set data
      series.data.setAll(values.map((val, idx) => ({
        category: labels[idx],
        value: val
      })));
      
      // Add cursor
      chart.set("cursor", am5xy.XYCursor.new(root, {}));
      
      // Store chart reference
      if (metric === 'traffic') {
        usersTrafficChart = root;
      } else {
        usersConnsChart = root;
      }
      
      console.log(`renderUserHistogram: chart created successfully for ${elementId}`);
    } catch (e) {
      console.error(`Error creating users ${metric} histogram:`, e);
      if (metric === 'traffic') {
        usersTrafficChart = null;
      } else {
        usersConnsChart = null;
      }
    }
  });
}

function renderUsersDomainsChart(users, metric) {
  const el = document.getElementById('chUsersDom');
  if (!el) {
    console.warn('renderUsersDomainsChart: chUsersDom element not found');
    return;
  }
  
  if (!users || !Array.isArray(users) || users.length === 0) {
    console.warn('renderUsersDomainsChart: no users data');
    return;
  }
  
  const labels = users.map(u => u.displayName || u.userId);
  const data = users.map(u => {
    if (metric === 'traffic') {
      return Number((u.traffic7dBytes || 0) / 1000000000); // GB
    } else {
      return Number(u.conns7d || 0);
    }
  });
  const colors = users.map(u => getColorForUser(u.userId));
  
  // Destroy existing chart if exists
  if (usersDomChart) {
    try {
      usersDomChart.dispose();
    } catch (e) {
      console.warn('Error disposing users domains chart:', e);
    }
  }
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = document.getElementById('chUsersDom');
      if (!elCheck || elCheck !== el) {
        console.warn('renderUsersDomainsChart: element changed');
        return;
      }
      
      const maxValue = Math.max(...data, 1);
      const unitLabel = metric === 'traffic' ? 'GB' : 'connections';
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0
      }));
      
      // Create axes
      const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererX.new(root, {
          cellStartLocation: 0.1,
          cellEndLocation: 0.9,
          minGridDistance: 30
        })
      }));
      
      xAxis.data.setAll(labels.map((label, idx) => ({
        category: label
      })));
      
      const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererY.new(root, {})
      }));
      
      // Create series
      const series = chart.series.push(am5xy.ColumnSeries.new(root, {
        name: metric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections',
        xAxis: xAxis,
        yAxis: yAxis,
        valueYField: "value",
        categoryXField: "category"
      }));
      
      // Configure columns with user-specific colors
      series.columns.template.setAll({
        tooltipText: "{categoryX}: {valueY.formatNumber(metric === 'traffic' ? '#.00' : '#,###')} {unitLabel}",
        tooltipY: 0,
        strokeOpacity: 0,
        cornerRadiusTL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBL: 8,
        cornerRadiusBR: 8
      });
      
      // Dynamic fill color based on user
      series.columns.template.adapters.add("fill", (fill, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx] + 'CC');
          }
        }
        return fill;
      });
      
      series.columns.template.adapters.add("stroke", (stroke, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const idx = dataItem.get("index");
          if (idx !== undefined && colors[idx]) {
            return am5.color(colors[idx]);
          }
        }
        return stroke;
      });
      
      // Labels added via bullets for ColumnSeries
      series.bullets.push(function() {
        const label = am5.Label.new(root, {
          text: "",
          fill: amColorVar("--text"),
          centerY: 0,
          centerX: am5.p50,
          fontSize: 10,
          fontWeight: "bold",
          dy: -5
        });
        // Format text using adapter
        label.adapters.add("text", (text, target) => {
          const dataItem = target.dataItem;
          if (dataItem) {
            const value = dataItem.get("valueY");
            if (!value) return "";
            if (metric === 'traffic') {
              return value.toFixed(2);
            } else {
              return value.toLocaleString('ru-RU');
            }
          }
          return "";
        });
        return am5.Bullet.new(root, {
          locationY: 1,
          sprite: label
        });
      });
      
      // Set data
      series.data.setAll(data.map((val, idx) => ({
        category: labels[idx],
        value: val,
        unitLabel: unitLabel,
        metric: metric
      })));
      
      // Add cursor
      chart.set("cursor", am5xy.XYCursor.new(root, {}));
      
      usersDomChart = root;
    } catch (e) {
      console.error('Error creating users domains chart:', e);
      usersDomChart = null;
    }
  });
}

function renderUserCards(users, userDetails, mode, unit, miniMetric) {
  const container = $('#usersGrid');
  if (!container) return;
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = unit === 'gb' ? 'GB' : 'MB';
  
  const html = users.map(u => {
    const details = userDetails[u.userId] || {};
    const statusClass = u.status === 'anomaly' ? 'bad' : 'ok';
    const statusText = u.status === 'anomaly' ? '–ê–Ω–æ–º–∞–ª–∏—è' : 'OK';
    
    // Round to 1 decimal place
    const traffic7d = ((u.traffic7dBytes || 0) / base).toFixed(1);
    const conns7d = (u.conns7d || 0).toLocaleString('ru-RU');
    
    const topTraffic = (details.topDomainsTraffic || []).slice(0, 5);
    const topConns = (details.topDomainsConns || []).slice(0, 5);
    
    return `
      <div class="card">
        <div class="card-hd">
          <div class="user-title-row">
            <h3>${u.displayName || u.userId}</h3>
            <span class="status-dot ${statusClass}" title="${statusText}"></span>
          </div>
          <div class="metrics-row">
            <div class="metric-item">
              <div class="metric-value">${traffic7d} ${unitLabel}</div>
              <div class="metric-label">traffic</div>
            </div>
            <div class="metric-item">
              <div class="metric-value">${conns7d}</div>
              <div class="metric-label">conns</div>
            </div>
          </div>
        </div>
        <div class="card-bd">
          <div style="height:60px;margin-bottom:10px;">
            <div id="userChart_${u.userId}" style="width:100%;height:100%;"></div>
          </div>
          <div class="user-table-traffic" data-user-id="${u.userId}">
            <div class="domains-section">
              <div class="domains-section-title">TOP DOMAINS</div>
              ${topTraffic.length > 0 ? topTraffic.map(d => {
                const domainGb = ((d.trafficBytes || 0) / base).toFixed(1);
                return `
                <div class="domain-item">
                  <span class="domain-pct">${(d.sharePct || 0).toFixed(0)}%</span>
                  <span class="domain-bullet">‚Ä¢</span>
                  <span class="domain-gb">${domainGb} ${unitLabel}</span>
                  <span class="domain-bullet">‚Ä¢</span>
                  <span class="domain-name">${d.domain}</span>
                </div>
              `;
              }).join('') : '<div style="color: var(--muted); font-size: 11px; text-align: center;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>'}
            </div>
          </div>
          <div class="user-table-conns" data-user-id="${u.userId}" style="display:none;">
            <div class="domains-section">
              <div class="domains-section-title">TOP DOMAINS</div>
              ${(topConns && topConns.length > 0) ? topConns.map(d => {
                const domain = d.domain || '‚Äî';
                const pct = typeof d === 'object' ? (d.sharePct || 0) : 0;
                const connsCount = typeof d === 'object' ? (d.conns || 0) : 0;
                return `
                <div class="domain-item">
                  <span class="domain-pct">${pct.toFixed(0)}%</span>
                  <span class="domain-bullet">‚Ä¢</span>
                  <span class="domain-gb">${connsCount.toLocaleString('ru-RU')}</span>
                  <span class="domain-bullet">‚Ä¢</span>
                  <span class="domain-name">${domain}</span>
                </div>
              `;
              }).join('') : '<div style="color: var(--muted); font-size: 11px; text-align: center;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>'}
            </div>
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  container.innerHTML = html;
  
  // Apply overview metric filter - show/hide tables in user cards
  const overviewMetric = state.overviewMetric || 'traffic';
  const allTrafficTables = container.querySelectorAll('.user-table-traffic');
  const allConnsTables = container.querySelectorAll('.user-table-conns');
  
  if (overviewMetric === 'traffic') {
    // Show traffic tables, hide conns tables
    allTrafficTables.forEach(el => { if (el) el.style.display = ''; });
    allConnsTables.forEach(el => { if (el) el.style.display = 'none'; });
  } else {
    // Show conns tables, hide traffic tables
    allTrafficTables.forEach(el => { if (el) el.style.display = 'none'; });
    allConnsTables.forEach(el => { if (el) el.style.display = ''; });
  }
  
  // Render mini charts for each user - use overviewMetric to determine which trend to show
  users.forEach(u => {
    const details = userDetails[u.userId] || {};
    const trend = overviewMetric === 'traffic' 
      ? (details.trafficTrendDailyBytes || [])
      : (details.connsTrendDaily || []);
    renderUserMiniChart(u.userId, trend, mode, unit, overviewMetric);
  });
}

// Chart library wrapper for user mini charts
function renderUserMiniChart(userId, trend, mode, unit, miniMetric) {
  if (state.chartLibrary === 'apexcharts' && typeof ApexCharts !== 'undefined') {
    renderUserMiniChartApex(userId, trend, mode, unit, miniMetric);
  } else if (state.chartLibrary === 'observable') {
    renderUserMiniChartObservable(userId, trend, mode, unit, miniMetric);
  } else if (state.chartLibrary === 'highcharts' && typeof Highcharts !== 'undefined') {
    renderUserMiniChartHighcharts(userId, trend, mode, unit, miniMetric);
  } else if (state.chartLibrary === 'vegalite' && typeof vegaEmbed !== 'undefined') {
    renderUserMiniChartVegaLite(userId, trend, mode, unit, miniMetric);
  } else if (state.chartLibrary === 'recharts' && typeof d3 !== 'undefined') {
    renderUserMiniChartRecharts(userId, trend, mode, unit, miniMetric);
  } else {
    renderUserMiniChartAmCharts(userId, trend, mode, unit, miniMetric);
  }
}

// amCharts version (original)
function renderUserMiniChartAmCharts(userId, trend, mode, unit, miniMetric) {
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) {
    console.warn(`Element userChart_${userId} not found`);
    return;
  }
  
  if (!trend || !Array.isArray(trend) || trend.length === 0) {
    console.warn(`No trend data for user ${userId}`);
    return;
  }
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const unitLabel = miniMetric === 'traffic' ? (unit === 'gb' ? 'GB' : 'MB') : 'connections';
  
  const labels = trend.map(t => {
    try {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      if (!dateStr) return '‚Äî';
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return '‚Äî';
      return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
    } catch (e) {
      console.error('Error parsing mini chart date:', t, e);
      return '‚Äî';
    }
  });
  const data = trend.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    // For traffic, divide by base; for conns, use value as-is
    return miniMetric === 'traffic' ? (Number(val) / base) : Number(val);
  });
  const color = getColorForUser(userId);
  
  // Destroy existing chart if exists (store in a map)
  if (!window.userMiniCharts) {
    window.userMiniCharts = {};
  }
  if (window.userMiniCharts[userId]) {
    try {
      window.userMiniCharts[userId].dispose();
    } catch (e) {
      console.warn(`Error disposing mini chart for user ${userId}:`, e);
    }
  }
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = document.getElementById(`userChart_${userId}`);
      if (!elCheck || elCheck !== el) {
        console.warn(`renderUserMiniChart: element changed for user ${userId}`);
        return;
      }
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0
      }));
      
      // Create axes
      const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererX.new(root, {
          minGridDistance: 20
        })
      }));
      xAxis.get("renderer").labels.template.setAll({
        fontSize: 8,
        fill: amColorVar("--muted")
      });
      
      xAxis.data.setAll(labels.map((label, idx) => ({
        category: label
      })));
      
      const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererY.new(root, {})
      }));
      yAxis.get("renderer").labels.template.setAll({
        fontSize: 8,
        fill: amColorVar("--muted")
      });
      
      // Create series with darker line and lighter fill (same color direction)
      const darkerColor = darkenColor(color, 20); // Darker for line (20% darker)
      
      const seriesName = miniMetric === 'traffic' ? `Traffic (${unitLabel})` : 'Connections';
      const lineSeries = chart.series.push(am5xy.LineSeries.new(root, {
        name: seriesName,
        xAxis: xAxis,
        yAxis: yAxis,
        valueYField: "value",
        categoryXField: "category",
        stroke: am5.color(darkerColor), // Darker line (same color direction, just darker)
        fill: am5.color(color) // Same color for fill, opacity will be set separately
      }));
      
      // Set tooltip format based on metric type
      lineSeries.set("tooltip", am5.Tooltip.new(root, {
        labelText: miniMetric === 'traffic' 
          ? "{categoryX}: {valueY.formatNumber('#.00')} {unitLabel}"
          : "{categoryX}: {valueY.formatNumber('#,###')} {unitLabel}"
      }));
      
      lineSeries.fills.template.setAll({
        fillOpacity: 0.3,
        visible: true
      });
      
      lineSeries.strokes.template.setAll({
        strokeWidth: 2
      });
      
      // Add bullets (points) with darker color
      lineSeries.bullets.push(() => {
        return am5.Bullet.new(root, {
          sprite: am5.Circle.new(root, {
            radius: 2,
            fill: am5.color(darkerColor), // Use darker color for consistency
            stroke: am5.color("#fff"),
            strokeWidth: 1
          })
        });
      });
      
      // Note: LineSeries doesn't have labels.template by default in amCharts 5
      // For mini charts, we skip labels to keep them clean and readable
      
      // Set data
      lineSeries.data.setAll(data.map((val, idx) => ({
        category: labels[idx],
        value: val,
        unitLabel: unitLabel
      })));
      
      // Store chart reference
      window.userMiniCharts[userId] = root;
    } catch (e) {
      console.error(`Error creating mini chart for user ${userId}:`, e);
      if (window.userMiniCharts) {
        window.userMiniCharts[userId] = null;
      }
    }
  });
}

// Observable Plot version - Data Journalism style
function renderUserMiniChartObservable(userId, trend, mode, unit, miniMetric) {
  // Observable Plot –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ UMD –∫–∞–∫ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç Plot
  if (typeof Plot === 'undefined' || typeof Plot.plot !== 'function') {
    console.error('Observable Plot mini-chart: Plot not available');
    console.error('typeof Plot:', typeof Plot);
    if (typeof Plot !== 'undefined') {
      console.error('Plot keys:', Object.keys(Plot).slice(0, 10));
    }
    return;
  }
  
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) return;
  if (!trend || !Array.isArray(trend) || trend.length === 0) return;
  
  const gbBase = 1000000000;
  const mbBase = 1000000;
  const base = unit === 'gb' ? gbBase : mbBase;
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.2)' : 'rgba(208, 215, 222, 0.2)';
  const color = getColorForUser(userId);
  
  try {
    el.innerHTML = '';
    
    const plotData = trend.map(t => {
      const dateStr = typeof t === 'object' ? (t.date || '') : '';
      const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
      if (!dateStr) return null;
      const d = new Date(dateStr + 'T00:00:00');
      if (isNaN(d.getTime())) return null;
      return {
        date: d,
        value: miniMetric === 'traffic' ? (Number(val) / base) : Number(val)
      };
    }).filter(d => d !== null && d.value !== undefined && !isNaN(d.value));
    
    if (plotData.length === 0) {
      console.warn(`renderUserMiniChartObservable: no valid data for user ${userId}`);
      return;
    }
    
    const width = Math.max(el.clientWidth || 300, 200);
    const height = Math.max(el.clientHeight || 70, 50);
    
    console.log('Observable Plot: rendering mini chart for user', userId, 'with', plotData.length, 'data points');
    
    const chart = Plot.plot({
      style: { 
        background: bgColor, 
        color: textColor, 
        fontSize: '10px', 
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif' 
      },
      width: width,
      height: height,
      marginTop: 5,
      marginRight: 5,
      marginBottom: 5,
      marginLeft: 5,
      x: { 
        type: 'time', 
        grid: true, 
        label: null
      },
      y: { 
        grid: true, 
        label: null
      },
      marks: [
        Plot.ruleY([0], { stroke: gridColor, strokeWidth: 0.5 }),
        Plot.areaY(plotData, { 
          x: 'date', 
          y: 'value', 
          fill: color, 
          fillOpacity: 0.2, 
          curve: 'natural' 
        }),
        Plot.lineY(plotData, { 
          x: 'date', 
          y: 'value', 
          stroke: color, 
          strokeWidth: 1.5, 
          curve: 'natural' 
        }),
        Plot.dot(plotData, { 
          x: 'date', 
          y: 'value', 
          fill: color, 
          r: 1.5, 
          stroke: bgColor, 
          strokeWidth: 0.5 
        })
      ]
    });
    
    if (chart) {
      el.appendChild(chart);
      console.log('Observable Plot: mini chart appended successfully for user', userId);
    } else {
      console.error('Observable Plot: mini chart is null for user', userId);
    }
  } catch (e) {
    console.error(`Error rendering Observable mini chart for user ${userId}:`, e);
  }
}

// Highcharts version
function renderUserMiniChartHighcharts(userId, trend, mode, unit, miniMetric) {
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) return;
  if (!trend || !Array.isArray(trend) || trend.length === 0) return;
  if (typeof Highcharts === 'undefined') return;
  
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase;
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff', gridColor = isDark ? 'rgba(48, 54, 61, 0.2)' : 'rgba(208, 215, 222, 0.2)';
  const color = getColorForUser(userId);
  
  if (!window.userMiniCharts) window.userMiniCharts = {};
  if (window.userMiniCharts[userId]) {
    try { window.userMiniCharts[userId].destroy(); } catch (e) {}
  }
  
  const data = trend.map(t => {
    const dateStr = typeof t === 'object' ? (t.date || '') : '';
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
    return [d.getTime(), miniMetric === 'traffic' ? (Number(val) / base) : Number(val)];
  });
  
  window.userMiniCharts[userId] = Highcharts.chart(el, {
    chart: { type: 'area', backgroundColor: bgColor, height: el.clientHeight || 70, spacing: [2, 2, 2, 2] },
    title: { text: null }, credits: { enabled: false },
    xAxis: { type: 'datetime', labels: { enabled: false }, lineWidth: 0, tickLength: 0 },
    yAxis: { title: { text: null }, labels: { enabled: false }, gridLineColor: gridColor, lineWidth: 0 },
    legend: { enabled: false },
    tooltip: { enabled: false },
    plotOptions: { area: { fillColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, color], [1, Highcharts.color(color).setOpacity(0.1).get('rgba')]] }, lineColor: color, marker: { enabled: false }, threshold: null } },
    series: [{ data: data, name: '' }]
  });
}

// Vega-Lite version - —É–ª—É—á—à–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∑–∞–π–Ω
function renderUserMiniChartVegaLite(userId, trend, mode, unit, miniMetric) {
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) return;
  if (!trend || !Array.isArray(trend) || trend.length === 0) return;
  if (typeof vegaEmbed === 'undefined') return;
  
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase;
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff';
  const color = getColorForUser(userId);
  
  el.innerHTML = '';
  
  const data = trend.map(t => {
    const dateStr = typeof t === 'object' ? (t.date || '') : '';
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
    return {
      date: d.toISOString().split('T')[0],
      value: miniMetric === 'traffic' ? (Number(val) / base) : Number(val)
    };
  });
  
  const spec = {
    $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
    data: { values: data },
    width: el.clientWidth || 300,
    height: el.clientHeight || 70,
    background: bgColor,
    config: {
      axis: { domain: false, ticks: false, labels: false, grid: false },
      view: { stroke: null },
      mark: { tooltip: false }
    },
    layer: [
      {
        mark: { type: 'area', color: color, opacity: 0.25, interpolate: 'monotone' }
      },
      {
        mark: { type: 'line', color: color, strokeWidth: 2, interpolate: 'monotone' }
      },
      {
        mark: { type: 'point', color: color, size: 20, opacity: 0.8 }
      }
    ],
    encoding: {
      x: { field: 'date', type: 'temporal', title: null },
      y: { field: 'value', type: 'quantitative', title: null }
    }
  };
  
  vegaEmbed(el, spec, { actions: false });
}

// Recharts version (D3.js-based) - —Å –ø–æ–¥–ø–∏—Å—è–º–∏ –∑–Ω–∞—á–µ–Ω–∏–π, –±–µ–∑ —à–∫–∞–ª—ã
function renderUserMiniChartRecharts(userId, trend, mode, unit, miniMetric) {
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) return;
  if (!trend || !Array.isArray(trend) || trend.length === 0) return;
  if (typeof d3 === 'undefined') return;
  
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase;
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff';
  const color = getColorForUser(userId);
  
  el.innerHTML = '';
  
  const data = trend.map(t => {
    const dateStr = typeof t === 'object' ? (t.date || '') : '';
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    const d = dateStr ? new Date(dateStr + 'T00:00:00') : new Date();
    return {
      date: d,
      dateLabel: d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' }),
      value: miniMetric === 'traffic' ? (Number(val) / base) : Number(val)
    };
  });
  
  const margin = { top: 5, right: 5, bottom: 5, left: 5 };
  const width = el.clientWidth - margin.left - margin.right;
  const height = el.clientHeight - margin.top - margin.bottom;
  
  const svg = d3.select(el).append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom);
  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
  
  const x = d3.scaleTime().domain(d3.extent(data, d => d.date)).range([0, width]);
  const y = d3.scaleLinear().domain([0, d3.max(data, d => d.value) * 1.1]).nice().range([height, 0]);
  
  const area = d3.area().x(d => x(d.date)).y0(height).y1(d => y(d.value)).curve(d3.curveMonotoneX);
  const line = d3.line().x(d => x(d.date)).y(d => y(d.value)).curve(d3.curveMonotoneX);
  
  g.append('path').datum(data).attr('fill', color).attr('fill-opacity', 0.3).attr('d', area);
  g.append('path').datum(data).attr('fill', 'none').attr('stroke', color).attr('stroke-width', 2).attr('d', line);
  
  // Add value labels on points (–ø–æ–¥–ø–∏—Å–∏ –∑–Ω–∞—á–µ–Ω–∏–π)
  g.selectAll('.value-label').data(data).enter().append('text')
    .attr('class', 'value-label')
    .attr('x', d => x(d.date))
    .attr('y', d => y(d.value) - 5)
    .attr('text-anchor', 'middle')
    .attr('font-size', '8px')
    .attr('fill', textColor)
    .attr('font-weight', 'bold')
    .text(d => miniMetric === 'traffic' ? d.value.toFixed(1) : d.value.toLocaleString('ru-RU'));
  
  // Dots
  g.selectAll('.dot').data(data).enter().append('circle')
    .attr('class', 'dot')
    .attr('cx', d => x(d.date))
    .attr('cy', d => y(d.value))
    .attr('r', 2)
    .attr('fill', color)
    .attr('stroke', bgColor)
    .attr('stroke-width', 1);
}

// ApexCharts version
function renderUserMiniChartApex(userId, trend, mode, unit, miniMetric) {
  const el = document.getElementById(`userChart_${userId}`);
  if (!el) return;
  if (!trend || !Array.isArray(trend) || trend.length === 0) return;
  if (typeof ApexCharts === 'undefined') return;
  
  const gbBase = 1000000000, mbBase = 1000000, base = unit === 'gb' ? gbBase : mbBase;
  const isDark = state.theme === 'dark', textColor = isDark ? '#e6edf3' : '#24292f', bgColor = isDark ? '#161b22' : '#ffffff';
  const color = getColorForUser(userId);
  
  if (!window.userMiniCharts) window.userMiniCharts = {};
  if (window.userMiniCharts[userId]) {
    try { window.userMiniCharts[userId].destroy(); } catch (e) {}
  }
  
  el.innerHTML = '';
  
  const labels = trend.map(t => {
    const dateStr = typeof t === 'object' ? (t.date || '') : '';
    if (!dateStr) return '‚Äî';
    const d = new Date(dateStr + 'T00:00:00');
    return isNaN(d.getTime()) ? '‚Äî' : d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' });
  });
  const values = trend.map(t => {
    const val = typeof t === 'object' ? (t.value || 0) : (t || 0);
    return miniMetric === 'traffic' ? (Number(val) / base) : Number(val);
  });
  
  window.userMiniCharts[userId] = new ApexCharts(el, {
    series: [{ name: '', data: values }],
    chart: { type: 'area', height: el.clientHeight || 70, toolbar: { show: false }, zoom: { enabled: false }, sparkline: { enabled: true } },
    stroke: { curve: 'smooth', width: 2, colors: [color] },
    fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: 0.3, opacityTo: 0.1, stops: [0, 100], colorStops: [{ offset: 0, color: color, opacity: 0.3 }, { offset: 100, color: color, opacity: 0.1 }] } },
    xaxis: { labels: { show: false }, axisBorder: { show: false }, axisTicks: { show: false } },
    yaxis: { labels: { show: false } },
    grid: { show: false },
    tooltip: { enabled: false },
    colors: [color]
  });
  
  window.userMiniCharts[userId].render();
}

async function updateDateSelect() {
  try {
    const res = await api('/api/usage/dates');
    const select = $('#dateSelect');
    if (!select) {
      console.warn('dateSelect element not found');
      return;
    }
    
    // Handle both {ok: true, dates: [...]} and {dates: [...]} formats
    const dates = (res.ok && res.dates) ? res.dates : (res.dates || []);
    
    if (dates && dates.length > 0) {
      // Prefer latest date (today if available, otherwise most recent) when no date is set
      // This ensures users always see the most current data by default on first load
      const today = new Date().toISOString().split('T')[0];
      const latestDate = dates.includes(today) ? today : dates[0];
      
      // Use latest date if no date selected
      if (!state.date) {
        state.date = latestDate;
        localStorage.setItem('usage.date', state.date);
      }
      // If saved date is not in available dates, reset to latest
      else if (!dates.includes(state.date)) {
        state.date = latestDate;
        localStorage.setItem('usage.date', state.date);
      }
      
      select.innerHTML = dates.map(d => 
        `<option value="${d}" ${d === state.date ? 'selected' : ''}>${formatDate(d)}</option>`
      ).join('');
    } else {
      select.innerHTML = '<option value="">–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∞—Ç</option>';
    }
  } catch (e) {
    console.error('Failed to load dates:', e);
    const select = $('#dateSelect');
    if (select) {
      select.innerHTML = '<option value="">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</option>';
    }
  }
}

function formatDate(dateStr) {
  const d = new Date(dateStr + 'T00:00:00');
  return d.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long', year: 'numeric' });
}

// ==================== ONLINE ====================
let onlinePollInterval = null;
let onlineLoading = false;

/**
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç polling –¥–ª—è online –¥–∞–Ω–Ω—ã—Ö (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª–∞–¥–∫–∞ online –∞–∫—Ç–∏–≤–Ω–∞)
 */
function startOnlinePolling() {
  // –û—á–∏—Å—Ç–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –µ—Å–ª–∏ –µ—Å—Ç—å
  if (onlinePollInterval) {
    clearInterval(onlinePollInterval);
    onlinePollInterval = null;
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –º—ã –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online
  const paneOnline = document.querySelector('[data-pane="online"]');
  if (!paneOnline || !paneOnline.classList.contains('active')) {
    return; // –ù–µ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online - –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ–º
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –Ω–µ –Ω–∞ –ø–∞—É–∑–µ
  if (state.livePaused) {
    return;
  }
  
  // –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ä–∞–∑—É
  loadOnline();
  
  // –ó–∞–ø—É—Å—Ç–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª
  onlinePollInterval = setInterval(() => {
    // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –º—ã –≤—Å—ë –µ—â—ë –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online
    const paneCheck = document.querySelector('[data-pane="online"]');
    if (!paneCheck || !paneCheck.classList.contains('active') || state.livePaused) {
      stopOnlinePolling();
      return;
    }
    loadOnline();
  }, 5000);
}

/**
 * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç polling –¥–ª—è online –¥–∞–Ω–Ω—ã—Ö
 */
function stopOnlinePolling() {
  if (onlinePollInterval) {
    clearInterval(onlinePollInterval);
    onlinePollInterval = null;
  }
}

async function loadOnline() {
  if (state.livePaused) return;
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –º—ã –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online
  const paneOnline = document.querySelector('[data-pane="online"]');
  if (!paneOnline || !paneOnline.classList.contains('active')) {
    return; // –ù–µ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online - –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º
  }
  
  // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
  if (onlineLoading) {
    return;
  }
  
  onlineLoading = true;
  
  try {
    // Load "now"
    const nowRes = await api('/api/live/now');
    if (nowRes.ok) {
      renderOnlineNow(nowRes.now, nowRes.meta);
    }
    
    // Load series for both charts
    const [connsRes, trafficRes] = await Promise.all([
      api(`/api/live/series?metric=conns&period=${state.livePeriod}&gran=${state.liveGran}&scope=${state.liveScope}`),
      api(`/api/live/series?metric=traffic&period=${state.livePeriod}&gran=${state.liveGran}&scope=${state.liveScope}`)
    ]);
    
    if (connsRes.ok && connsRes.series) {
      renderOnlineChart('conns', connsRes.series, connsRes.meta);
    }
    if (trafficRes.ok && trafficRes.series) {
      renderOnlineChart('traffic', trafficRes.series, trafficRes.meta);
    }
    
    // Load top users for today with online status
    const today = new Date().toISOString().split('T')[0];
    const topRes = await api(`/api/usage/dashboard?date=${today}&mode=daily&windowDays=1`);
    if (topRes.ok) {
      // Get online users from now data
      const onlineUsersList = nowRes?.now?.onlineUsers || [];
      renderOnlineTop(topRes, onlineUsersList);
    }
  } catch (e) {
    console.error('Online load error:', e);
  } finally {
    onlineLoading = false;
  }
}

function renderOnlineNow(now, meta) {
  if (!now || !meta) return;
  const el1 = $('#onlineUsersValue');
  const el2 = $('#onlineConnsValue');
  const el3 = $('#onlineTrafficValue');
  const el4 = $('#onlineTrafficNote');
  const el5 = $('#onlineSource');
  // Use onlineUsersCount if available, otherwise onlineUsers (for backward compatibility)
  const onlineCount = now.onlineUsersCount !== undefined ? now.onlineUsersCount : (Array.isArray(now.onlineUsers) ? now.onlineUsers.length : (now.onlineUsers || 0));
  if (el1) el1.textContent = onlineCount.toLocaleString('ru-RU');
  if (el2) el2.textContent = (now.conns || 0).toLocaleString('ru-RU');
  if (el3) {
    if (now.trafficAvailable) {
      el3.textContent = fmtBytes(now.trafficBytes || 0);
      if (el4) el4.style.display = 'none';
    } else {
      el3.textContent = '‚Äî';
      if (el4) el4.style.display = 'block';
    }
  }
  if (el5) el5.textContent = meta.source || '‚Äî';
}

let onlineConnsChart = null;
let onlineTrafficChart = null;
let onlineChartInitializing = { conns: false, traffic: false };
// ApexCharts instances
let onlineConnsChartApex = null;
let onlineTrafficChartApex = null;

// Chart library wrapper for online charts
function renderOnlineChart(metric, series, meta) {
  if (state.chartLibrary === 'apexcharts' && typeof ApexCharts !== 'undefined') {
    renderOnlineChartApex(metric, series, meta);
  } else if (state.chartLibrary === 'observable') {
    renderOnlineChartObservable(metric, series, meta);
  } else if (state.chartLibrary === 'highcharts' && typeof Highcharts !== 'undefined') {
    renderOnlineChartHighcharts(metric, series, meta);
  } else if (state.chartLibrary === 'vegalite' && typeof vegaEmbed !== 'undefined') {
    renderOnlineChartVegaLite(metric, series, meta);
  } else if (state.chartLibrary === 'recharts' && typeof d3 !== 'undefined') {
    renderOnlineChartRecharts(metric, series, meta);
  } else {
    renderOnlineChartAmCharts(metric, series, meta);
  }
}

// amCharts version (original)
function renderOnlineChartAmCharts(metric, series, meta) {
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const chartVar = metric === 'traffic' ? 'onlineTrafficChart' : 'onlineConnsChart';
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏ –∑–∞—â–∏—Ç–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
  const el = document.getElementById(chartId);
  if (!el) {
    return; // –¢–∏—Ö–∏–π –≤—ã—Ö–æ–¥, –±–µ–∑ warn
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –≥–æ—Ç–æ–≤ –¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞
  if (!isRenderable(el)) {
    return; // –¢–∏—Ö–∏–π –≤—ã—Ö–æ–¥, –±–µ–∑ warn
  }
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartAmCharts(${metric}): no data`);
    return;
  }
  
  // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–π
  if (onlineChartInitializing[metric]) {
    console.warn(`renderOnlineChartAmCharts(${metric}): already initializing, skipping`);
    return;
  }
  
  // Destroy ApexCharts if exists
  const apexChartVar = metric === 'traffic' ? 'onlineTrafficChartApex' : 'onlineConnsChartApex';
  if (window[apexChartVar]) {
    try {
      window[apexChartVar].destroy();
      window[apexChartVar] = null;
    } catch (e) {
      console.warn(`Error destroying ${metric} ApexChart:`, e);
    }
  }
  
  const labels = series.map(s => {
    const d = new Date(s.ts);
    return d.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
  });
  const data = series.map(s => s.value || 0);
  
  const unit = meta.unit === 'bytes' ? 'bytes' : 'count';
  const label = metric === 'traffic' ? 'Traffic' : 'Connections';
  const color = metric === 'traffic' ? '#58a6ff' : '#4caf50';
  
  // Destroy existing chart if exists (–ø–µ—Ä–µ–¥ am5.ready)
  if (window[chartVar]) {
    try {
      window[chartVar].dispose();
      window[chartVar] = null;
    } catch (e) {
      console.warn(`Error disposing ${metric} chart:`, e);
      window[chartVar] = null;
    }
  }
  
  onlineChartInitializing[metric] = true;
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞ (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ –æ–Ω –±—ã–ª —É–¥–∞–ª—ë–Ω)
      const elCheck = document.getElementById(chartId);
      if (!elCheck || elCheck !== el) {
        console.warn(`renderOnlineChart(${metric}): element changed or removed`);
        onlineChartInitializing[metric] = false;
        return;
      }
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0
      }));
      
      // Create axes
      const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererX.new(root, {
          minGridDistance: 30
        })
      }));
      
      xAxis.data.setAll(labels.map((label, idx) => ({
        category: label
      })));
      
      const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererY.new(root, {})
      }));
      
      // Create series
      // Convert hex color to rgba
      const hexToRgba = (hex, alpha) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };
      
      const lineSeries = chart.series.push(am5xy.LineSeries.new(root, {
        name: label,
        xAxis: xAxis,
        yAxis: yAxis,
        valueYField: "value",
        categoryXField: "category",
        stroke: am5.color(color),
        fill: am5.color(hexToRgba(color, 0.3))
      }));
      
      lineSeries.fills.template.setAll({
        fillOpacity: 0.3,
        visible: true
      });
      
      lineSeries.strokes.template.setAll({
        strokeWidth: 3
      });
      
      lineSeries.bullets.push(() => {
        return am5.Bullet.new(root, {
          sprite: am5.Circle.new(root, {
            radius: 4,
            fill: am5.color(color),
            stroke: am5.color("#fff"),
            strokeWidth: 2
          })
        });
      });
      
      // Set data
      lineSeries.data.setAll(data.map((val, idx) => ({
        category: labels[idx],
        value: val,
        unit: unit,
        label: label
      })));
      
      // Add cursor
      chart.set("cursor", am5xy.XYCursor.new(root, {}));
      
      window[chartVar] = root;
      onlineChartInitializing[metric] = false;
    } catch (e) {
      console.error(`Error creating ${metric} chart:`, e);
      window[chartVar] = null;
      onlineChartInitializing[metric] = false;
    }
  });
}

// ApexCharts version for online charts (alternative - –∫—Ä–∞—Å–∏–≤—ã–µ –ª–∏–Ω–µ–π–Ω—ã–µ –≥—Ä–∞—Ñ–∏–∫–∏)
function renderOnlineChartApex(metric, series, meta) {
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const chartVar = metric === 'traffic' ? 'onlineTrafficChartApex' : 'onlineConnsChartApex';
  
  const el = document.getElementById(chartId);
  if (!el) return;
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartApex(${metric}): no data`);
    return;
  }
  
  // Destroy existing ApexCharts
  if (window[chartVar]) {
    try {
      window[chartVar].destroy();
    } catch (e) {
      console.warn(`Error destroying ${metric} ApexChart:`, e);
    }
    window[chartVar] = null;
  }
  
  const labels = series.map(s => {
    const d = new Date(s.ts);
    return d.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
  });
  const data = series.map(s => s.value || 0);
  
  const unit = meta.unit === 'bytes' ? 'bytes' : 'count';
  const label = metric === 'traffic' ? 'Traffic' : 'Connections';
  const color = metric === 'traffic' ? '#58a6ff' : '#3fb950';
  
  // Get theme colors
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.5)' : 'rgba(208, 215, 222, 0.5)';
  
  el.innerHTML = ''; // Clear for ApexCharts
  
  const chartConfig = {
    series: [{
      name: label,
      data: data
    }],
    chart: {
      type: 'line',
      height: '100%',
      toolbar: { show: false },
      animations: { enabled: true, easing: 'easeinout', speed: 800 },
      zoom: { enabled: false }
    },
    stroke: {
      curve: 'smooth',
      width: 3,
      colors: [color]
    },
    fill: {
      type: 'gradient',
      gradient: {
        shade: isDark ? 'dark' : 'light',
        type: 'vertical',
        shadeIntensity: 0.5,
        gradientToColors: [color],
        inverseColors: false,
        opacityFrom: 0.3,
        opacityTo: 0.05,
        stops: [0, 100]
      }
    },
    markers: {
      size: 4,
      colors: [color],
      strokeColors: '#fff',
      strokeWidth: 2,
      hover: { size: 6 }
    },
    xaxis: {
      categories: labels,
      labels: { style: { colors: textColor, fontSize: '11px' } },
      axisBorder: { color: gridColor },
      axisTicks: { color: gridColor }
    },
    yaxis: {
      labels: { style: { colors: textColor } },
      title: { text: label, style: { color: textColor } }
    },
    grid: {
      borderColor: gridColor,
      strokeDashArray: 4
    },
    tooltip: {
      theme: isDark ? 'dark' : 'light',
      y: {
        formatter: (val) => {
          if (metric === 'traffic') {
            return `${(val / 1000000000).toFixed(2)} GB`;
          } else {
            return `${val.toLocaleString('ru-RU')} connections`;
          }
        }
      }
    },
    colors: [color]
  };
  
  window[chartVar] = new ApexCharts(el, chartConfig);
  window[chartVar].render();
}

// Observable Plot version
// Observable Plot version - Data Journalism / Bloomberg style (–º–∏–Ω–∏–º–∞–ª–∏–∑–º, —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∞)
function renderOnlineChartObservable(metric, series, meta) {
  if (typeof Plot === 'undefined' || typeof Plot.plot !== 'function') {
    console.error('Observable Plot: Plot is not available');
    return;
  }
  
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const el = document.getElementById(chartId);
  if (!el) return;
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartObservable(${metric}): no data`);
    return;
  }
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  const color = metric === 'traffic' ? '#58a6ff' : '#3fb950';
  
  try {
    el.innerHTML = '';
    
    const plotData = series.map(s => {
      const ts = s.ts;
      if (!ts) return null;
      const d = new Date(ts);
      if (isNaN(d.getTime())) return null;
      return {
        time: d,
        value: metric === 'traffic' ? (s.value || 0) / 1000000000 : (s.value || 0)
      };
    }).filter(d => d !== null && d.value !== undefined && !isNaN(d.value));
    
    if (plotData.length === 0) {
      console.warn(`renderOnlineChartObservable(${metric}): no valid data after filtering`);
      return;
    }
    
    const width = Math.max(el.clientWidth || 600, 300);
    const height = Math.max(el.clientHeight || 300, 200);
    
    console.log('Observable Plot: rendering online chart with', plotData.length, 'data points');
    
    const chart = Plot.plot({
      style: { 
        background: bgColor, 
        color: textColor,
        fontSize: '12px',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
      },
      width: width,
      height: height,
      marginTop: 20,
      marginRight: 20,
      marginBottom: 40,
      marginLeft: 60,
      x: { 
        type: 'time', 
        grid: true, 
        label: null
      },
      y: { 
        grid: true, 
        label: metric === 'traffic' ? 'Traffic (GB)' : 'Connections'
      },
      marks: [
        Plot.ruleY([0], { stroke: gridColor, strokeWidth: 1 }),
        Plot.areaY(plotData, { 
          x: 'time', 
          y: 'value', 
          fill: color, 
          fillOpacity: 0.15,
          curve: 'natural'
        }),
        Plot.lineY(plotData, { 
          x: 'time', 
          y: 'value', 
          stroke: color, 
          strokeWidth: 2,
          curve: 'natural'
        }),
        Plot.dot(plotData, { 
          x: 'time', 
          y: 'value', 
          fill: color,
          r: 2.5,
          stroke: bgColor,
          strokeWidth: 1
        })
      ]
    });
    
    if (chart) {
      el.appendChild(chart);
      console.log('Observable Plot: online chart appended successfully');
    } else {
      console.error('Observable Plot: online chart is null');
    }
  } catch (e) {
    console.error(`Error rendering Observable online chart (${metric}):`, e);
  }
}

// Highcharts version - –∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–µ–º–∏—É–º —Å—Ç–∏–ª—å
function renderOnlineChartHighcharts(metric, series, meta) {
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const chartVar = metric === 'traffic' ? 'onlineTrafficChartHighcharts' : 'onlineConnsChartHighcharts';
  const el = document.getElementById(chartId);
  if (!el) return;
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartHighcharts(${metric}): no data`);
    return;
  }
  
  if (typeof Highcharts === 'undefined') {
    console.warn('Highcharts not available');
    return;
  }
  
  // Destroy existing chart
  if (window[chartVar]) {
    window[chartVar].destroy();
    window[chartVar] = null;
  }
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)';
  const color = metric === 'traffic' ? '#58a6ff' : '#3fb950';
  
  const data = series.map(s => [new Date(s.ts).getTime(), s.value || 0]);
  
  window[chartVar] = Highcharts.chart(el, {
    chart: {
      type: 'area',
      backgroundColor: bgColor,
      height: el.clientHeight || 300
    },
    title: { text: null },
    credits: { enabled: false },
    xAxis: {
      type: 'datetime',
      labels: { style: { color: textColor } },
      gridLineColor: gridColor,
      lineColor: gridColor,
      tickColor: gridColor
    },
    yAxis: {
      title: { text: metric === 'traffic' ? 'Traffic (GB)' : 'Connections', style: { color: textColor } },
      labels: { style: { color: textColor } },
      gridLineColor: gridColor
    },
    legend: { enabled: false },
    tooltip: {
      backgroundColor: bgColor,
      borderColor: textColor,
      style: { color: textColor },
      formatter: function() {
        const val = metric === 'traffic' 
          ? `${(this.y / 1000000000).toFixed(2)} GB`
          : `${this.y.toLocaleString('ru-RU')} connections`;
        return `<b>${Highcharts.dateFormat('%H:%M', this.x)}</b><br/>${val}`;
      }
    },
    plotOptions: {
      area: {
        fillColor: {
          linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
          stops: [
            [0, color],
            [1, Highcharts.color(color).setOpacity(0.1).get('rgba')]
          ]
        },
        lineColor: color,
        marker: { radius: 3, fillColor: color }
      }
    },
    series: [{
      name: metric === 'traffic' ? 'Traffic' : 'Connections',
      data: data
    }]
  });
}

// Vega-Lite version - —á–∏—Å—Ç—ã–π BI-–º–∏–Ω–∏–º–∞–ª–∏–∑–º
function renderOnlineChartVegaLite(metric, series, meta) {
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const el = document.getElementById(chartId);
  if (!el) return;
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartVegaLite(${metric}): no data`);
    return;
  }
  
  if (typeof vegaEmbed === 'undefined') {
    console.warn('Vega-Lite not available');
    return;
  }
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const color = metric === 'traffic' ? '#58a6ff' : '#3fb950';
  
  el.innerHTML = '';
  
  const data = series.map(s => ({
    time: new Date(s.ts).toISOString(),
    value: metric === 'traffic' ? (s.value || 0) / 1000000000 : (s.value || 0)
  }));
  
  const spec = {
    $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
    data: { values: data },
    width: el.clientWidth || 600,
    height: el.clientHeight || 300,
    background: bgColor,
    config: {
      axis: { labelColor: textColor, titleColor: textColor, gridColor: isDark ? 'rgba(48, 54, 61, 0.3)' : 'rgba(208, 215, 222, 0.3)' },
      text: { color: textColor }
    },
    layer: [
      {
        mark: { type: 'area', color: color, opacity: 0.3 }
      },
      {
        mark: { type: 'line', color: color, strokeWidth: 2 }
      }
    ],
    encoding: {
      x: { field: 'time', type: 'temporal', title: null },
      y: { field: 'value', type: 'quantitative', title: metric === 'traffic' ? 'Traffic (GB)' : 'Connections' }
    }
  };
  
  vegaEmbed(el, spec, { actions: false });
}

// Recharts version (D3.js-based, —Å—Ç–∏–ª—å Recharts)
function renderOnlineChartRecharts(metric, series, meta) {
  const chartId = metric === 'traffic' ? 'chOnlineTraffic' : 'chOnlineConns';
  const el = document.getElementById(chartId);
  if (!el) return;
  
  if (!series || !Array.isArray(series) || series.length === 0) {
    console.warn(`renderOnlineChartRecharts(${metric}): no data`);
    return;
  }
  
  if (typeof d3 === 'undefined') {
    console.warn('D3.js not available');
    return;
  }
  
  const isDark = state.theme === 'dark';
  const textColor = isDark ? '#e6edf3' : '#24292f';
  const bgColor = isDark ? '#161b22' : '#ffffff';
  const gridColor = isDark ? '#303639' : '#d0d7de';
  const color = metric === 'traffic' ? '#58a6ff' : '#3fb950';
  
  el.innerHTML = '';
  
  const data = series.map(s => ({
    time: new Date(s.ts),
    timeLabel: new Date(s.ts).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }),
    value: s.value || 0
  }));
  
  const margin = { top: 20, right: 20, bottom: 40, left: 60 };
  const width = el.clientWidth - margin.left - margin.right;
  const height = (el.clientHeight || 300) - margin.top - margin.bottom;
  
  const svg = d3.select(el)
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom);
  
  const g = svg.append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);
  
  const x = d3.scaleTime()
    .domain(d3.extent(data, d => d.time))
    .range([0, width]);
  
  const y = d3.scaleLinear()
    .domain([0, d3.max(data, d => d.value) * 1.1])
    .nice()
    .range([height, 0]);
  
  // Area
  const area = d3.area()
    .x(d => x(d.time))
    .y0(height)
    .y1(d => y(d.value))
    .curve(d3.curveMonotoneX);
  
  // Line
  const line = d3.line()
    .x(d => x(d.time))
    .y(d => y(d.value))
    .curve(d3.curveMonotoneX);
  
  // Grid lines
  g.selectAll('.grid-line')
    .data(y.ticks(5))
    .enter().append('line')
    .attr('class', 'grid-line')
    .attr('x1', 0)
    .attr('x2', width)
    .attr('y1', d => y(d))
    .attr('y2', d => y(d))
    .attr('stroke', gridColor)
    .attr('stroke-dasharray', '3,3')
    .attr('opacity', 0.5);
  
  // Area
  g.append('path')
    .datum(data)
    .attr('fill', color)
    .attr('fill-opacity', 0.3)
    .attr('d', area);
  
  // Line
  g.append('path')
    .datum(data)
    .attr('fill', 'none')
    .attr('stroke', color)
    .attr('stroke-width', 2)
    .attr('d', line);
  
  // X axis
  g.append('g')
    .attr('transform', `translate(0,${height})`)
    .call(d3.axisBottom(x).tickFormat(d3.timeFormat('%H:%M')))
    .attr('color', textColor);
  
  // Y axis
  g.append('g')
    .call(d3.axisLeft(y))
    .attr('color', textColor);
  
  // Tooltip
  const tooltip = d3.select('body').append('div')
    .attr('class', 'tooltip')
    .style('opacity', 0)
    .style('position', 'absolute')
    .style('background', bgColor)
    .style('color', textColor)
    .style('padding', '8px')
    .style('border-radius', '4px')
    .style('border', `1px solid ${textColor}`)
    .style('pointer-events', 'none');
  
  // Dots
  g.selectAll('.dot')
    .data(data)
    .enter().append('circle')
    .attr('class', 'dot')
    .attr('cx', d => x(d.time))
    .attr('cy', d => y(d.value))
    .attr('r', 3)
    .attr('fill', color)
    .on('mouseover', function(event, d) {
      tooltip.transition().style('opacity', 1);
      const val = metric === 'traffic' 
        ? `${(d.value / 1000000000).toFixed(2)} GB`
        : `${d.value.toLocaleString('ru-RU')} connections`;
      tooltip.html(`${d.timeLabel}: ${val}`)
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 10) + 'px');
    })
    .on('mouseout', function() {
      tooltip.transition().style('opacity', 0);
    });
}

function renderOnlineTop(dashboardData, onlineUsers) {
  if (!dashboardData || !dashboardData.users) {
    $('#tblOnlineTop tbody').innerHTML = '<tr><td colspan="4">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>';
    return;
  }
  
  const users = dashboardData.users || [];
  const onlineUsersSet = new Set(onlineUsers || []);
  const userDetails = dashboardData.userDetails || {};
  
  // Build user list with today's data
  // users is an array of objects with userId, displayName, traffic7dBytes, conns7d, etc.
  // For today's data, we need to get from userDetails which has daily data
  const userList = users.map(userData => {
    const userId = userData.userId;
    const details = userDetails[userId] || {};
    
    // Get today's data from trends (last day in the array)
    const trafficTrend = details.trafficDailyBytes || [];
    const connsTrend = details.connsDaily || [];
    const userTodayTraffic = trafficTrend.length > 0 ? trafficTrend[trafficTrend.length - 1] : 0;
    const userTodayConns = connsTrend.length > 0 ? connsTrend[connsTrend.length - 1] : 0;
    
    const isOnline = onlineUsersSet.has(userId);
    
    return {
      userId: userId,
      displayName: userData.displayName || userId,
      traffic: userTodayTraffic,
      conns: userTodayConns,
      isOnline
    };
  }).filter(u => u.traffic > 0 || u.conns > 0 || u.isOnline) // Show only users with activity or online
    .sort((a, b) => {
      // Sort: online first, then by traffic
      if (a.isOnline && !b.isOnline) return -1;
      if (!a.isOnline && b.isOnline) return 1;
      return (b.traffic || 0) - (a.traffic || 0);
    });
  
  const html = userList.length > 0 ? userList.map(r => `
    <tr>
      <td>${r.displayName || r.userId}</td>
      <td>${r.isOnline ? '<span style="color: var(--ok);">üü¢ –û–Ω–ª–∞–π–Ω</span>' : '<span style="color: var(--muted);">‚ö™ –û—Ñ–ª–∞–π–Ω</span>'}</td>
      <td>${fmtBytes(r.traffic || 0)}</td>
      <td>${(r.conns || 0).toLocaleString('ru-RU')}</td>
    </tr>
  `).join('') : '<tr><td colspan="4">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>';
  
  $('#tblOnlineTop tbody').innerHTML = html;
}

// ==================== SERVICES MANAGEMENT ====================
async function loadServices() {
  await loadServicesStatus();
  // Load logs automatically (sequentially)
  await loadServiceJournal('ui');
  await loadServiceJournal('xray');
}

async function loadServicesStatus() {
  try {
    const statusData = await api('/api/system/status');
    if (statusData.ok) {
      // API returns ui and xray directly, not inside services
      const ui = statusData.ui || {};
      const xray = statusData.xray || {};
      const restartHistory = statusData.restart_history || [];
      
      // Also update header badges to keep them in sync
      updateHeaderStatusBadges({ ui, xray });
      
      // Filter restart history by service
      const uiRestarts = restartHistory.filter(e => {
        const action = (e.action || '').toLowerCase();
        const service = (e.service || '').toLowerCase();
        return action.includes('ui') || action.includes('restart_ui') || service.includes('ui') || service.includes('xray-report-ui');
      });
      const xrayRestarts = restartHistory.filter(e => {
        const action = (e.action || '').toLowerCase();
        const service = (e.service || '').toLowerCase();
        return action.includes('xray') || action.includes('restart_xray') || service.includes('xray');
      });
      
      // UI Service
      const uiActive = Boolean(ui.active); // Force boolean conversion
      const serviceUIStatusText = $('#serviceUIStatusText');
      const serviceUIDot = $('#serviceUIDot');
      const serviceUIUptime = $('#serviceUIUptime');
      const serviceUIRestarts = $('#serviceUIRestarts');
      const serviceUIRestartHistory = $('#serviceUIRestartHistory');
      
      if (serviceUIStatusText) {
        serviceUIStatusText.textContent = uiActive ? '—Ä–∞–±–æ—Ç–∞–µ—Ç' : '–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω';
        serviceUIStatusText.style.color = uiActive ? 'var(--ok)' : 'var(--bad)';
      }
      if (serviceUIDot) {
        serviceUIDot.style.background = uiActive ? 'var(--ok)' : 'var(--bad)';
      }
      if (serviceUIUptime) {
        serviceUIUptime.textContent = ui.uptime || '‚Äî';
      }
      if (serviceUIRestarts) {
        // Use restart_count_14d from API if available, otherwise count from history
        const restartCount14d = ui.restart_count_14d !== undefined ? ui.restart_count_14d : (() => {
          const now = new Date();
          const days14Ago = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
          return uiRestarts.filter(e => {
            if (!e.ts) return false;
            const eventDate = new Date(e.ts);
            return eventDate >= days14Ago;
          }).length;
        })();
        serviceUIRestarts.textContent = restartCount14d;
      }
      if (serviceUIRestartHistory) {
        if (uiRestarts.length > 0) {
          serviceUIRestartHistory.innerHTML = `
            <table style="width: 100%; font-size: 12px;">
              <thead>
                <tr style="border-bottom: 1px solid var(--line);">
                  <th style="text-align: left; padding: 6px; color: var(--muted); font-size: 11px;">–í—Ä–µ–º—è</th>
                  <th style="text-align: left; padding: 6px; color: var(--muted); font-size: 11px;">–†–µ–∑—É–ª—å—Ç–∞—Ç</th>
                </tr>
              </thead>
              <tbody>
                ${uiRestarts.slice(0, 10).map(e => {
                  const ts = e.ts || '';
                  const result = e.result || '—É—Å–ø–µ—à–Ω–æ';
                  const date = new Date(ts);
                  const formattedDate = date.toLocaleString('ru-RU', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                  });
                  return `
                    <tr style="border-bottom: 1px solid var(--line);">
                      <td style="padding: 6px; color: var(--muted); font-size: 11px;">${escapeHtml(formattedDate)}</td>
                      <td style="padding: 6px; color: var(--ok); font-size: 11px;">${escapeHtml(result)}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          `;
        } else {
          serviceUIRestartHistory.innerHTML = '<span style="color: var(--muted); font-size: 11px;">–ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤</span>';
        }
      }
      
      // Xray Service
      const xrayActive = Boolean(xray.active); // Force boolean conversion
      const serviceXrayStatusText = $('#serviceXrayStatusText');
      const serviceXrayDot = $('#serviceXrayDot');
      const serviceXrayUptime = $('#serviceXrayUptime');
      const serviceXrayRestarts = $('#serviceXrayRestarts');
      const serviceXrayName = $('#serviceXrayName');
      const serviceXrayRestartHistory = $('#serviceXrayRestartHistory');
      
      if (serviceXrayStatusText) {
        serviceXrayStatusText.textContent = xrayActive ? '—Ä–∞–±–æ—Ç–∞–µ—Ç' : '–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω';
        serviceXrayStatusText.style.color = xrayActive ? 'var(--ok)' : 'var(--bad)';
      }
      if (serviceXrayDot) {
        serviceXrayDot.style.background = xrayActive ? 'var(--ok)' : 'var(--bad)';
      }
      if (serviceXrayUptime) {
        serviceXrayUptime.textContent = xray.uptime || '‚Äî';
      }
      if (serviceXrayRestarts) {
        // Use restart_count_14d from API if available, otherwise count from history
        const restartCount14d = xray.restart_count_14d !== undefined ? xray.restart_count_14d : (() => {
          const now = new Date();
          const days14Ago = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
          return xrayRestarts.filter(e => {
            if (!e.ts) return false;
            const eventDate = new Date(e.ts);
            return eventDate >= days14Ago;
          }).length;
        })();
        serviceXrayRestarts.textContent = restartCount14d;
      }
      if (serviceXrayName && xray.name) {
        serviceXrayName.textContent = xray.name;
      }
      if (serviceXrayRestartHistory) {
        if (xrayRestarts.length > 0) {
          serviceXrayRestartHistory.innerHTML = `
            <table style="width: 100%; font-size: 12px;">
              <thead>
                <tr style="border-bottom: 1px solid var(--line);">
                  <th style="text-align: left; padding: 6px; color: var(--muted); font-size: 11px;">–í—Ä–µ–º—è</th>
                  <th style="text-align: left; padding: 6px; color: var(--muted); font-size: 11px;">–†–µ–∑—É–ª—å—Ç–∞—Ç</th>
                </tr>
              </thead>
              <tbody>
                ${xrayRestarts.slice(0, 10).map(e => {
                  const ts = e.ts || '';
                  const result = e.result || '—É—Å–ø–µ—à–Ω–æ';
                  const date = new Date(ts);
                  const formattedDate = date.toLocaleString('ru-RU', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                  });
                  return `
                    <tr style="border-bottom: 1px solid var(--line);">
                      <td style="padding: 6px; color: var(--muted); font-size: 11px;">${escapeHtml(formattedDate)}</td>
                      <td style="padding: 6px; color: var(--ok); font-size: 11px;">${escapeHtml(result)}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          `;
        } else {
          serviceXrayRestartHistory.innerHTML = '<span style="color: var(--muted); font-size: 11px;">–ù–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤</span>';
        }
      }
      
      // Setup restart buttons
      setupRestartButtons();
    } else {
      // If API failed, show error in history
      const serviceUIRestartHistory = $('#serviceUIRestartHistory');
      const serviceXrayRestartHistory = $('#serviceXrayRestartHistory');
      if (serviceUIRestartHistory) {
        serviceUIRestartHistory.innerHTML = '<span style="color: var(--bad); font-size: 11px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</span>';
      }
      if (serviceXrayRestartHistory) {
        serviceXrayRestartHistory.innerHTML = '<span style="color: var(--bad); font-size: 11px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</span>';
      }
    }
  } catch (e) {
    console.error('Failed to load services status:', e);
    const serviceUIRestartHistory = $('#serviceUIRestartHistory');
    const serviceXrayRestartHistory = $('#serviceXrayRestartHistory');
    if (serviceUIRestartHistory) {
      serviceUIRestartHistory.innerHTML = '<span style="color: var(--bad); font-size: 11px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</span>';
    }
    if (serviceXrayRestartHistory) {
      serviceXrayRestartHistory.innerHTML = '<span style="color: var(--bad); font-size: 11px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</span>';
    }
  }
}

function setupRestartButtons() {
  // UI restart
  const btnRestartUI = $('#btnRestartUI');
  if (btnRestartUI) {
    btnRestartUI.onclick = async () => {
      const confirmed = await modal(
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ UI',
        '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å UI —Å–µ—Ä–≤–∏—Å?<br><br>–í–µ–±-–ø–∞–Ω–µ–ª—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—Å—è, –∏ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.',
        '',
        '–û—Ç–º–µ–Ω–∞',
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å'
      );
      if (!confirmed) return;
      
      btnRestartUI.disabled = true;
      btnRestartUI.textContent = '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...';
      
      try {
        const res = await api('/api/system/restart?target=ui', { method: 'POST' });
        if (res.ok) {
          showToast('‚úÖ', 'UI –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω. –°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—Å—è —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã...');
          setTimeout(() => {
            window.location.reload();
          }, 2000);
        } else {
          showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞');
          btnRestartUI.disabled = false;
          btnRestartUI.textContent = 'üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å';
        }
      } catch (e) {
        showToast('‚ùå', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: ' + (e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
        btnRestartUI.disabled = false;
        btnRestartUI.textContent = 'üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å';
      }
    };
  }
  
  // Xray restart
  const btnRestartXray = $('#btnRestartXray');
  if (btnRestartXray) {
    btnRestartXray.onclick = async () => {
      const confirmed = await modal(
        '‚ö†Ô∏è –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ Xray',
        '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray —Å–µ—Ä–≤–∏—Å?<br><br><strong style="color: var(--warn);">–í—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ VPN –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –±—É–¥—É—Ç —Ä–∞–∑–æ—Ä–≤–∞–Ω—ã.</strong><br>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.',
        '',
        '–û—Ç–º–µ–Ω–∞',
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å',
        true
      );
      if (!confirmed) return;
      
      btnRestartXray.disabled = true;
      btnRestartXray.textContent = '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...';
      
      try {
        const res = await api('/api/system/restart?target=xray', { method: 'POST' });
        if (res.ok) {
          showToast('‚úÖ', 'Xray –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω');
          setTimeout(() => {
            loadServices();
          }, 2000);
        } else {
          showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞');
          btnRestartXray.disabled = false;
          btnRestartXray.textContent = '‚ö° –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å';
        }
      } catch (e) {
        showToast('‚ùå', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: ' + (e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
        btnRestartXray.disabled = false;
        btnRestartXray.textContent = '‚ö° –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å';
      }
    };
  }
}

function toggleServiceLogs(service) {
  const logsEl = $(`#service${service === 'ui' ? 'UI' : 'Xray'}Logs`);
  if (logsEl) {
    const isVisible = logsEl.style.display !== 'none';
    logsEl.style.display = isVisible ? 'none' : 'block';
    if (!isVisible) {
      loadServiceJournal(service);
    }
  }
}

async function loadServiceJournal(service) {
  const contentEl = $(`#service${service === 'ui' ? 'UI' : 'Xray'}JournalContent`);
  const timezoneEl = $(`#service${service === 'ui' ? 'UI' : 'Xray'}Timezone`);
  if (!contentEl) return;
  
  contentEl.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞...';
  if (timezoneEl) {
    timezoneEl.textContent = '(–∑–∞–≥—Ä—É–∑–∫–∞...)';
  }
  
  try {
    const res = await api(`/api/system/journal?target=${service}&limit=100`);
    if (res.ok) {
      contentEl.textContent = res.journal || '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
      if (timezoneEl && res.timezone) {
        timezoneEl.textContent = `(${res.timezone})`;
      }
    } else {
      contentEl.textContent = `–û—à–∏–±–∫–∞: ${res.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–æ–≥–∏'}`;
      if (timezoneEl) {
        timezoneEl.textContent = '';
      }
    }
  } catch (e) {
    console.error('Journal load error:', e);
    contentEl.textContent = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`;
    if (timezoneEl) {
      timezoneEl.textContent = '';
    }
  }
}

function toggleServiceLogs(service) {
  // Function kept for compatibility but logs are now always visible
  loadServiceJournal(service);
}

// ==================== STATUS ====================
async function loadStatus() {
  try {
    const res = await api('/api/system/status');
    if (res.ok) {
      const s = res.services || {};
      const html = `
        <div class="card">
          <h4>UI Service</h4>
          <p>Name: ${s.ui?.name || '‚Äî'}</p>
          <p>Active: ${s.ui?.active ? '‚úÖ' : '‚ùå'}</p>
          <p>State: ${s.ui?.state || '‚Äî'}</p>
        </div>
        <div class="card">
          <h4>Xray Service</h4>
          <p>Name: ${s.xray?.name || '‚Äî'}</p>
          <p>Active: ${s.xray?.active ? '‚úÖ' : '‚ùå'}</p>
          <p>State: ${s.xray?.state || '‚Äî'}</p>
        </div>
      `;
      $('#statusContent').innerHTML = html;
    }
  } catch (e) {
    console.error('Status load error:', e);
  }
}

// ==================== RESTART ====================
async function loadRestart() {
  // Load current service status
  try {
    const statusData = await api('/api/system/status');
    if (statusData.ok) {
      const services = statusData.services || {};
      
      // UI status
      const uiActive = services.ui?.active || false;
      const restartUIStatusText = $('#restartUIStatusText');
      const restartUIDot = $('#restartUIDot');
      if (restartUIStatusText) {
        restartUIStatusText.textContent = uiActive ? '—Ä–∞–±–æ—Ç–∞–µ—Ç' : '–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω';
      }
      if (restartUIDot) {
        restartUIDot.className = 'dot ' + (uiActive ? 'ok' : 'bad');
        restartUIDot.style.background = uiActive ? 'var(--ok)' : 'var(--bad)';
      }
      
      // Xray status
      const xrayActive = xray.active || false;
      const restartXrayStatusText = $('#restartXrayStatusText');
      const restartXrayDot = $('#restartXrayDot');
      if (restartXrayStatusText) {
        restartXrayStatusText.textContent = xrayActive ? '—Ä–∞–±–æ—Ç–∞–µ—Ç' : '–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω';
      }
      if (restartXrayDot) {
        restartXrayDot.className = 'dot ' + (xrayActive ? 'ok' : 'bad');
        restartXrayDot.style.background = xrayActive ? 'var(--ok)' : 'var(--bad)';
      }
      
      // Xray service name
      const restartXrayServiceName = $('#restartXrayServiceName');
      if (restartXrayServiceName && xray.name) {
        restartXrayServiceName.textContent = xray.name;
      }
    }
  } catch (e) {
    console.error('Failed to load service status:', e);
  }
  
  // UI restart handler
  const btnRestartUI = $('#btnRestartUI');
  if (btnRestartUI) {
    btnRestartUI.onclick = async () => {
      const confirmed = await modal(
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ UI',
        '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å UI —Å–µ—Ä–≤–∏—Å?<br><br>–í–µ–±-–ø–∞–Ω–µ–ª—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—Å—è, –∏ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.',
        '',
        '–û—Ç–º–µ–Ω–∞',
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å'
      );
      if (!confirmed) return;
      
      btnRestartUI.disabled = true;
      btnRestartUI.textContent = '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...';
      
      try {
        const res = await api('/api/system/restart?target=ui', { method: 'POST' });
        if (res.ok) {
          showToast('‚úÖ', 'UI –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω. –°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—Å—è —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã...');
          setTimeout(() => {
            window.location.reload();
          }, 2000);
        } else {
          showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞');
          btnRestartUI.disabled = false;
          btnRestartUI.textContent = 'üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å UI';
        }
      } catch (e) {
        showToast('‚ùå', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: ' + (e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
        btnRestartUI.disabled = false;
        btnRestartUI.textContent = 'üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å UI';
      }
    };
  }
  
  // Xray restart handler (from restart pane)
  const btnRestartXrayPane = $('#btnRestartXrayPane');
  if (btnRestartXrayPane) {
    btnRestartXrayPane.onclick = async () => {
      const confirmed = await modal(
        '‚ö†Ô∏è –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ Xray',
        '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray —Å–µ—Ä–≤–∏—Å?<br><br><strong style="color: var(--warn);">–í—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ VPN –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –±—É–¥—É—Ç —Ä–∞–∑–æ—Ä–≤–∞–Ω—ã.</strong><br>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è.',
        '',
        '–û—Ç–º–µ–Ω–∞',
        '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å',
        true // danger button
      );
      if (!confirmed) return;
      
      btnRestartXrayPane.disabled = true;
      btnRestartXrayPane.textContent = '–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...';
      
      try {
        const res = await api('/api/system/restart?target=xray', { method: 'POST' });
        if (res.ok) {
          showToast('‚úÖ', 'Xray –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω');
          // Refresh status after 2 seconds
          setTimeout(() => {
            loadRestart();
          }, 2000);
        } else {
          showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞');
          btnRestartXrayPane.disabled = false;
          btnRestartXrayPane.textContent = '‚ö° –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray';
        }
      } catch (e) {
        showToast('‚ùå', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: ' + (e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
        btnRestartXrayPane.disabled = false;
        btnRestartXrayPane.textContent = '‚ö° –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray';
      }
    };
  }
}

// ==================== JOURNAL ====================
let currentJournalTarget = 'xray'; // Default target

async function loadJournal(target) {
  // If target is provided, update current target
  if (target) {
    currentJournalTarget = target;
  } else {
    // If no target provided, use current
    target = currentJournalTarget;
  }
  
  const journalContent = $('#journalContent');
  const journalServiceName = $('#journalServiceName');
  const btnJournalUI = $('#btnJournalUI');
  const btnJournalXray = $('#btnJournalXray');
  
  // Update button states
  if (btnJournalUI && btnJournalXray) {
    if (target === 'ui') {
      btnJournalUI.classList.add('active');
      btnJournalXray.classList.remove('active');
    } else {
      btnJournalUI.classList.remove('active');
      btnJournalXray.classList.add('active');
    }
  }
  
  if (journalContent) {
    journalContent.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞...';
  }
  
  try {
    const res = await api(`/api/system/journal?target=${target}&limit=200`);
    if (res.ok) {
      if (journalContent) {
        journalContent.textContent = res.journal || '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
      }
      if (journalServiceName) {
        journalServiceName.textContent = res.service || target;
      }
    } else {
      if (journalContent) {
        journalContent.textContent = `–û—à–∏–±–∫–∞: ${res.error || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–æ–≥–∏'}`;
      }
    }
  } catch (e) {
    console.error('Journal load error:', e);
    if (journalContent) {
      journalContent.textContent = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`;
    }
  }
}

// ==================== OLD DASHBOARD (legacy) ====================
async function loadDashboard() {
  // Legacy function, redirect to management
  setNav('management');
}

function renderDashboard(data) {
  const kpi = data.kpi || {};
  const global = data.global || {};
  const usersObj = data.users || {};
  const meta = data.meta || {};
  
  // Convert users object to array, sorted by sum7_traffic_bytes
  const usersArray = Object.values(usersObj).sort((a, b) => 
    (b.sum7_traffic_bytes || 0) - (a.sum7_traffic_bytes || 0)
  );
  
  // Top users for today (from last day of daily_traffic_bytes)
  const todayTraffic = global.daily_traffic_bytes || [];
  const todayIdx = todayTraffic.length - 1;
  const todayUsers = usersArray
    .map(u => ({
      email: u.email,
      bytes: (u.daily_traffic_bytes || [])[todayIdx] || 0
    }))
    .sort((a, b) => b.bytes - a.bytes)
    .slice(0, 5);
  
  // KPI Cards with icons and top users
  const changeColor = kpi.change_pct >= 0 ? 'var(--ok)' : 'var(--bad)';
  const changePct = kpi.change_pct !== null ? `${kpi.change_pct >= 0 ? '+' : ''}${kpi.change_pct.toFixed(1)}%` : '‚Äî';
  
  const topUsersHtml = todayUsers.length > 0 ? `
    <div style="margin-top:12px;font-size:12px;">
      <div style="color:var(--muted);margin-bottom:6px;">Top-5 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</div>
      ${todayUsers.map((u, idx) => `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
          <span style="color:var(--text);font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:60%;">${u.email}</span>
          <span style="color:var(--text);font-weight:600;white-space:nowrap;">${fmtBytes(u.bytes || 0)}</span>
        </div>
      `).join('')}
    </div>
  ` : '';
  
  // Top domains for KPI
  const topDomainsTraffic = (global.top_domains_traffic || []).slice(0, 3);
  const topDomainsConns = (global.top_domains_conns || []).slice(0, 3);
  
  $('#kpiGrid').innerHTML = `
    <div class="kpi-card" style="border-left: 4px solid var(--accent);">
      <div class="kpi-label">üìä ${t('todayTraffic')}</div>
      <div class="kpi-value" style="color:var(--accent);">${fmtBytes(kpi.today_bytes)}</div>
      <div class="kpi-change ${kpi.change_pct >= 0 ? 'up' : 'down'}" style="color:${changeColor};">
        ${changePct}
        <span style="font-size:11px;color:var(--muted);margin-left:8px;">vs –≤—á–µ—Ä–∞</span>
      </div>
      ${topUsersHtml}
    </div>
    <div class="kpi-card" style="border-left: 4px solid var(--muted);">
      <div class="kpi-label">üìÖ ${t('yesterdayTraffic')}</div>
      <div class="kpi-value">${fmtBytes(kpi.yesterday_bytes)}</div>
    </div>
    <div class="kpi-card" style="border-left: 4px solid var(--ok);">
      <div class="kpi-label">üíæ ${t('totalTraffic')}</div>
      <div class="kpi-value" style="color:var(--ok);">${fmtBytes(kpi.total_bytes)}</div>
      <div style="font-size:11px;color:var(--muted);margin-top:4px;">–∑–∞ –ø–µ—Ä–∏–æ–¥</div>
    </div>
    <div class="kpi-card" style="border-left: 4px solid var(--warn);">
      <div class="kpi-label">üë• ${t('activeUsers')}</div>
      <div class="kpi-value" style="color:var(--warn);">${kpi.active_users || 0} <span style="font-size:16px;color:var(--muted);">/ ${kpi.total_users || 0}</span></div>
    </div>
    <div class="kpi-card" style="border-left: 4px solid ${data.collector?.lag_days > 1 ? 'var(--bad)' : 'var(--ok)'};">
      <div class="kpi-label">‚è±Ô∏è ${t('collectorLag')}</div>
      <div class="kpi-value ${data.collector?.lag_days > 1 ? 'text-warn' : 'text-ok'}">${data.collector?.lag_days ?? '‚Äî'} <span style="font-size:14px;">–¥–Ω.</span></div>
    </div>
    ${topDomainsTraffic.length > 0 ? `
    <div class="kpi-card" style="border-left: 4px solid var(--accent);">
      <div class="kpi-label">üåê –¢–æ–ø –¥–æ–º–µ–Ω—ã (7–¥) - —Ç—Ä–∞—Ñ–∏–∫</div>
      <div style="margin-top:8px;font-size:12px;">
        ${topDomainsTraffic.map((d, idx) => `
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span style="color:var(--text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:60%;">${idx + 1}. ${d.domain}</span>
            <span style="color:var(--text);font-weight:600;white-space:nowrap;">${fmtBytes(d.value)}</span>
          </div>
        `).join('')}
      </div>
    </div>
    ` : ''}
    ${topDomainsConns.length > 0 ? `
    <div class="kpi-card" style="border-left: 4px solid var(--warn);">
      <div class="kpi-label">üåê –¢–æ–ø –¥–æ–º–µ–Ω—ã (7–¥) - –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</div>
      <div style="margin-top:8px;font-size:12px;">
        ${topDomainsConns.map((d, idx) => `
          <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
            <span style="color:var(--text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:60%;">${idx + 1}. ${d.domain}</span>
            <span style="color:var(--text);font-weight:600;white-space:nowrap;">${d.value.toLocaleString()}</span>
          </div>
        `).join('')}
      </div>
    </div>
    ` : ''}
  `;
  
  // Chart - use global.daily_traffic_bytes with meta.days as labels
  const days = meta.days || [];
  const dailyData = global.daily_traffic_bytes || [];
  const chartData = days.map((d, i) => ({
    date: d,
    bytes: dailyData[i] || 0
  }));
  renderChart(chartData);
  
  // Top Users Table with progress bars
  const totalBytes = usersArray.reduce((sum, u) => sum + (u.sum7_traffic_bytes || 0), 0);
  const tbody = $('#topUsersTable tbody');
  tbody.innerHTML = usersArray.slice(0, 20).map((u, idx) => {
    const pct = totalBytes > 0 ? ((u.sum7_traffic_bytes || 0) / totalBytes * 100) : 0;
    return `
      <tr>
        <td style="text-align:center;color:var(--muted);">${idx + 1}</td>
        <td><strong class="mono">${u.email}</strong></td>
        <td><strong>${fmtBytes(u.sum7_traffic_bytes || 0)}</strong></td>
        <td>
          <div class="progress-bar">
            <div class="progress-fill" style="width:${pct}%;">${pct.toFixed(1)}%</div>
          </div>
        </td>
        <td style="text-align:center;">${(u.daily_traffic_bytes || []).filter(x => x > 0).length}</td>
      </tr>
    `;
  }).join('') || '<tr><td colspan="5" class="muted" style="text-align:center;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>';
  
  // Store for other functions
  state.dashboard = data;
}

let chartInstance = null;

function renderChart(perDay) {
  const el = $('#trafficChart');
  if (!el) return;
  
  if (chartInstance) {
    try {
      chartInstance.dispose();
    } catch (e) {
      console.warn('Error disposing legacy chart:', e);
    }
    chartInstance = null;
  }
  
  if (!perDay || !perDay.length) {
    el.parentElement.innerHTML = '<div style="text-align:center;padding:40px;color:var(--muted);">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ –ø–µ—Ä–∏–æ–¥</div>';
    return;
  }
  
  const labels = perDay.map(d => d.date.slice(5)); // MM-DD
  const data = perDay.map(d => d.bytes);
  const maxValue = Math.max(...data, 1);
  
  am5.ready(() => {
    try {
      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
      const elCheck = $('#trafficChart');
      if (!elCheck || elCheck !== el) {
        console.warn('renderChart: element changed or not found');
        return;
      }
      
      // Create root element
      const root = am5.Root.new(elCheck);
      root.setThemes([
        am5themes_Animated.new(root)
      ]);
      
      // Create chart
      const chart = root.container.children.push(am5xy.XYChart.new(root, {
        panX: false,
        panY: false,
        wheelX: "none",
        wheelY: "none",
        paddingLeft: 0,
        paddingRight: 0
      }));
      
      // Create axes
      const xAxis = chart.xAxes.push(am5xy.CategoryAxis.new(root, {
        categoryField: "category",
        renderer: am5xy.AxisRendererX.new(root, {
          cellStartLocation: 0.1,
          cellEndLocation: 0.9,
          minGridDistance: 30
        })
      }));
      
      xAxis.data.setAll(labels.map((label, idx) => ({
        category: label
      })));
      
      const yAxis = chart.yAxes.push(am5xy.ValueAxis.new(root, {
        renderer: am5xy.AxisRendererY.new(root, {})
      }));
      
      // Create series
      const series = chart.series.push(am5xy.ColumnSeries.new(root, {
        name: '–¢—Ä–∞—Ñ–∏–∫',
        xAxis: xAxis,
        yAxis: yAxis,
        valueYField: "value",
        categoryXField: "category"
      }));
      
      // Configure columns
      series.columns.template.setAll({
        tooltipY: 0,
        strokeOpacity: 0,
        cornerRadiusTL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBL: 8,
        cornerRadiusBR: 8
      });
      
      // Custom tooltip formatter
      series.columns.template.adapters.add("tooltipText", (text, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const value = dataItem.get("valueY");
          const category = dataItem.get("categoryX");
          return `${category}: ${fmtBytes(value)}`;
        }
        return text;
      });
      
      // Dynamic fill color
      series.columns.template.adapters.add("fill", (fill, target) => {
        const dataItem = target.dataItem;
        if (dataItem) {
          const value = dataItem.get("valueY");
          const ratio = maxValue > 0 ? value / maxValue : 0;
          const opacity = 0.4 + ratio * 0.4;
          return am5.color(`rgba(88, 166, 255, ${opacity})`);
        }
        return fill;
      });
      
      // Labels added via bullets for ColumnSeries
      series.bullets.push(function() {
        const label = am5.Label.new(root, {
          text: "{valueY}",
          fill: amColorVar("--text"),
          centerY: 0,
          centerX: am5.p50,
          fontSize: 10,
          fontWeight: "bold",
          dy: -5
        });
        // Custom text formatting
        label.adapters.add("text", (text, target) => {
          const dataItem = target.dataItem;
          if (dataItem) {
            const value = dataItem.get("valueY");
            return fmtBytes(value);
          }
          return text;
        });
        return am5.Bullet.new(root, {
          locationY: 1,
          sprite: label
        });
      });
      
      // Set data
      series.data.setAll(data.map((val, idx) => ({
        category: labels[idx],
        value: val
      })));
      
      // Add cursor
      chart.set("cursor", am5xy.XYCursor.new(root, {}));
      
      chartInstance = root;
    } catch (e) {
      console.error('Error creating legacy chart:', e);
      chartInstance = null;
    }
  });
}

// ==================== USERS ====================
async function loadUsers() {
  console.log('=== loadUsers: START ===');
  
  // Wait for DOM to be ready
  await new Promise(resolve => setTimeout(resolve, 50));
  
  const tbody = document.querySelector('#usersTable tbody');
  console.log('loadUsers: tbody found:', !!tbody);
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É
  if (tbody) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;color:var(--muted);">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...</td></tr>';
  } else {
    console.error('loadUsers: tbody NOT found!');
    showToast('‚ùå', '–û—à–∏–±–∫–∞: —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
    return;
  }
  
  try {
    // Load users first (required)
    console.log('loadUsers: Fetching /api/users...');
    const usersRes = await api('/api/users');
    console.log('loadUsers: Users response:', usersRes);
    
    if (!usersRes || !usersRes.users) {
      throw new Error('Invalid users response');
    }
    
    state.users = usersRes.users || [];
    console.log('loadUsers: Got', state.users.length, 'users');
    
    // Try to load stats (optional - if fails, just show users without stats)
    let statsMap = {};
    try {
      console.log('loadUsers: Fetching /api/users/stats...');
      const statsRes = await api('/api/users/stats');
      console.log('loadUsers: Stats response:', statsRes);
      
      if (statsRes && statsRes.users) {
        statsRes.users.forEach(s => {
          statsMap[s.email] = s;
        });
        console.log('loadUsers: Got stats for', Object.keys(statsMap).length, 'users');
      }
    } catch (statsError) {
      console.warn('Failed to load user stats, continuing without stats:', statsError);
      // Continue without stats - users will be shown with default values
    }
    
    console.log('loadUsers: Calling renderUsers...');
    renderUsers(state.users, statsMap);
    console.log('=== loadUsers: DONE ===');
    
  } catch (e) {
    console.error('Users load error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
    // Show error in table
    const tbodyRetry = document.querySelector('#usersTable tbody');
    if (tbodyRetry) {
      tbodyRetry.innerHTML = '<tr><td colspan="7" style="text-align:center;color:var(--bad);">‚ùå –û—à–∏–±–∫–∞: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞') + '</td></tr>';
    }
  }
}

function renderUsers(users, statsMap = {}) {
  console.log('renderUsers: called with', users ? users.length : 0, 'users');
  const tbody = document.querySelector('#usersTable tbody');
  console.log('renderUsers: tbody element found:', !!tbody);
  
  if (!tbody) {
    console.error('renderUsers: tbody NOT found!');
    // Try alternative selectors
    const table = document.getElementById('usersTable');
    if (table) {
      const tbody2 = table.querySelector('tbody');
      if (tbody2) {
        console.log('renderUsers: Found tbody via alternative selector');
        return renderUsers_Internal(users, statsMap, tbody2);
      }
    }
    console.error('renderUsers: Cannot find tbody at all!');
    return;
  }
  
  renderUsers_Internal(users, statsMap, tbody);
}

function renderUsers_Internal(users, statsMap, tbody) {
  if (!users || users.length === 0) {
    console.log('renderUsers: no users, showing empty message');
    tbody.innerHTML = '<tr><td colspan="7" class="muted">–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</td></tr>';
    return;
  }
  
  // Filter inactive users if checkbox is checked
  const hideInactive = document.getElementById('chkHideInactive')?.checked ?? true;
  const filteredUsers = hideInactive 
    ? users.filter(u => {
        const stats = statsMap[u.email] || {};
        const totalTraffic = stats.totalTrafficBytes || 0;
        return totalTraffic >= 1000000; // >= 1 MB
      })
    : users;
  
  console.log(`renderUsers: rendering ${filteredUsers.length} of ${users.length} users (hideInactive: ${hideInactive})`);
  
  if (filteredUsers.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" class="muted">–í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å–∫—Ä—ã—Ç—ã —Ñ–∏–ª—å—Ç—Ä–æ–º (—Ç—Ä–∞—Ñ–∏–∫ &lt; 1 –ú–ë)</td></tr>';
    return;
  }
  
  const rowsHtml = filteredUsers.map(u => {
    const stats = statsMap[u.email] || {};
    const alias = stats.alias || u.alias || '';
    const displayName = alias || u.email;
    const daysUsed = stats.daysUsed || 0;
    const totalTraffic = stats.totalTrafficBytes || 0;
    const top3Domains = stats.top3Domains || [];
    const isOnline = stats.isOnline || false;
    
    // Format top 3 domains - traffic first, then domain
    let top3Html = '‚Äî';
    if (top3Domains.length > 0) {
      top3Html = top3Domains.map(d => {
        const trafficGB = (d.trafficBytes / 1000000000).toFixed(1);
        return `<div style="line-height: 1.4; margin-bottom: 2px;"><span style="font-family: ui-monospace, Menlo, Consolas, monospace; color: var(--muted); font-size: 11px; display: inline-block; min-width: 48px;">${trafficGB} GB</span> <span style="margin-left: 4px;">${escapeHtml(d.domain)}</span></div>`;
      }).join('');
    }
    
    // Days used - hide if 0
    const daysUsedHtml = daysUsed > 0 ? daysUsed.toString() : '‚Äî';
    
    // Status indicator
    let statusHtml;
    if (daysUsed === 0) {
      statusHtml = '<span style="color: var(--muted);">‚ö™</span>';
    } else if (isOnline) {
      statusHtml = '<span style="color: var(--ok);">üü¢</span>';
    } else {
      statusHtml = '<span style="color: var(--muted);">‚ö™</span>';
    }
    
    return `
    <tr>
      <td>
        <span class="user-name">${escapeHtml(displayName)}</span>
      </td>
      <td class="mono" style="max-width: 180px; word-break: break-all;">${u.uuid}</td>
      <td style="max-width: 200px;">${top3Html}</td>
      <td style="text-align: center; font-size: 13px;">${daysUsedHtml}</td>
      <td style="text-align: center; font-size: 13px; font-family: ui-monospace, Menlo, Consolas, monospace;">${fmtBytes(totalTraffic)}</td>
      <td style="text-align: center; font-size: 13px;">${statusHtml}</td>
      <td style="text-align: center;">
        <div style="display: flex; gap: 4px; justify-content: center;">
          <button class="btn" data-email="${escapeHtml(u.email)}" onclick="copyUserLink(this.dataset.email)" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É">üîó</button>
          <button class="btn" data-email="${escapeHtml(u.email)}" onclick="kickUser(this.dataset.email)" title="–û—Ç–∫–ª—é—á–∏—Ç—å">üîÑ</button>
          <button class="btn danger" data-email="${escapeHtml(u.email)}" onclick="deleteUser(this.dataset.email)" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
        </div>
      </td>
    </tr>
  `;
  }).join('');
  
  console.log('renderUsers: Generated HTML length:', rowsHtml.length, 'characters');
  
  // Insert HTML into tbody
  tbody.innerHTML = rowsHtml;
  
  // Verify insertion
  console.log('renderUsers: HTML inserted into tbody');
  console.log('renderUsers: tbody.children.length after insert:', tbody.children.length);
  
  if (tbody.children.length === 0) {
    console.error('renderUsers: WARNING - tbody has no children after insert!');
  } else {
    console.log('renderUsers: ‚úÖ Successfully rendered', tbody.children.length, 'rows');
  }
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

async function addUser() {
  const email = await modal(t('addUser'), '–í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (email):', '<input type="text" id="newUserEmail" placeholder="user_12" style="width:100%;">');
  if (!email) return;
  
  try {
    await api('/api/users/add', {
      method: 'POST',
      body: JSON.stringify({ email })
    });
    showToast('‚úÖ', t('userAdded'));
    loadUsers();
    loadDashboard();
  } catch (e) {}
}

async function copyUserLink(email) {
  try {
    const res = await api(`/api/users/link?email=${encodeURIComponent(email)}`);
    if (res.ok && res.link) {
      // Copy to clipboard
      await navigator.clipboard.writeText(res.link);
      showToast('‚úÖ', '–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
    } else {
      // Show detailed error
      const errorMsg = res.error || '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Å—ã–ª–∫–∏';
      console.error('Link generation error:', errorMsg);
      
      // If server_host not configured, show helpful message
      if (errorMsg.includes('server_host')) {
        showToast('‚ùå', '–ù–∞—Å—Ç—Ä–æ–π—Ç–µ IP —Å–µ—Ä–≤–µ—Ä–∞ –≤ —Ä–∞–∑–¥–µ–ª–µ "–°–∏—Å—Ç–µ–º–∞ ‚Üí –ù–∞—Å—Ç—Ä–æ–π–∫–∏"');
      } else {
        showToast('‚ùå', errorMsg);
      }
    }
  } catch (e) {
    console.error('Copy link error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
  }
}

async function deleteUser(email) {
  const confirmed = await modal(
    '‚ö†Ô∏è –í–ù–ò–ú–ê–ù–ò–ï: –ù–µ–æ–±—Ä–∞—Ç–∏–º–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ',
    `–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "${escapeHtml(email)}"?<br><br><strong style="color: var(--bad);">–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.</strong><br>UUID –±—É–¥–µ—Ç —É–¥–∞–ª—ë–Ω –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –±–µ–∑–≤–æ–∑–≤—Ä–∞—Ç–Ω–æ.`,
    '',
    '–û—Ç–º–µ–Ω–∞',
    '–£–¥–∞–ª–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞',
    true  // confirmDanger = true
  );
  if (!confirmed) return;
  
  try {
    const res = await api('/api/users/delete', {
      method: 'POST',
      body: JSON.stringify({ email })
    });
    if (res.ok) {
      showToast('‚úÖ', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${email} —É–¥–∞–ª—ë–Ω`);
      loadUsers();
      // Reload dashboard to update stats
      if (typeof loadDashboard === 'function') {
        loadDashboard();
      }
    } else {
      console.error('Delete user API error:', res.error);
      showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è');
    }
  } catch (e) {
    console.error('Delete user error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
  }
}

async function kickUser(email) {
  const confirmed = await modal(
    'üîÑ –û—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è',
    `–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–∫–ª—é—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "${escapeHtml(email)}"?<br><br>UUID –±—É–¥–µ—Ç –∏–∑–º–µ–Ω—ë–Ω, —Ç–µ–∫—É—â–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Ä–∞–∑–æ—Ä–≤—É—Ç—Å—è. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É.`,
    '',
    '–û—Ç–º–µ–Ω–∞',
    '–û—Ç–∫–ª—é—á–∏—Ç—å',
    false
  );
  if (!confirmed) return;
  
  try {
    const res = await api('/api/users/kick', {
      method: 'POST',
      body: JSON.stringify({ email })
    });
    if (res.ok) {
      const newUuid = res.new_uuid ? ` (–Ω–æ–≤—ã–π UUID: ${res.new_uuid.substring(0, 8)}...)` : '';
      showToast('‚úÖ', `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${email} –æ—Ç–∫–ª—é—á—ë–Ω${newUuid}`);
      loadUsers();
    } else {
      console.error('Kick user API error:', res.error);
      showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è');
    }
  } catch (e) {
    console.error('Kick user error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ' + (e.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
  }
}

async function editUserAlias(email, currentAlias) {
  const alias = await modal(
    '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å Alias',
    `–í–≤–µ–¥–∏—Ç–µ alias –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è "${email}":`,
    `<input type="text" id="userAliasInput" placeholder="–í–≤–µ–¥–∏—Ç–µ alias (–∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º)" value="${escapeHtml(currentAlias)}" style="width:100%;">`,
    '–û—Ç–º–µ–Ω–∞',
    '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å',
    false
  );
  
  if (alias === null) return; // Cancelled
  
  const aliasInput = document.getElementById('userAliasInput');
  const newAlias = aliasInput ? aliasInput.value.trim() : '';
  
  try {
    const res = await api('/api/users/update-alias', {
      method: 'POST',
      body: JSON.stringify({ email, alias: newAlias })
    });
    if (res.ok) {
      showToast('‚úÖ', 'Alias –æ–±–Ω–æ–≤–ª—ë–Ω');
      loadUsers();
    } else {
      showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è alias');
    }
  } catch (e) {
    console.error('Update alias error:', e);
    showToast('‚ùå', '–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è alias');
  }
}

// Legacy function - redirect to copyUserLink
async function getLink(email) {
  return copyUserLink(email);
}

// ==================== EVENTS ====================
async function loadEvents() {
  try {
    const filter = $('#eventsFilter').value.trim();
    const url = filter ? `/api/events?text=${encodeURIComponent(filter)}` : '/api/events';
    const data = await api(url);
    renderEvents(data.events || []);
  } catch (e) {
    console.error('Events load error:', e);
  }
}

function renderEvents(events) {
  const tbody = $('#eventsTable tbody');
  
  function interpretEvent(e) {
    const type = e.type || 'UNKNOWN';
    const action = e.action || '';
    const severity = e.severity || 'INFO';
    
    let interpretation = '';
    let icon = 'üìã';
    
    if (type === 'USER') {
      if (action.includes('add')) {
        interpretation = `–î–æ–±–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${e.email || e.userId || '‚Äî'}`;
        icon = '‚ûï';
      } else if (action.includes('delete')) {
        interpretation = `–£–¥–∞–ª—ë–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${e.email || e.userId || '‚Äî'}`;
        icon = 'üóëÔ∏è';
      } else if (action.includes('kick')) {
        interpretation = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–∫–ª—é—á—ë–Ω (UUID –∏–∑–º–µ–Ω—ë–Ω): ${e.email || e.userId || '‚Äî'}`;
        icon = 'üîÑ';
      } else {
        interpretation = `–î–µ–π—Å—Ç–≤–∏–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º: ${action}`;
      }
    } else if (type === 'SYSTEM') {
      if (action.includes('restart')) {
        interpretation = `–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞: ${e.target || '‚Äî'}`;
        icon = '‚ö°';
      } else {
        interpretation = `–°–∏—Å—Ç–µ–º–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: ${action}`;
      }
    } else if (type === 'SETTINGS') {
      interpretation = `–ò–∑–º–µ–Ω–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–π–∫–∏: ${action}`;
      icon = '‚öôÔ∏è';
    } else if (type === 'XRAY') {
      interpretation = `–î–µ–π—Å—Ç–≤–∏–µ —Å Xray: ${action}`;
      icon = 'üîß';
    } else {
      interpretation = `${type}: ${action}`;
    }
    
    return { interpretation, icon, severity };
  }
  
  tbody.innerHTML = events.slice(0, 100).map(e => {
    const { interpretation, icon, severity } = interpretEvent(e);
    const severityClass = severity === 'ERROR' ? 'bad' : severity === 'WARN' ? 'warn' : 'ok';
    
    return `
      <tr>
        <td class="mono" style="font-size:11px;">${fmtDate(e.ts)}</td>
        <td><span class="badge ${severityClass}">${e.type || '‚Äî'}</span></td>
        <td>${icon} ${interpretation}</td>
        <td class="muted" style="font-size:11px;">${e.action || '‚Äî'}</td>
      </tr>
    `;
  }).join('') || '<tr><td colspan="4" class="muted">–ù–µ—Ç —Å–æ–±—ã—Ç–∏–π</td></tr>';
}

// ==================== XRAY ====================
async function loadXrayConfig() {
  try {
    const xrayConfigEl = $('#xrayConfig');
    const realityParamsEl = $('#realityParams');
    
    if (!xrayConfigEl || !realityParamsEl) {
      console.warn('loadXrayConfig: elements not found, settings pane may not be active');
      return;
    }
    
    const data = await api('/api/xray/config');
    xrayConfigEl.value = JSON.stringify(data.config, null, 2);
    
    const reality = data.reality || {};
    // Get server_host from settings if not in config
    const serverHost = reality.server_host || state.settings?.xray?.server_host || '(–Ω–µ –∑–∞–¥–∞–Ω)';
    realityParamsEl.textContent = `pbk: ${reality.pbk || '(–Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω)'}
sni: ${reality.sni || '‚Äî'}
sid: ${reality.sid || '‚Äî'}
port: ${reality.port || 443}
server_host: ${serverHost}`;
  } catch (e) {
    console.error('Xray config load error:', e);
  }
}

async function restartXray() {
  const ok = await modal('–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ Xray', 'Xray –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω. –í—Å–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±–æ—Ä–≤—É—Ç—Å—è. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?');
  if (!ok) return;
  
  try {
    await api('/api/xray/restart', { method: 'POST', body: '{}' });
    showToast('‚úÖ', 'Xray –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω');
    loadSystemStatus();
  } catch (e) {}
}

// ==================== SETTINGS ====================
async function loadSettings() {
  try {
    // Ensure settings subpane is visible
    const settingsSubpane = document.querySelector('[data-system-subpane="settings"]');
    if (settingsSubpane && !settingsSubpane.classList.contains('active')) {
      // If not visible, make it visible first
      settingsSubpane.classList.add('active');
      settingsSubpane.style.display = 'block';
    }
    
    const data = await api('/api/settings');
    state.settings = data.settings;
    
    const serverHost = $('#setServerHost');
    const pbk = $('#setPbk');
    const usageDir = $('#setUsageDir');
    
    if (serverHost) serverHost.value = state.settings.xray?.server_host || '';
    if (pbk) pbk.value = state.settings.xray?.reality_pbk || '';
    if (usageDir) usageDir.value = state.settings.collector?.usage_dir || '/var/log/xray/usage';
    
    // Also reload Xray config to show current Reality parameters
    await loadXrayConfig();
    
    // Collector status (read-only, no auto-toggle)
    try {
      const collector = await api('/api/collector/status');
      if (collector && collector.ok !== false) {
        const cron = collector.cron || {};
        let cronHtml = '';
        if (cron.found) {
          let jobsHtml = '';
          if (cron.all_jobs && cron.all_jobs.length > 1) {
            // Show all jobs with stats and edit capability
            jobsHtml = cron.all_jobs.map((job, idx) => {
              const stats = job.stats || {};
              const scheduleParts = (job.schedule || '').split(' ');
              const scheduleDesc = scheduleParts.length === 5 ? 
                `–ö–∞–∂–¥—É—é ${scheduleParts[0]} –º–∏–Ω—É—Ç—É ${scheduleParts[1]} —á–∞—Å–∞` : job.schedule;
              
              const status = job.status || {};
              const statusColor = status.active ? 'var(--ok)' : 'var(--warn)';
              const statusText = status.active ? 'üü¢ –ê–∫—Ç–∏–≤–Ω–∞' : '‚ö™ –ù–µ–∞–∫—Ç–∏–≤–Ω–∞';
              
              return `
              <div style="padding: 8px; background: var(--panel); border-radius: 6px; border: 1px solid var(--line);">
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px;">
                  <div style="flex-grow: 1;">
                    <div style="font-weight: 600; font-size: 11px; margin-bottom: 2px;">
                      ${job.script ? `<code style="font-size: 10px; background: var(--panel2); padding: 2px 5px; border-radius: 3px;">${escapeHtml(job.script)}</code>` : 'Cron –∑–∞–¥–∞—á–∞'}
                    </div>
                    <div style="font-size: 10px; color: var(--muted); line-height: 1.2;">
                      ${job.description || '–°–∫—Ä–∏–ø—Ç —Å–±–æ—Ä—â–∏–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏'}
                    </div>
                  </div>
                  <div style="font-size: 10px; color: ${statusColor}; white-space: nowrap; margin-left: 8px;">
                    ${statusText}
                  </div>
                </div>
                
                <div style="margin-bottom: 6px; padding: 4px; background: var(--panel2); border-radius: 3px;">
                  <div style="font-size: 9px; color: var(--muted); margin-bottom: 2px;">–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ:</div>
                  <div style="display: flex; gap: 4px; align-items: center; flex-wrap: wrap;">
                    <code style="font-size: 10px; font-family: ui-monospace; background: var(--bg); padding: 2px 5px; border-radius: 3px;">${escapeHtml(job.schedule || '‚Äî')}</code>
                    <button class="btn" style="padding: 2px 6px; font-size: 9px; line-height: 1.2;" onclick="editCronSchedule('${escapeHtml(job.script || '')}', '${escapeHtml(job.schedule || '')}')">‚úèÔ∏è</button>
                  </div>
                </div>
                
                <div style="margin-bottom: 4px; font-size: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
                  <span><span style="color: var(--muted);">–ó–∞–ø—É—Å–∫–æ–≤:</span> <strong>${stats.runs_count || 0}</strong></span>
                  ${stats.errors_count > 0 ? `<span style="color: var(--warn);">–û—à–∏–±–æ–∫: <strong>${stats.errors_count}</strong></span>` : ''}
                  ${stats.files_count !== undefined ? `<span style="color: var(--muted);">–§–∞–π–ª–æ–≤: <strong>${stats.files_count}</strong></span>` : ''}
                </div>
                
                ${stats.last_run ? `
                <div style="font-size: 9px; color: var(--muted); margin-bottom: 3px;">
                  –ü–æ—Å–ª–µ–¥–Ω–∏–π –∑–∞–ø—É—Å–∫: <strong style="color: var(--text);">${escapeHtml(stats.last_run)}</strong>
                </div>
                ` : ''}
                
                ${stats.last_error ? `
                <div style="margin-top: 3px; padding: 4px; background: rgba(255, 100, 100, 0.1); border-radius: 3px; font-size: 9px; color: var(--warn); line-height: 1.2;">
                  <strong>–û—à–∏–±–∫–∞:</strong> ${escapeHtml(stats.last_error.substring(0, 80))}${stats.last_error.length > 80 ? '...' : ''}
                </div>
                ` : ''}
                
                ${stats.created_files && stats.created_files.length > 0 ? `
                <div style="margin-top: 4px;">
                  <div style="font-size: 9px; color: var(--muted); margin-bottom: 2px;">–§–∞–π–ª—ã (${stats.created_files.length}):</div>
                  <div style="font-size: 8px; font-family: ui-monospace; color: var(--muted); max-height: 40px; overflow-y: auto; line-height: 1.3;">
                    ${stats.created_files.slice(0, 3).map(f => `<div>${escapeHtml(f)}</div>`).join('')}
                    ${stats.created_files.length > 3 ? `<div style="color: var(--muted);">... +${stats.created_files.length - 3}</div>` : ''}
                  </div>
                </div>
                ` : ''}
              </div>
            `;
            }).join('');
          } else {
            // Show single job
            jobsHtml = `
              <div style="margin-top: 4px; padding: 6px; background: var(--panel); border-radius: 4px;">
                <div><strong>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ:</strong> <code>${escapeHtml(cron.schedule || '‚Äî')}</code></div>
                ${cron.command ? `<div style="margin-top: 4px; word-break: break-all;"><strong>–ö–æ–º–∞–Ω–¥–∞:</strong> <code style="font-size: 11px;">${escapeHtml(cron.command)}</code></div>` : ''}
              </div>
            `;
          }
          
          cronHtml = `
            <div style="margin-top: 8px;">
              <div style="font-size: 12px; color: var(--muted); margin-bottom: 8px;">
                üìÖ Cron –∑–∞–¥–∞—á–∞${cron.jobs_count > 1 ? '–∏ (' + cron.jobs_count + ')' : ''} ‚Ä¢ –§–∞–π–ª: <code style="font-size: 11px;">${escapeHtml(cron.file || '‚Äî')}</code>
              </div>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 8px; padding-right: 4px;">
                ${jobsHtml}
              </div>
            </div>
          `;
        } else {
          cronHtml = `
            <div class="form-row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--line);">
              <div style="color: var(--warn);">
                ‚ö†Ô∏è Cron –∑–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ /etc/cron.daily/xray-usage –∏–ª–∏ crontab -l
              </div>
            </div>
          `;
        }
        
        let disabledInfo = '';
        if (!collector.enabled) {
          const activeCount = collector.active_jobs_count || 0;
          const totalCount = collector.total_jobs_count || 0;
          let howToFix = '';
          
          if (totalCount === 0) {
            howToFix = '–°–æ–∑–¥–∞–π—Ç–µ cron —Ñ–∞–π–ª /etc/cron.d/xray-usage —Å –∑–∞–¥–∞—á–∞–º–∏ —Å–±–æ—Ä—â–∏–∫–∞.';
          } else if (activeCount === 0 && totalCount > 0) {
            howToFix = '–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–µ—Ä–≤–∏—Å cron –∑–∞–ø—É—â–µ–Ω (systemctl status cron) –∏ –∑–∞–¥–∞—á–∏ –Ω–µ –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ cron —Ñ–∞–π–ª–µ.';
          } else {
            howToFix = '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å cron —Å–µ—Ä–≤–∏—Å–∞ –∏ —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∑–∞–¥–∞—á–∏ –∞–∫—Ç–∏–≤–Ω—ã.';
          }
          
          disabledInfo = `
            <div style="margin-bottom: 8px; padding: 8px; background: rgba(255, 200, 0, 0.1); border-radius: 4px; border-left: 3px solid var(--warn);">
              <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--warn);">
                ‚ö†Ô∏è –°–±–æ—Ä—â–∏–∫ –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω
              </div>
              <div style="font-size: 10px; color: var(--muted); margin-bottom: 4px;">
                <strong>–ü—Ä–∏—á–∏–Ω–∞:</strong> ${escapeHtml(collector.disabled_reason || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞')}
              </div>
              <div style="font-size: 10px; color: var(--muted); margin-bottom: 4px;">
                <strong>–°—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á:</strong> ${activeCount} –∏–∑ ${totalCount} –∞–∫—Ç–∏–≤–Ω—ã
              </div>
              <div style="font-size: 10px; color: var(--muted);">
                <strong>–ö–∞–∫ –∏—Å–ø—Ä–∞–≤–∏—Ç—å:</strong> ${escapeHtml(howToFix)}
              </div>
            </div>
          `;
        }
        
        $('#collectorStatus').innerHTML = `
          <div style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--line);">
            <div style="font-size: 12px;"><span style="color: var(--muted);">–°—Ç–∞—Ç—É—Å:</span> <strong>${collector.enabled ? '‚úÖ –í–∫–ª—é—á–µ–Ω' : '‚ùå –í—ã–∫–ª—é—á–µ–Ω'}</strong></div>
            <div style="font-size: 12px;"><span style="color: var(--muted);">–§–∞–π–ª–æ–≤:</span> <strong>${collector.files_count || 0}</strong></div>
            <div style="font-size: 12px;"><span style="color: var(--muted);">–ü–æ—Å–ª–µ–¥–Ω–∏–π —Ñ–∞–π–ª:</span> <strong>${collector.newest_file || '‚Äî'}</strong></div>
            <div style="font-size: 12px;"><span style="color: var(--muted);">–õ–∞–≥:</span> <strong class="${collector.lag_days > 1 ? 'text-warn' : ''}">${collector.lag_days ?? '‚Äî'} –¥–Ω–µ–π</strong></div>
          </div>
          ${disabledInfo}
          ${cronHtml}
        `;
      } else {
        $('#collectorStatus').innerHTML = '<div class="muted">–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–±–æ—Ä—â–∏–∫–∞</div>';
      }
    } catch (e) {
      $('#collectorStatus').innerHTML = '<div class="muted">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ —Å–±–æ—Ä—â–∏–∫–∞</div>';
    }
  } catch (e) {
    console.error('Settings load error:', e);
  }
}

async function editCronSchedule(scriptName, currentSchedule) {
  // Parse current schedule
  const parts = (currentSchedule || '0 0 * * *').split(' ');
  const [minute, hour, day, month, weekday] = parts.length === 5 ? parts : ['0', '0', '*', '*', '*'];
  
  // Show modal with schedule editor
  const scheduleHtml = `
    <div style="margin-bottom: 12px;">
      <label style="display: block; margin-bottom: 4px; font-size: 12px;">–§–æ—Ä–º–∞—Ç cron (5 –ø–æ–ª–µ–π):</label>
      <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-bottom: 8px;">
        <div>
          <input type="text" id="cronMinute" value="${escapeHtml(minute)}" placeholder="–º–∏–Ω—É—Ç–∞" style="width: 100%; padding: 6px; font-family: ui-monospace; font-size: 12px;" />
          <div style="font-size: 10px; color: var(--muted); margin-top: 2px;">–ú–∏–Ω—É—Ç–∞ (0-59)</div>
        </div>
        <div>
          <input type="text" id="cronHour" value="${escapeHtml(hour)}" placeholder="—á–∞—Å" style="width: 100%; padding: 6px; font-family: ui-monospace; font-size: 12px;" />
          <div style="font-size: 10px; color: var(--muted); margin-top: 2px;">–ß–∞—Å (0-23)</div>
        </div>
        <div>
          <input type="text" id="cronDay" value="${escapeHtml(day)}" placeholder="–¥–µ–Ω—å" style="width: 100%; padding: 6px; font-family: ui-monospace; font-size: 12px;" />
          <div style="font-size: 10px; color: var(--muted); margin-top: 2px;">–î–µ–Ω—å (1-31)</div>
        </div>
        <div>
          <input type="text" id="cronMonth" value="${escapeHtml(month)}" placeholder="–º–µ—Å—è—Ü" style="width: 100%; padding: 6px; font-family: ui-monospace; font-size: 12px;" />
          <div style="font-size: 10px; color: var(--muted); margin-top: 2px;">–ú–µ—Å—è—Ü (1-12)</div>
        </div>
        <div>
          <input type="text" id="cronWeekday" value="${escapeHtml(weekday)}" placeholder="–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏" style="width: 100%; padding: 6px; font-family: ui-monospace; font-size: 12px;" />
          <div style="font-size: 10px; color: var(--muted); margin-top: 2px;">–î–µ–Ω—å –Ω–µ–¥–µ–ª–∏ (0-7)</div>
        </div>
      </div>
      <div style="margin-top: 8px; padding: 8px; background: var(--panel2); border-radius: 4px; font-size: 11px;">
        <strong>–ü—Ä–∏–º–µ—Ä—ã:</strong><br/>
        ‚Ä¢ –ö–∞–∂–¥—ã–π —á–∞—Å: <code>0 * * * *</code><br/>
        ‚Ä¢ –ö–∞–∂–¥—ã–µ 12 —á–∞—Å–æ–≤: <code>0 */12 * * *</code><br/>
        ‚Ä¢ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 00:05: <code>5 0 * * *</code><br/>
        ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ <code>*</code> –¥–ª—è "–ª—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ"
      </div>
    </div>
  `;
  
  const result = await modal('–ò–∑–º–µ–Ω–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ cron', scheduleHtml, ['–°–æ—Ö—Ä–∞–Ω–∏—Ç—å', '–û—Ç–º–µ–Ω–∞']);
  if (result === '–°–æ—Ö—Ä–∞–Ω–∏—Ç—å') {
    const newSchedule = [
      $('#cronMinute').value.trim(),
      $('#cronHour').value.trim(),
      $('#cronDay').value.trim(),
      $('#cronMonth').value.trim(),
      $('#cronWeekday').value.trim()
    ].join(' ');
    
    if (newSchedule.split(' ').length !== 5) {
      toast('–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è', 'error');
      return;
    }
    
    try {
      const res = await api('/api/collector/update-schedule', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          script: scriptName,
          schedule: newSchedule
        })
      });
      
      if (res.ok !== false) {
        toast('–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ. –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤—Å—Ç—É–ø—è—Ç –≤ —Å–∏–ª—É –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ cron.', 'success');
        loadSettings(); // Reload to show updated schedule
      } else {
        toast('–û—à–∏–±–∫–∞: ' + (res.error || '–Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ'), 'error');
      }
    } catch (e) {
      toast('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: ' + e.message, 'error');
    }
  }
}

async function saveSettings() {
  try {
    const settings = {
      xray: {
        server_host: $('#setServerHost').value.trim(),
        reality_pbk: $('#setPbk').value.trim(),
      },
      collector: {
        usage_dir: $('#setUsageDir').value.trim(),
      }
    };
    
    await api('/api/settings', {
      method: 'POST',
      body: JSON.stringify(settings)
    });
    
    showToast('‚úÖ', t('settingsSaved'));
  } catch (e) {}
}

// ==================== COLLECTOR STATUS ====================
async function loadCollectorStatus() {
  try {
    const data = await api('/api/collector/status');
    const enabled = data.enabled || false;
    const lagDays = data.lag_days;
    
    const dotEl = $('#dotCollector');
    
    if (dotEl) {
      if (!enabled) {
        dotEl.className = 'dot bad'; // –∫—Ä–∞—Å–Ω—ã–π = –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
      } else if (lagDays !== null && lagDays > 1) {
        dotEl.className = 'dot bad'; // –∫—Ä–∞—Å–Ω—ã–π = –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –ª–∞–≥
      } else if (lagDays === 1) {
        dotEl.className = 'dot warn'; // –∂—ë–ª—Ç—ã–π = –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º—ã (–ª–∞–≥ 1 –¥–µ–Ω—å)
      } else {
        dotEl.className = 'dot ok'; // –∑–µ–ª—ë–Ω—ã–π = –≤—Å—ë –æ—Ç–ª–∏—á–Ω–æ
      }
    }
  } catch (e) {
    console.error('Collector status load error:', e);
    const dotEl = $('#dotCollector');
    if (dotEl) dotEl.className = 'dot bad'; // –∫—Ä–∞—Å–Ω—ã–π = –æ—à–∏–±–∫–∞
  }
}

// ==================== SYSTEM STATUS ====================
function updateHeaderStatusBadges(services) {
  // services is { ui: {...}, xray: {...} }
  const ui = services.ui || {};
  const xray = services.xray || {};
  
  // UI status - only color indicator (green = ok, red = bad, yellow = warn)
  const uiActive = Boolean(ui.active);
  const dotUI = $('#dotUI');
  if (dotUI) {
    // Determine status: ok (green), bad (red), or warn (yellow)
    let statusClass = 'bad'; // default to red
    if (uiActive) {
      statusClass = 'ok'; // green = —Ä–∞–±–æ—Ç–∞–µ—Ç
    } else {
      statusClass = 'bad'; // red = –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    }
    dotUI.className = 'dot ' + statusClass;
  }
  
  // Xray status - only color indicator
  const xrayActive = Boolean(xray.active);
  const dotXray = $('#dotXray');
  if (dotXray) {
    let statusClass = 'bad';
    if (xrayActive) {
      statusClass = 'ok'; // green = —Ä–∞–±–æ—Ç–∞–µ—Ç
    } else {
      statusClass = 'bad'; // red = –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
    }
    dotXray.className = 'dot ' + statusClass;
  }
}

async function loadSystemStatus() {
  try {
    const data = await api('/api/system/status');
    if (!data.ok) return;
    
    // API returns ui and xray directly, not inside services
    const ui = data.ui || {};
    const xray = data.xray || {};
    
    updateHeaderStatusBadges({ ui, xray });
  } catch (e) {
    console.error('Status load error:', e);
    const dotUI = $('#dotUI');
    const dotXray = $('#dotXray');
    if (dotUI) dotUI.className = 'dot bad';
    if (dotXray) dotXray.className = 'dot bad';
  }
}

// ==================== INIT ====================
let initCalled = false;
async function init() {
  if (initCalled) {
    console.warn('init() already called, skipping');
    return;
  }
  initCalled = true;
  
  // Theme
  const savedTheme = localStorage.getItem('theme') || 'dark';
  setTheme(savedTheme);
  
  // Lang
  const savedLang = localStorage.getItem('lang') || 'ru';
  state.lang = savedLang;
  const langToggle = $('#langToggle');
  if (langToggle) langToggle.textContent = savedLang.toUpperCase();
  applyI18n();
  
  // Event handlers for tabs (–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, –°–æ–±—ã—Ç–∏—è, Xray, –ù–∞—Å—Ç—Ä–æ–π–∫–∏)
  const tabsContainer = document.querySelector('.tabs');
  if (tabsContainer) {
    tabsContainer.addEventListener('click', (e) => {
      const tab = e.target.closest('.tab');
      if (tab && tab.dataset && tab.dataset.tab) {
        e.preventDefault();
        e.stopPropagation();
        setTab(tab.dataset.tab);
      }
    });
  } else {
    // Fallback: direct handlers
    const tabs = $$('.tab');
    if (tabs.length > 0) {
      tabs.forEach(tab => {
        if (tab && tab.dataset && tab.dataset.tab) {
          tab.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setTab(tab.dataset.tab);
          };
        }
      });
    }
  }
  
  // Event handlers for system sub-tabs (Services, Events, Settings)
  document.addEventListener('click', (e) => {
    const systemTab = e.target.closest('.system-tab');
    if (systemTab && systemTab.dataset && systemTab.dataset.systemTab) {
      e.preventDefault();
      e.stopPropagation();
      setSystemSubpane(systemTab.dataset.systemTab);
    }
  });
  
  const themeToggle = $('#themeToggle');
  if (themeToggle) {
    themeToggle.onclick = () => {
      setTheme(state.theme === 'dark' ? 'light' : 'dark');
    };
  }
  
  if (langToggle) {
    langToggle.onclick = () => {
      state.lang = state.lang === 'ru' ? 'en' : 'ru';
      localStorage.setItem('lang', state.lang);
      langToggle.textContent = state.lang.toUpperCase();
      applyI18n();
      loadDashboard();
    };
  }
  
  // User management buttons
  const btnAddUser = $('#btnAddUser');
  if (btnAddUser) btnAddUser.onclick = addUser;
  const btnRefreshUsers = $('#btnRefreshUsers');
  if (btnRefreshUsers) btnRefreshUsers.onclick = loadUsers;
  
  // Filter checkbox handler
  const chkHideInactive = $('#chkHideInactive');
  if (chkHideInactive) {
    chkHideInactive.onchange = () => {
      console.log('Filter changed, reloading users');
      loadUsers();
    };
  }
  const btnRefreshEvents = $('#btnRefreshEvents');
  if (btnRefreshEvents) btnRefreshEvents.onclick = loadEvents;
  const eventsFilter = $('#eventsFilter');
  if (eventsFilter) {
    eventsFilter.onkeyup = (e) => { if (e.key === 'Enter') loadEvents(); };
  }
  const btnReloadXray = $('#btnReloadXray');
  if (btnReloadXray) btnReloadXray.onclick = loadXrayConfig;
  const btnSaveSettings = $('#btnSaveSettings');
  if (btnSaveSettings) btnSaveSettings.onclick = saveSettings;
  const btnReloadSettings = $('#btnReloadSettings');
  if (btnReloadSettings) btnReloadSettings.onclick = loadSettings;
  
  // Journal - load on init if pane is active
  const paneJournal = document.querySelector('[data-pane="journal"]');
  if (paneJournal && paneJournal.classList.contains('active')) {
    loadJournal('xray'); // Load Xray logs by default
  }
  // Navigation pills - use event delegation
  const navContainer = document.querySelector('.nav-pills') || document.querySelector('.header-right');
  if (navContainer) {
    navContainer.addEventListener('click', (e) => {
      const pill = e.target.closest('.nav-pill');
      if (pill && pill.dataset && pill.dataset.nav) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Nav pill clicked:', pill.dataset.nav);
        setNav(pill.dataset.nav);
      }
    });
  }
  
  // Date select
  const dateSelect = $('#dateSelect');
  if (dateSelect) {
    dateSelect.onchange = () => {
      state.date = dateSelect.value;
      localStorage.setItem('usage.date', state.date);
      loadManagement();
    };
  } else {
    console.warn('dateSelect element not found');
  }
  
  // Segmented controls - use event delegation
  document.addEventListener('click', (e) => {
    // Daily/Cumulative
    if (e.target.id === 'segDaily' || e.target.id === 'segCum') {
      e.preventDefault();
      e.stopPropagation();
      const isDaily = e.target.id === 'segDaily';
      state.mode = isDaily ? 'daily' : 'cumulative';
      localStorage.setItem('usage.mode', state.mode);
      const segDaily = $('#segDaily');
      const segCum = $('#segCum');
      if (segDaily && segCum) {
        if (isDaily) {
          segDaily.classList.add('active');
          segCum.classList.remove('active');
        } else {
          segCum.classList.add('active');
          segDaily.classList.remove('active');
        }
      }
      loadManagement();
      return;
    }
    
    // Dark/Light
    if (e.target.id === 'segDark' || e.target.id === 'segLight') {
      e.preventDefault();
      e.stopPropagation();
      const isDark = e.target.id === 'segDark';
      setTheme(isDark ? 'dark' : 'light');
      const segDark = $('#segDark');
      const segLight = $('#segLight');
      if (segDark && segLight) {
        if (isDark) {
          segDark.classList.add('active');
          segLight.classList.remove('active');
        } else {
          segLight.classList.add('active');
          segDark.classList.remove('active');
        }
      }
      return;
    }
    
    
    // Overview Metric Filter (Traffic/Connections)
    if (e.target.id === 'btnOverviewTraffic' || e.target.id === 'btnOverviewConns') {
      e.preventDefault();
      e.stopPropagation();
      
      const newMetric = e.target.id === 'btnOverviewTraffic' ? 'traffic' : 'conns';
      state.overviewMetric = newMetric;
      localStorage.setItem('overview.metric', state.overviewMetric);
      
      // Sync with users section filters (mainMetric and miniMetric)
      state.mainMetric = newMetric;
      state.miniMetric = newMetric;
      localStorage.setItem('users.mainMetric', state.mainMetric);
      localStorage.setItem('users.miniMetric', state.miniMetric);
      
      // Update global filter button states
      const btnTraffic = $('#btnOverviewTraffic');
      const btnConns = $('#btnOverviewConns');
      if (btnTraffic && btnConns) {
        if (newMetric === 'traffic') {
          btnTraffic.classList.add('active');
          btnConns.classList.remove('active');
        } else {
          btnConns.classList.add('active');
          btnTraffic.classList.remove('active');
        }
      }
      
      // Update users section filter buttons (sync them with global filter)
      const segCmpTraffic = $('#segCmpTraffic');
      const segCmpConns = $('#segCmpConns');
      const segMiniTraffic = $('#segMiniTraffic');
      const segMiniConns = $('#segMiniConns');
      
      if (segCmpTraffic && segCmpConns) {
        if (newMetric === 'traffic') {
          segCmpTraffic.classList.add('active');
          segCmpConns.classList.remove('active');
        } else {
          segCmpConns.classList.add('active');
          segCmpTraffic.classList.remove('active');
        }
      }
      
      if (segMiniTraffic && segMiniConns) {
        if (newMetric === 'traffic') {
          segMiniTraffic.classList.add('active');
          segMiniConns.classList.remove('active');
        } else {
          segMiniConns.classList.add('active');
          segMiniTraffic.classList.remove('active');
        }
      }
      
      // Re-render overview page with new filter
      if (state.dashboard) {
        renderManagement(state.dashboard);
      } else {
        loadManagement();
      }
      return;
    }
    
    // Chart Library Toggle - now handled by select element (see separate handler below)
    // Old button handlers removed
    
    // Users: Traffic/Conns comparison toggle (synced with global overview filter)
    if (e.target.id === 'segCmpTraffic' || e.target.id === 'segCmpConns') {
      e.preventDefault();
      e.stopPropagation();
      const isTraffic = e.target.id === 'segCmpTraffic';
      const newMetric = isTraffic ? 'traffic' : 'conns';
      
      // Update both local and global metrics
      state.mainMetric = newMetric;
      state.overviewMetric = newMetric; // Sync with global filter
      state.miniMetric = newMetric; // Also sync mini metric
      localStorage.setItem('users.mainMetric', state.mainMetric);
      localStorage.setItem('overview.metric', state.overviewMetric);
      localStorage.setItem('users.miniMetric', state.miniMetric);
      
      // Update global filter buttons
      const btnTraffic = $('#btnOverviewTraffic');
      const btnConns = $('#btnOverviewConns');
      if (btnTraffic && btnConns) {
        if (isTraffic) {
          btnTraffic.classList.add('active');
          btnConns.classList.remove('active');
        } else {
          btnConns.classList.add('active');
          btnTraffic.classList.remove('active');
        }
      }
      
      // Update local filter buttons
      const segCmpTraffic = $('#segCmpTraffic');
      const segCmpConns = $('#segCmpConns');
      const segMiniTraffic = $('#segMiniTraffic');
      const segMiniConns = $('#segMiniConns');
      if (segCmpTraffic && segCmpConns) {
        if (isTraffic) {
          segCmpTraffic.classList.add('active');
          segCmpConns.classList.remove('active');
        } else {
          segCmpConns.classList.add('active');
          segCmpTraffic.classList.remove('active');
        }
      }
      if (segMiniTraffic && segMiniConns) {
        if (isTraffic) {
          segMiniTraffic.classList.add('active');
          segMiniConns.classList.remove('active');
        } else {
          segMiniConns.classList.add('active');
          segMiniTraffic.classList.remove('active');
        }
      }
      
      // Re-render entire overview page with new filter
      if (state.dashboard) {
        renderManagement(state.dashboard);
      } else {
        loadManagement();
      }
      return;
    }
    
    // Users: Mini Traffic/Conns toggle (synced with global overview filter)
    if (e.target.id === 'segMiniTraffic' || e.target.id === 'segMiniConns') {
      e.preventDefault();
      e.stopPropagation();
      const isTraffic = e.target.id === 'segMiniTraffic';
      const newMetric = isTraffic ? 'traffic' : 'conns';
      
      // Update both local and global metrics
      state.miniMetric = newMetric;
      state.overviewMetric = newMetric; // Sync with global filter
      state.mainMetric = newMetric; // Also sync main metric
      localStorage.setItem('users.miniMetric', state.miniMetric);
      localStorage.setItem('overview.metric', state.overviewMetric);
      localStorage.setItem('users.mainMetric', state.mainMetric);
      
      // Update global filter buttons
      const btnTraffic = $('#btnOverviewTraffic');
      const btnConns = $('#btnOverviewConns');
      if (btnTraffic && btnConns) {
        if (isTraffic) {
          btnTraffic.classList.add('active');
          btnConns.classList.remove('active');
        } else {
          btnConns.classList.add('active');
          btnTraffic.classList.remove('active');
        }
      }
      
      // Update local filter buttons
      const segCmpTraffic = $('#segCmpTraffic');
      const segCmpConns = $('#segCmpConns');
      const segMiniTraffic = $('#segMiniTraffic');
      const segMiniConns = $('#segMiniConns');
      if (segCmpTraffic && segCmpConns) {
        if (isTraffic) {
          segCmpTraffic.classList.add('active');
          segCmpConns.classList.remove('active');
        } else {
          segCmpConns.classList.add('active');
          segCmpTraffic.classList.remove('active');
        }
      }
      if (segMiniTraffic && segMiniConns) {
        if (isTraffic) {
          segMiniTraffic.classList.add('active');
          segMiniConns.classList.remove('active');
        } else {
          segMiniConns.classList.add('active');
          segMiniTraffic.classList.remove('active');
        }
      }
      
      // Re-render entire overview page with new filter
      if (state.dashboard) {
        renderManagement(state.dashboard);
      } else {
        loadManagement();
      }
      return;
    }
  });
  
  // Segmented controls handlers are already set via event delegation above
  // Just initialize visual state here
  
  // Legacy handlers (if elements exist)
  const btnRefreshDashboard = $('#btnRefreshDashboard');
  if (btnRefreshDashboard) btnRefreshDashboard.onclick = () => loadManagement();
  const periodSelect = $('#periodSelect');
  if (periodSelect) periodSelect.onchange = () => loadManagement();
  
  // Online pause button
  const btnPause = $('#btnPause');
  if (btnPause) {
    btnPause.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      state.livePaused = !state.livePaused;
      localStorage.setItem('live.paused', state.livePaused);
      btnPause.textContent = state.livePaused ? 'Resume' : 'Pause';
      if (state.livePaused) {
        stopOnlinePolling();
      } else {
        // Resume - –∑–∞–ø—É—Å—Ç–∏—Ç—å polling —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–∞ –≤–∫–ª–∞–¥–∫–µ online
        const paneOnline = document.querySelector('[data-pane="online"]');
        if (paneOnline && paneOnline.classList.contains('active')) {
          startOnlinePolling();
        }
      }
    };
  }
  
  // Initialize theme/unit/mode from state (with null checks)
  const segDark = $('#segDark');
  const segLight = $('#segLight');
  if (segDark && segLight) {
    if (state.theme === 'dark') {
      segDark.classList.add('active');
      segLight.classList.remove('active');
    } else {
      segLight.classList.add('active');
      segDark.classList.remove('active');
    }
  }
  
  
  const segDaily = $('#segDaily');
  const segCum = $('#segCum');
  if (segDaily && segCum) {
    if (state.mode === 'daily') {
      segDaily.classList.add('active');
      segCum.classList.remove('active');
    } else {
      segCum.classList.add('active');
      segDaily.classList.remove('active');
    }
  }
  
  // Initial load
  try {
    await loadSystemStatus();
    await updateDateSelect();
    // Ensure dashboard tab is active and management pane is shown
    const dashboardTab = document.querySelector('.tab[data-tab="dashboard"]');
    if (dashboardTab) {
      $$('.tab').forEach(t => t.classList.remove('active'));
      dashboardTab.classList.add('active');
    }
    // Show management pane, hide others
    $$('.pane').forEach(p => {
      if (p && p.dataset) {
        if (p.dataset.pane === 'management') {
          p.classList.add('active');
          p.style.display = 'block';
        } else {
          p.classList.remove('active');
          p.style.display = 'none';
        }
      }
    });
    
    // Deactivate nav pills
    $$('.nav-pill').forEach(p => p.classList.remove('active'));
    // Load management content
    await loadManagement();
    // Load collector status
    await loadCollectorStatus();
  } catch (e) {
    console.error('Init error:', e);
    // Load collector status even on error
    try {
      await loadCollectorStatus();
    } catch (e) {
      console.error('Collector status load error:', e);
    }
  }
  
  // Initialize Online segmented controls
  if (state.liveScope === 'global') {
    $('#segScopeGlobal').classList.add('active');
    $('#segScopeUsers').classList.remove('active');
  } else {
    $('#segScopeUsers').classList.add('active');
    $('#segScopeGlobal').classList.remove('active');
  }
  
  if (state.liveMetric === 'traffic') {
    $('#segMetricTraffic').classList.add('active');
  } else if (state.liveMetric === 'conns') {
    $('#segMetricConns').classList.add('active');
  } else {
    $('#segMetricOnline').classList.add('active');
  }
  
  if (state.livePeriod === 3600) {
    $('#segPeriod60m').classList.add('active');
  } else if (state.livePeriod === 21600) {
    $('#segPeriod6h').classList.add('active');
  } else {
    $('#segPeriod24h').classList.add('active');
  }
  
  if (state.liveGran === 60) {
    $('#segGran1m').classList.add('active');
  } else if (state.liveGran === 300) {
    $('#segGran5m').classList.add('active');
  } else {
    $('#segGran10m').classList.add('active');
  }
  
  // Initialize Overview Metric Filter
  const overviewFilter = $('#overviewMetricFilter');
  const btnOverviewTraffic = $('#btnOverviewTraffic');
  const btnOverviewConns = $('#btnOverviewConns');
  
  // Show filter only on dashboard tab (which is active by default)
  const activeTab = document.querySelector('.tab.active');
  const isDashboardActive = activeTab && activeTab.dataset.tab === 'dashboard';
  if (overviewFilter) {
    overviewFilter.style.display = isDashboardActive ? 'flex' : 'none';
  }
  
  if (btnOverviewTraffic && btnOverviewConns) {
    if (state.overviewMetric === 'traffic') {
      btnOverviewTraffic.classList.add('active');
      btnOverviewConns.classList.remove('active');
    } else {
      btnOverviewConns.classList.add('active');
      btnOverviewTraffic.classList.remove('active');
    }
  }
  
  // Initialize Chart library select dropdown
  const chartLibrarySelect = $('#chartLibrarySelect');
  if (chartLibrarySelect) {
    chartLibrarySelect.value = state.chartLibrary || 'amcharts';
    
    // Handler for chart library change
    chartLibrarySelect.onchange = () => {
      state.chartLibrary = chartLibrarySelect.value;
      localStorage.setItem('ui.chartLibrary', state.chartLibrary);
      
      // Re-render all charts with new library
      if (state.dashboard) {
        renderManagement(state.dashboard);
      } else {
        loadManagement();
      }
    };
  }
  
  // Initialize Users segmented controls
  const segCmpTraffic = $('#segCmpTraffic');
  const segCmpConns = $('#segCmpConns');
  
  if (segCmpTraffic && segCmpConns) {
    if (state.mainMetric === 'traffic') {
      segCmpTraffic.classList.add('active');
      segCmpConns.classList.remove('active');
    } else {
      segCmpConns.classList.add('active');
      segCmpTraffic.classList.remove('active');
    }
  }
  
  // Initialize Users section filters (synced with global overview filter)
  // Use overviewMetric if it exists, otherwise use mainMetric/miniMetric
  const activeMetric = state.overviewMetric || state.mainMetric || 'traffic';
  state.mainMetric = activeMetric;
  state.miniMetric = activeMetric;
  
  if (segCmpTraffic && segCmpConns) {
    if (state.mainMetric === 'traffic') {
      segCmpTraffic.classList.add('active');
      segCmpConns.classList.remove('active');
    } else {
      segCmpConns.classList.add('active');
      segCmpTraffic.classList.remove('active');
    }
  }
  
  const segMiniTraffic = $('#segMiniTraffic');
  const segMiniConns = $('#segMiniConns');
  
  if (segMiniTraffic && segMiniConns) {
    if (state.miniMetric === 'traffic') {
      segMiniTraffic.classList.add('active');
      segMiniConns.classList.remove('active');
    } else {
      segMiniConns.classList.add('active');
      segMiniTraffic.classList.remove('active');
    }
  }
  
  // Initialize Pause button state
  const btnPauseInit = $('#btnPause');
  if (btnPauseInit) {
    btnPauseInit.textContent = state.livePaused ? 'Resume' : 'Pause';
  }
  // Polling –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –Ω–∞ –≤–∫–ª–∞–¥–∫—É online —á–µ—Ä–µ–∑ startOnlinePolling()
  
  // Status badges click handlers
  const badgeUI = $('#badgeUI');
  const badgeXray = $('#badgeXray');
  const xrayActionEl = $('#xrayAction');
  
  if (badgeUI) {
    badgeUI.onclick = () => {
      setTab('settings'); // Status info is in settings
    };
  }
  
  if (badgeXray) {
    badgeXray.onclick = () => {
      setTab('settings'); // Status info is in settings
    };
    
    // Quick restart Xray from status badge
    if (xrayActionEl) {
      xrayActionEl.onclick = async (e) => {
        e.stopPropagation();
        const confirmed = await modal(
          '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray',
          '–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å Xray —Å–µ—Ä–≤–∏—Å?<br><br>–≠—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–µ—Ä–≤–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.',
          '',
          '–û—Ç–º–µ–Ω–∞',
          '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å',
          true
        );
        if (!confirmed) return;
        
        try {
          const res = await api('/api/system/restart?target=xray', { method: 'POST' });
          if (res.ok) {
            showToast('‚úÖ', 'Xray –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...');
            setTimeout(loadSystemStatus, 2000); // Refresh status after 2 seconds
          } else {
            showToast('‚ùå', res.error || '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞');
          }
        } catch (e) {
          console.error('Restart Xray error:', e);
          showToast('‚ùå', '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ Xray');
        }
      };
    }
  }
  
  // Collector badge click handler
  const badgeCollector = $('#badgeCollector');
  if (badgeCollector) {
    badgeCollector.onclick = () => {
      setTab('settings'); // Open settings where collector status is shown
    };
  }
  
  // Periodic refresh
  setInterval(loadSystemStatus, 10000);
  setInterval(loadCollectorStatus, 30000); // Refresh collector status every 30 seconds
  setInterval(() => {
    if (document.querySelector('.pane[data-pane="management"].active')) {
      loadManagement();
    }
  }, 60000);
}

// Wait for DOM to be ready
(function() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    // DOM already ready, but wait a bit to ensure all elements are rendered
    setTimeout(init, 100);
  }
})();
</script>
</body>
</html>
